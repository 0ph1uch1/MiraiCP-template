// This file is generated automatically by buildScript;
    // When contributing to this repository, please DO NOT edit this file.
    // Copyright (c) 2020 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <MiraiCP.hpp>
//from include/Bot.cpp
#include <atomic>
#include <memory>
#include <mutex>
namespace MiraiCP {
    struct InternalBot : public IMiraiData {
        std::string _avatarUrl;
        std::string _nickOrNameCard;
        QQID _id;
        explicit InternalBot(QQID in_botid) : _id(in_botid) {}
        ~InternalBot() override = default;
        void deserialize(nlohmann::json in_json) override {} // should never be called
        nlohmann::json internalToJson() const override {
            return {{"botid", _id}, {"type", MIRAI_OTHERTYPE}};
        }
        void refreshInfo() override {
            nlohmann::json j{{"source", internalToString()}};
            LowLevelAPI::info tmp = LowLevelAPI::info0(KtOperation::ktOperation(KtOperation::RefreshInfo, std::move(j)));
            _avatarUrl = std::move(tmp.avatarUrl);
            _nickOrNameCard = std::move(tmp.nickornamecard);
        }
    };
    inline std::shared_ptr<InternalBot> get_bot(QQID id) {
        static std::unordered_map<QQID, std::shared_ptr<InternalBot>> BotPool;
        static std::mutex mtx;
        std::lock_guard<std::mutex> lck(mtx);
        auto &Ptr = BotPool.try_emplace(id).first->second;
        if (!Ptr) Ptr = std::make_shared<InternalBot>(id);
        return Ptr;
    }
    Group Bot::getGroup(QQID groupid) const {
        return {groupid, InternalData->_id};
    }
    Friend Bot::getFriend(QQID i) const {
        return {i, InternalData->_id};
    }
    std::vector<QQID> Bot::getFriendList() const {
        nlohmann::json j{{"botid", InternalData->_id}};
        std::string temp = KtOperation::ktOperation(KtOperation::QueryBFL, std::move(j));
        return Tools::StringToVector(std::move(temp));
    }
    std::string Bot::FriendListToString() const {
        return Tools::VectorToString(getFriendList());
    }
    std::vector<QQID> Bot::getGroupList() const {
        nlohmann::json j{{"botid", InternalData->_id}};
        std::string temp = KtOperation::ktOperation(KtOperation::QueryBGL, std::move(j));
        return Tools::StringToVector(std::move(temp));
    }
    std::string Bot::GroupListToString() const {
        return Tools::VectorToString(getGroupList());
    }
    void Bot::refreshInfo() {
        InternalData->requestRefresh();
    }
    Bot::Bot(QQID in_id) : InternalData(get_bot(in_id)) {
        InternalData->forceRefreshNextTime();
    }
    std::string Bot::nick() {
        refreshInfo();
        std::shared_lock<std::shared_mutex> _lck(InternalData->getMutex());
        return InternalData->_nickOrNameCard;
    }
    std::string Bot::avatarUrl() {
        refreshInfo();
        std::shared_lock<std::shared_mutex> _lck(InternalData->getMutex());
        return InternalData->_avatarUrl;
    }
    QQID Bot::id() const {
        return InternalData->_id;
    }
} // namespace MiraiCP
//from include/CPPPlugin.cpp
namespace MiraiCP {
    // 静态区代码一般不会使用logger，虽是ub，但应该不会造成影响；
    // 静态区强行调用的话，因为loggerInterface尚未传入，若logger尚未初始化，访问Logger::logger将是ub
    // 可以考虑把logger做成纯静态实现？以及最好做成 Logger * const
    Logger *CPPPlugin::pluginLogger = &Logger::logger;
    std::unique_ptr<CPPPlugin> CPPPlugin::plugin = nullptr;
} // namespace MiraiCP
//from include/Command.cpp
namespace MiraiCP {
    CommandManager CommandManager::commandManager = CommandManager();
}
//from include/Contact.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    //    Contact Contact::deserialize(const std::string &source) {
    //        json j;
    //        try {
    //            j = json::parse(source);
    //        } catch (json::parse_error &e) {
    //            Logger::logger.error("json序列化错误 Contact::deserializationFromString");
    //            Logger::logger.error(source);
    //            Logger::logger.error(e.what());
    //        }
    //        return Contact::deserialize(j);
    //    }
    std::shared_ptr<Contact> Contact::deserializeToPointer(nlohmann::json j) {
        uint8_t thistype = j["type"];
        switch (thistype) {
            case MIRAI_FRIEND: {
                return std::make_shared<Friend>(std::move(j));
            }
            case MIRAI_MEMBER: {
                return std::make_shared<Member>(std::move(j));
            }
            case MIRAI_GROUP: {
                return std::make_shared<Group>(std::move(j));
            }
            default:
                assert(0);
                break;
        }
        return {};
        //        return Contact(j["type"],
        //                       j["id"],
        //                       j["groupid"],
        //                       j["nickornamecard"],
        //                       j["botid"],
        //                       j["anonymous"]);
    }
    //    void Contact::deserializeWriter(const nlohmann::json &source) {
    //        _type = static_cast<ContactType>(source["type"]);
    //        _id = source["id"];
    //        //        _groupid = source["groupid"];
    //        //        _nickOrNameCard = source["nickornamecard"];
    //        //        _botid = source["botid"];
    //        //        _anonymous = source["anonymous"];
    //    }
    //    Contact::Contact(const nlohmann::json &in_json)
    //        : Contact(in_json["id"], in_json["groupid"], static_cast<ContactType>(in_json["type"])) {
    //        // todo
    //    }
    //    Contact::Contact(QQID in_id, QQID in_botid, ContactType in_type) {
    //        // todo
    //    }
    MessageSource Contact::sendVoiceImpl(std::string path) const {
        json source{{"path", std::move(path)}};
        json j{{"source", source.dump()},
               {"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::Voice, std::move(j));
        if (re == "E1") {
            throw UploadException("上传语音文件格式不对(必须为.amr/.silk)或文件不存在", MIRAICP_EXCEPTION_WHERE);
        } else if (re == "E2") {
            throw UploadException("上传语音文件大小超过服务器限制，一般限制在1MB上下", MIRAICP_EXCEPTION_WHERE);
        }
        return MessageSource::deserializeFromString(re);
    }
    void IContactData::deserialize(nlohmann::json in_json) {
        using Tools::json_stringmover;
        _nickOrNameCard = json_stringmover(in_json, "nickornamecard");
        _avatarUrl = json_stringmover(in_json, "avatarUrl");
    }
    void IContactData::refreshInfo() {
        // default to Friend
        std::string temp = LowLevelAPI::getInfoSource(internalToString());
        if (temp == "E1") {
            throw FriendException(MIRAICP_EXCEPTION_WHERE);
        }
        LowLevelAPI::info tmp = LowLevelAPI::info0(temp);
        this->_nickOrNameCard = tmp.nickornamecard;
        this->_avatarUrl = tmp.avatarUrl;
    }
    nlohmann::json IContactData::internalToJson() const {
        return {{"nickornamecard", _nickOrNameCard}, {"id", _id}, {"botid", _botid}, {"type", _type}};
        // j["type"] = type();
        //            j["id"] = id();
        //            j["groupid"] = groupid();
        //            j["nickornamecard"] = nickOrNameCard();
        //            j["botid"] = botid();
    }
    nlohmann::json IContactData::getQuoteSign() const {
        return {{"MiraiCode", true}};
    }
    void IContactData::updateJson(json &json_to_update) const {
        json_to_update.update(toJson(), true);
    }
    nlohmann::json GroupRelatedData::internalToJson() const {
        auto result = IContactData::internalToJson();
        result["groupid"] = _groupid;
        return result;
    }
    nlohmann::json GroupRelatedData::getQuoteSign() const {
        auto ans = Super::getQuoteSign();
        ans["groupid"] = _groupid;
        return ans;
    }
    MessageSource Contact::quoteAndSend0(std::string msg, const MessageSource &ms) {
        json sign = InternalData->getQuoteSign();
        json obj{{"messageSource", ms.serializeToString()},
                 {"msg",           std::move(msg)},
                 {"sign",          sign.dump()}};
        std::string re = KtOperation::ktOperation(KtOperation::SendWithQuote, std::move(obj));
        MIRAICP_ERROR_HANDLE(re, "");
        return MessageSource::deserializeFromString(re);
    }
    Image Contact::uploadImg(const std::string &path) const {
        std::string re = LowLevelAPI::uploadImg0(path, toString());
        if (re == "E2")
            throw UploadException("上传图片大小超过30MB,路径:" + path, MIRAICP_EXCEPTION_WHERE);
        return Image::deserialize(re);
    }
    FlashImage Contact::uploadFlashImg(const std::string &path) const {
        std::string re = LowLevelAPI::uploadImg0(path, toString());
        if (re == "E2")
            throw UploadException("上传图片大小超过30MB,路径:" + path, MIRAICP_EXCEPTION_WHERE);
        return FlashImage::deserialize(re);
    }
    MessageSource Contact::sendMsgImpl(std::string msg, int retryTime, bool miraicode) const {
        if (msg.empty()) {
            throw IllegalArgumentException("不能发送空信息, 位置: Contact::SendMsg", MIRAICP_EXCEPTION_WHERE);
        }
        std::string re = LowLevelAPI::send0(std::move(msg), InternalData->toJson(), retryTime, miraicode,
                                            "reach a error area, Contact::SendMiraiCode");
        MIRAICP_ERROR_HANDLE(re, "");
        return MessageSource::deserializeFromString(re);
    }
} // namespace MiraiCP
//from include/Event.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    Event Event::processor;
    GroupMessageEvent::GroupMessageEvent(nlohmann::json j) : BotEvent(j["group"]["botid"]),
                                                             group(Contact::deserialize<Group>(Tools::json_jsonmover(j, "group"))),
                                                             sender(Tools::json_jsonmover(j, "member")),
                                                             message(MessageChain::deserializationFromMessageSourceJson(
                                                                             json::parse(j["source"].get<std::string>()))
                                                                             .plus(MessageSource::deserializeFromString(
                                                                                     j["source"].get<std::string>()))) {
    }
    MessageChain GroupMessageEvent::nextMessage(long time, bool halt) const {
        json j{{"contactSource", this->group.toString()}, {"time", time}, {"halt", halt}};
        std::string r = KtOperation::ktOperation(KtOperation::NextMsg, std::move(j));
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageSourceJson(json::parse(re["messageSource"].get<std::string>())).plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    MessageChain GroupMessageEvent::senderNextMessage(long time, bool halt) const {
        json j{{"contactSource", this->sender.toString()}, {"time", time}, {"halt", halt}};
        std::string r = KtOperation::ktOperation(KtOperation::NextMsg, std::move(j));
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageSourceJson(json::parse(re["messageSource"].get<std::string>())).plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    PrivateMessageEvent::PrivateMessageEvent(nlohmann::json j) : BotEvent(j["friend"]["botid"]),
                                                                 sender(Contact::deserialize<Friend>(Tools::json_jsonmover(j, "friend"))),
                                                                 message(MessageChain::deserializationFromMessageSourceJson(
                                                                                 json::parse(j["source"].get<std::string>()))
                                                                                 .plus(MessageSource::deserializeFromString(
                                                                                         j["source"].get<std::string>()))) {
    }
    MessageChain PrivateMessageEvent::nextMessage(long time, bool halt) const {
        json j{{"contactSource", this->sender.toString()}, {"time", time}, {"halt", halt}};
        std::string r = KtOperation::ktOperation(KtOperation::NextMsg, std::move(j));
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageSourceJson(json::parse(re["messageSource"].get<std::string>())).plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    GroupInviteEvent::GroupInviteEvent(nlohmann::json j) : BotEvent(j["source"]["botid"]),
                                                           source(Tools::json_stringmover(j, "request")),
                                                           inviterNick(Tools::json_stringmover(j["source"], "inviternick")),
                                                           groupName(Tools::json_stringmover(j["source"], "groupname")),
                                                           groupid(j["source"]["groupid"]),
                                                           inviterid(j["source"]["inviterid"]) {
    }
    void GroupInviteEvent::operation0(const std::string &source, QQID botid, bool accept) {
        nlohmann::json j{{"text", source}, {"accept", accept}, {"botid", botid}};
        std::string re = KtOperation::ktOperation(KtOperation::Gioperation, std::move(j));
        if (re == "E") Logger::logger.error("群聊邀请事件同意失败(可能因为重复处理),id:" + source);
    }
    NewFriendRequestEvent::NewFriendRequestEvent(nlohmann::json j) : BotEvent(j["source"]["botid"]),
                                                                     source(Tools::json_stringmover(j, "request")),
                                                                     fromid(j["source"]["fromid"]),
                                                                     fromgroupid(j["source"]["fromgroupid"]),
                                                                     nick(Tools::json_stringmover(j["source"], "fromnick")),
                                                                     message(Tools::json_stringmover(j["source"], "message")) {
    }
    void NewFriendRequestEvent::operation0(const std::string &source, QQID botid, bool accept, bool ban) {
        nlohmann::json j{{"text", source}, {"accept", accept}, {"botid", botid}, {"ban", ban}};
        std::string re = KtOperation::ktOperation(KtOperation::Nfroperation, std::move(j));
        if (re == "E") Logger::logger.error("好友申请事件同意失败(可能因为重复处理),id:" + source);
    }
    MemberJoinEvent::MemberJoinEvent(nlohmann::json j) : BotEvent(j["group"]["botid"]),
                                                         type(joinType(j["jointype"].get<int>())),
                                                         member(Contact::deserialize<Member>(Tools::json_jsonmover(j, "member"))),
                                                         group(Contact::deserialize<Group>(Tools::json_jsonmover(j, "group"))),
                                                         inviterid(j["inviterid"]) {
    }
    MemberLeaveEvent::MemberLeaveEvent(nlohmann::json j) : BotEvent(j["group"]["botid"]),
                                                           memberid(j["memberid"]),
                                                           group(Contact::deserialize<Group>(Tools::json_jsonmover(j, "group"))),
                                                           operaterid(j["operatorid"]),
                                                           type(j["leavetype"]) {
    }
    RecallEvent::RecallEvent(nlohmann::json j) : BotEvent(j["botid"]),
                                                 type(j["etype"]),
                                                 time(j["time"]),
                                                 authorid(j["authorid"]),
                                                 operatorid(j["operatorid"]),
                                                 ids(Tools::json_stringmover(j, "ids")),
                                                 internalids(Tools::json_stringmover(j, "internalids")),
                                                 groupid(j["groupid"]) {
    }
    BotJoinGroupEvent::BotJoinGroupEvent(nlohmann::json j) : BotEvent(j["group"]["botid"]),
                                                             group(Contact::deserialize<Group>(Tools::json_jsonmover(j, "group"))),
                                                             inviterid(j["inviterid"]),
                                                             type(j["etype"]) {
    }
    GroupTempMessageEvent::GroupTempMessageEvent(nlohmann::json j) : BotEvent(j["group"]["botid"]),
                                                                     group(Contact::deserialize<Group>(Tools::json_jsonmover(j, "group"))),
                                                                     sender(Contact::deserialize<Member>(Tools::json_jsonmover(j, "member"))),
                                                                     message(MessageChain::deserializationFromMessageSourceJson(json::parse(j["message"].get<std::string>()))
                                                                                     .plus(MessageSource::deserializeFromString(j["source"]))) {
    }
    NudgeEvent::NudgeEvent(nlohmann::json j) : BotEvent(j["botid"]),
                                               from(Contact::deserializeToPointer(Tools::json_jsonmover(j, "from"))),
                                               target(Contact::deserializeToPointer(Tools::json_jsonmover(j, "target"))),
                                               subject(Contact::deserializeToPointer(Tools::json_jsonmover(j, "subject"))) {
    }
    BotLeaveEvent::BotLeaveEvent(nlohmann::json j) : BotEvent(j["botid"]),
                                                     groupid(j["groupid"]), type(j["type"].get<EventType>()) {
        QQID val = j["operatorid"];
        if (val != (QQID) -1) {
            this->operatorId = val;
        }
    }
    MemberJoinRequestEvent::MemberJoinRequestEvent(nlohmann::json j) : BotEvent(j["group"]["botid"]),
                                                                       source(j["requestData"]),
                                                                       group(Contact::deserialize<Group>(j["group"])),
                                                                       inviter(j["inviter"]["id"] != 0 ? std::optional<Member>(Contact::deserialize<Member>(j["inviter"])) : std::optional<Member>(std::nullopt)),
                                                                       requesterId(j["requester"]) {
    }
    void MemberJoinRequestEvent::operate(std::string_view s, QQID botid, bool sign, const std::string &msg) {
        nlohmann::json j{{"source", s}, {"botid", botid}, {"sign", sign}, {"msg", msg}};
        KtOperation::ktOperation(KtOperation::MemberJoinRequest, std::move(j));
    }
    MessagePreSendEvent::MessagePreSendEvent(nlohmann::json j) : BotEvent(j["botid"]),
                                                                 target(Contact::deserializeToPointer(Tools::json_jsonmover(j, "target"))),
                                                                 message(MessageChain::deserializationFromMessageSourceJson(j["message"].get<std::string>(), false)) {
    }
    void Event::incomingEvent(json j, int type) {
        switch (type) {
            case eventTypes::GroupMessageEvent: {
                //GroupMessage
                Event::broadcast(GroupMessageEvent(std::move(j)));
                break;
            }
            case eventTypes::PrivateMessageEvent: {
                //私聊消息
                Event::broadcast(PrivateMessageEvent(std::move(j)));
                break;
            }
            case eventTypes::GroupInviteEvent: {
                //群聊邀请
                Event::broadcast(GroupInviteEvent(std::move(j)));
                break;
            }
            case eventTypes::NewFriendRequestEvent: {
                //好友
                Event::broadcast(NewFriendRequestEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberJoinEvent: { //新成员加入
                Event::broadcast(MemberJoinEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberLeaveEvent: {
                //群成员退出
                Event::broadcast(MemberLeaveEvent(std::move(j)));
                break;
            }
            case eventTypes::RecallEvent: {
                Event::broadcast(RecallEvent(std::move(j)));
                break;
            }
            case eventTypes::BotJoinGroupEvent: {
                Event::broadcast(BotJoinGroupEvent(std::move(j)));
                break;
            }
            case eventTypes::GroupTempMessageEvent: {
                Event::broadcast(GroupTempMessageEvent(std::move(j)));
                break;
            }
            case eventTypes::TimeOutEvent: {
                Event::broadcast(TimeOutEvent(Tools::json_stringmover(j, "msg")));
                break;
            }
            case eventTypes::BotOnlineEvent: {
                Event::broadcast(BotOnlineEvent(j["botid"].get<QQID>()));
                break;
            }
            case eventTypes::NudgeEvent: {
                Event::broadcast(NudgeEvent(std::move(j)));
                break;
            }
            case eventTypes::BotLeaveEvent: {
                Event::broadcast(BotLeaveEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberJoinRequestEvent: {
                Event::broadcast(MemberJoinRequestEvent(std::move(j)));
                break;
            }
            case eventTypes::MessagePreSendEvent: {
                Event::broadcast(MessagePreSendEvent(std::move(j)));
                break;
            }
            case eventTypes::Command: {
                // command
                CommandManager::commandManager[j["bindId"]]->onCommand(
                        j.contains("contact") ? Contact::deserializeToPointer(Tools::json_jsonmover(j, "contact")) : nullptr,
                        Bot(j["botid"]),
                        MessageChain::deserializationFromMessageSourceJson(
                                j.contains("message") ? j["message"].get<std::string>() : "",
                                false));
                break;
            }
            default: {
                throw APIException("Unreachable code", MIRAICP_EXCEPTION_WHERE);
            }
        }
    }
} // namespace MiraiCP
//from include/Exception.cpp
namespace MiraiCP {
    void MiraiCPExceptionBase::basicRaise() const {
        Logger::logger.error(this->what());
    }
    void MiraiCPExceptionBase::raise() const {
        this->basicRaise();
        if (!filename.empty() && lineNum != 0) {
            Logger::logger.error("文件名:" + filename + "\n行号:" + std::to_string(lineNum));
        }
    }
    std::string MiraiCPThreadException::getThreadIdStr(const std::thread::id &id) {
        static std::stringstream ss;
        ss << id;
        auto result = ss.str();
        ss.str("");
        return result;
    }
} // namespace MiraiCP
//from include/ForwardedMessage.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    ForwardedNode::ForwardedNode(QQID id, std::string name, ForwardedMessage _message, int t, std::optional<ForwardedMessageDisplayStrategy> display)
        : id(id), name(std::move(name)),
          message(std::make_shared<ForwardedMessage>(std::move(_message))),
          time(t), isForwardedMessage(true), display(std::move(display)) {}
    bool BaseForwardedMessage::operator==(const BaseForwardedMessage &m) const {
        if (this->nodes.size() != m.nodes.size()) return false;
        int i = 0;
        return std::all_of(this->nodes.begin(), this->nodes.end(), [&i, &m](const auto &n) {
            return n.message == m[i++].message;
        });
    }
    json ForwardedMessage::nodesToJson() { // NOLINT(misc-no-recursion)
        auto value = json::array();
        for (const ForwardedNode &node: nodes) {
            json temp{{"id", node.id}, {"time", node.time}, {"name", node.name}};
            if (node.isForwarded()) {
                temp["isForwardedMessage"] = true;
                temp["message"] = std::get<std::shared_ptr<ForwardedMessage>>(node.message)->nodesToJson().dump();
                if (display.has_value())
                    temp["display"] = display->toJson();
            } else {
                temp["message"] = std::get<MessageChain>(node.message).toMiraiCode();
            }
            value.emplace_back(std::move(temp));
        }
        json tmp2 = this->sendmsg;
        tmp2["value"] = std::move(value);
        return tmp2;
    }
    //发送这个聊天记录
    MessageSource ForwardedMessage::sendTo(Contact *c) {
        json text = c->toJson();
        text["content"] = this->nodesToJson();
        json temp{{"text", text.dump()}};
        temp["botid"] = c->botid();
        if (display.has_value())
            temp["display"] = display->toJson();
        std::string re = KtOperation::ktOperation(KtOperation::Buildforward, std::move(temp));
        MIRAICP_ERROR_HANDLE(re, "");
        return MessageSource::deserializeFromString(re);
    }
    ForwardedMessage ForwardedMessage::deserializationFromMessageSourceJson(const json &j) {
        std::vector<ForwardedNode> nodes;
        try {
            for (auto &&a: j) {
                if (a["messageChain"][0].contains("kind") && a["messageChain"][0]["kind"] == "FORWARD") {
                    nodes.emplace_back(a["senderId"], a["senderName"], ForwardedMessage::deserializationFromMessageSourceJson(a["messageChain"][1]["nodeList"]), a["time"], ForwardedMessageDisplayStrategy::defaultStrategy());
                } else {
                    nodes.emplace_back(a["senderId"], a["senderName"], MessageChain::deserializationFromMessageSourceJson(a["messageChain"], false), a["time"]);
                }
            }
        } catch (const json::exception &) {
            throw APIException("ForwardedMessage格式化异常", MIRAICP_EXCEPTION_WHERE);
        }
        return ForwardedMessage(std::move(nodes));
    }
    OnlineForwardedMessage OnlineForwardedMessage::deserializationFromMessageSourceJson(const json &j) {
        std::vector<ForwardedNode> nodes;
        try {
            for (auto &&a: j[1]["nodeList"]) {
                if (a["messageChain"][0].contains("kind") && a["messageChain"][0]["kind"] == "FORWARD") {
                    nodes.emplace_back(a["senderId"], a["senderName"], ForwardedMessage::deserializationFromMessageSourceJson(a["messageChain"][1]["nodeList"]), a["time"], ForwardedMessageDisplayStrategy::defaultStrategy());
                } else {
                    nodes.emplace_back(a["senderId"], a["senderName"], MessageChain::deserializationFromMessageSourceJson(a["messageChain"], false), a["time"]);
                }
            }
        } catch (const json::parse_error &) {
            throw APIException("OnlineForwardedMessage格式化异常", MIRAICP_EXCEPTION_WHERE);
        }
        //if (j[0].contains("resourceId") && !j[0]["resourceId"].is_null())
        return OnlineForwardedMessage(j[0]["origin"], /*j[0]["resourceId"],*/ std::move(nodes));
        //else
        // return OnlineForwardedMessage(j[0]["origin"], std::nullopt, std::move(nodes));
    }
    ForwardedMessage OnlineForwardedMessage::toForwardedMessage(std::optional<ForwardedMessageDisplayStrategy> display) const {
        return ForwardedMessage(this->nodes, std::move(display));
    }
} // namespace MiraiCP
//from include/Friend.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    auto GetFriendPool(QQID id, QQID botid) noexcept {
        static std::unordered_map<QQID, std::unordered_map<QQID, std::shared_ptr<Friend::DataType>>> Pool;
        auto &val = Pool[botid][id];
        if (!val) {
            val = std::make_shared<Friend::DataType>();
            val->_id = id;
            val->_botid = botid;
            val->_type = MIRAI_FRIEND;
        }
        return val;
    }
    auto GetFriendPool(const json &in_json) {
        try {
            return GetFriendPool(in_json["id"], in_json["botid"]);
        } catch (const nlohmann::detail::exception &) {
            throw IllegalArgumentException("构造Friend时传入的json异常", MIRAICP_EXCEPTION_WHERE);
        }
    }
    /*好友类实现*/
    Friend::Friend(QQID id, QQID botid) : Contact(GetFriendPool(id, botid)) {
        forceRefreshNextTime(); //InternalData->requestRefresh();
    }
    Friend::Friend(nlohmann::json in_json) : Contact(GetFriendPool(in_json)) {
        auto ActualDataPtr = GetDataInternal();
        assert(ActualDataPtr != nullptr);
        bool needRefresh = false;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_nickOrNameCard = Tools::json_stringmover(in_json, "nickornamecard");
        else
            needRefresh = true;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_avatarUrl = Tools::json_stringmover(in_json, "avatarUrl");
        else
            needRefresh = true;
        if (needRefresh) forceRefreshNextTime();
    }
    void Friend::deleteFriend() {
        json j{{"source", toString()}, {"quit", true}};
        KtOperation::ktOperation(KtOperation::RefreshInfo, std::move(j));
    }
    //    void Friend::refreshInfo() {
    //        InternalData->requestRefresh();
    //        //        std::string temp = LowLevelAPI::getInfoSource(this->toString());
    //        //        if (temp == "E1") {
    //        //            throw FriendException(MIRAICP_EXCEPTION_WHERE);
    //        //        }
    //        //        LowLevelAPI::info tmp = LowLevelAPI::info0(temp);
    //        //        this->_nickOrNameCard = tmp.nickornamecard;
    //        //        this->_avatarUrl = tmp.avatarUrl;
    //    }
    void Friend::sendNudge() {
        json j{{"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::SendNudge, std::move(j));
        if (re == "E1")
            throw IllegalStateException("发送戳一戳失败，登录协议不为phone/ipad", MIRAICP_EXCEPTION_WHERE);
    }
} // namespace MiraiCP
//from include/Group.cpp
namespace MiraiCP {
#define LOC_CLASS_NAMESPACE Group
    using json = nlohmann::json;
    std::string Group::MemberListToString() {
        return Tools::VectorToString(getMemberList());
    }
    auto GetGroupFromPool(QQID groupid, QQID botid) noexcept {
        static std::unordered_map<QQID, std::unordered_map<QQID, std::shared_ptr<Group::DataType>>> Pool;
        auto &Val = Pool[botid][groupid];
        if (!Val) {
            Val = std::make_shared<Group::DataType>(groupid);
            Val->_botid = botid;
            Val->_id = groupid;
            Val->_type = MIRAI_GROUP;
        }
        return Val;
    }
    auto GetGroupFromPool(const json &in_json) {
        try {
            // todo(Antares): group 的 in_json 的 groupid 项是空值就很离谱，上游这里为什么这样设计？
            return GetGroupFromPool(in_json["id"], in_json["botid"]);
        } catch (const nlohmann::detail::exception &) {
            throw IllegalArgumentException("构造Group时传入的json异常", MIRAICP_EXCEPTION_WHERE);
        }
    }
    Group::Group(QQID groupid, QQID botid) : Contact(GetGroupFromPool(groupid, botid)) {
        forceRefreshNextTime();
    }
    Group::Group(json in_json) : Contact(GetGroupFromPool(in_json)) {
        auto ActualDataPtr = GetDataInternal();
        assert(ActualDataPtr != nullptr);
        bool needRefresh = false;
        if (in_json.contains("nickornamecard")) ActualDataPtr->_nickOrNameCard = Tools::json_stringmover(in_json, "nickornamecard");
        else
            needRefresh = true;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_avatarUrl = Tools::json_stringmover(in_json, "avatarUrl");
        else
            needRefresh = true;
        if (needRefresh) forceRefreshNextTime();
    }
    std::vector<Group::OnlineAnnouncement> Group::getAnnouncementsList() {
        json j{{"source", toString()}, {"announcement", true}};
        std::string re = KtOperation::ktOperation(KtOperation::RefreshInfo, std::move(j));
        std::vector<OnlineAnnouncement> oa;
        for (const json &e: json::parse(re)) {
            oa.push_back(Group::OnlineAnnouncement::deserializeFromJson(e));
        }
        return oa;
    }
    void Group::OnlineAnnouncement::deleteThis() {
        json i{{"botid", botid}, {"groupid", groupid}, {"fid", fid}, {"type", 1}};
        json j{{"identify", i.dump()}};
        std::string re = KtOperation::ktOperation(KtOperation::Announcement, std::move(j));
        if (re == "E1")
            throw IllegalArgumentException("无法根据fid找到群公告(群公告不存在)", MIRAICP_EXCEPTION_WHERE);
        if (re == "E3")
            throw IllegalStateException("群公告状态异常", MIRAICP_EXCEPTION_WHERE);
    }
    json Group::AnnouncementParams::serializeToJson() {
        return {
                {"sendToNewMember", send2new},
                {"isPinned", pinned},
                {"showEditCard", showEditCard},
                {"showPopup", showPopup},
                {"requireConfirmation", requireConfirm}};
    }
    Group::OnlineAnnouncement Group::OfflineAnnouncement::publishTo(const Group &g) {
        json i{{"botid", g.botid()}, {"groupid", g.id()}, {"type", 2}};
        json s{{"content", content}, {"params", params.serializeToJson()}};
        json j{{"identify", i.dump()}, {"source", s.dump()}};
        std::string re = KtOperation::ktOperation(KtOperation::Announcement, std::move(j));
        return Group::OnlineAnnouncement::deserializeFromJson(json::parse(re));
    }
    Group::OnlineAnnouncement Group::OnlineAnnouncement::deserializeFromJson(const json &j) {
        return Group::OnlineAnnouncement{
                j["content"],
                j["botid"],
                j["groupid"],
                j["senderid"],
                j["time"],
                j["fid"],
                j["imageid"],
                j["confirmationNum"],
                {j["params"]["sendToNewMember"],
                 j["params"]["requireConfirmation"],
                 j["params"]["isPinned"],
                 j["params"]["showEditCard"],
                 j["params"]["showPopup"]}};
    }
    std::vector<unsigned long long> Group::getMemberList() {
        nlohmann::json j{{"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::QueryML, std::move(j));
        if (re == "E1") {
            throw GroupException(MIRAICP_EXCEPTION_WHERE);
        }
        return Tools::StringToVector(std::move(re));
    }
    void Group::quit() {
        nlohmann::json j{{"source", toString()}, {"quit", true}};
        KtOperation::ktOperation(KtOperation::RefreshInfo, std::move(j));
    }
    void Group::updateSetting(GroupData::GroupSetting newSetting) {
        json j{
                {"name", std::move(newSetting.name)},
                {"isMuteAll", newSetting.isMuteAll},
                {"isAllowMemberInvite", newSetting.isAllowMemberInvite},
                {"isAutoApproveEnabled", newSetting.isAutoApproveEnabled},
                {"isAnonymousChatEnabled", newSetting.isAnonymousChatEnabled}};
        json tmp{{"source", j.dump()}, {"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::GroupSetting, std::move(tmp));
        InternalData->forceRefreshNextTime();
    }
    RemoteFile Group::sendFile(const std::string &path, const std::string &filepath) {
        json source{{"path", path}, {"filepath", filepath}};
        json tmp{{"source", source.dump()}, {"contactSource", toString()}};
        std::string result = KtOperation::ktOperation(KtOperation::SendFile, std::move(tmp));
        if (result == "E2") throw UploadException("找不到" + filepath + "位置:C-uploadfile", MIRAICP_EXCEPTION_WHERE);
        if (result == "E3")
            throw UploadException("Upload error:路径格式异常，应为'/xxx.xxx'或'/xx/xxx.xxx'目前只支持群文件和单层路径, path:" + path, MIRAICP_EXCEPTION_WHERE);
        return RemoteFile::deserializeFromString(result);
    }
    RemoteFile Group::getFile(const std::string &path, const std::string &id) {
        // source 参数
        if (path.empty() || path == "/")
            return this->getFileById(id);
        json tmp{{"id", id}, {"path", path}};
        json j{{"source", tmp.dump()}, {"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::RemoteFileInfo, std::move(j));
        if (re == "E2") throw RemoteAssetException("Get error: 文件路径不存在, path:" + path + ",id:" + id, MIRAICP_EXCEPTION_WHERE);
        return RemoteFile::deserializeFromString(re);
    }
    RemoteFile Group::getFileById(const std::string &id) {
        json tmp{{"id", id}};
        json j{{"source", tmp.dump()}, {"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::RemoteFileInfo, std::move(j));
        if (re == "E1") throw RemoteAssetException("Get error: 文件路径不存在, id:" + id, MIRAICP_EXCEPTION_WHERE);
        return RemoteFile::deserializeFromString(re);
    }
    Member Group::getOwner() {
        json j{{"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::QueryOwner, std::move(j));
        return Member(stoi(re), this->id(), this->botid());
    }
    std::string Group::getFileListString(const std::string &path) {
        json temp{{"id", "-1"}, {"path", path}};
        json j{{"source", temp.dump()}, {"contactSource", toString()}};
        return KtOperation::ktOperation(KtOperation::RemoteFileInfo, std::move(j));
    }
    std::vector<Group::file_short_info> Group::getFileList(const std::string &path) {
        std::vector<file_short_info> re = std::vector<file_short_info>();
        std::string tmp = getFileListString(path);
        json root = json::parse(tmp);
        for (auto &i: root) {
            file_short_info t;
            t.path = i[0];
            t.id = i[1];
            re.push_back(t);
        }
        return re;
    }
    Member Group::getMember(QQID memberid) {
        return Member(memberid, this->id(), this->botid());
    }
    Member Group::operator[](QQID a) {
        return getMember(a);
    }
    IMPL_GETTER(setting)
    void GroupData::refreshInfo() {
        std::string re = LowLevelAPI::getInfoSource(internalToString());
        LowLevelAPI::info tmp = LowLevelAPI::info0(re);
        this->_nickOrNameCard = std::move(tmp.nickornamecard);
        this->_avatarUrl = std::move(tmp.avatarUrl);
        nlohmann::json j = nlohmann::json::parse(re)["setting"];
        this->_setting.name = Tools::json_stringmover(j, "name");
        this->_setting.isMuteAll = j["isMuteAll"];
        this->_setting.isAllowMemberInvite = j["isAllowMemberInvite"];
        this->_setting.isAutoApproveEnabled = j["isAutoApproveEnabled"];
        this->_setting.isAnonymousChatEnabled = j["isAnonymousChatEnabled"];
    }
    void GroupData::deserialize(nlohmann::json in_json) {
        _groupid = in_json["groupid"];
        IContactData::deserialize(std::move(in_json));
    }
#undef LOC_CLASS_NAMESPACE
} // namespace MiraiCP
//from include/IMiraiData.cpp
// Copyright (c) 2022 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <mutex>
namespace MiraiCP {
    void IMiraiData::requestRefresh() {
        if (!MiraiCP::checkSafeCall() || Locker._inited.exchange(true)) return;
        std::unique_lock<std::shared_mutex> _lck(Locker._mtx);
        refreshInfo();
    }
    void IMiraiData::forceRefreshNextTime() {
        Locker._inited = false;
    }
    std::string IMiraiData::toString() const {
        return toJson().dump();
    }
    nlohmann::json IMiraiData::toJson() const {
        std::shared_lock<std::shared_mutex> lck(Locker._mtx);
        return internalToJson();
    }
    nlohmann::json IMiraiData::internalToString() const {
        return internalToJson().dump();
    }
} // namespace MiraiCP
//from include/KtOperation.cpp
// -----------------------
namespace MiraiCP::KtOperation {
    std::string ktOperation(operation_set type, nlohmann::json data, bool catchErr, const std::string &errorInfo) {
        nlohmann::json j{{"type",type},{"data", std::move(data)}};
        std::string re = LibLoader::LoaderApi::pluginOperation(j.dump());
        if (catchErr) MIRAICP_ERROR_HANDLE(re, errorInfo);
        return re;
    }
} // namespace MiraiCP::KtOperation
//from include/Logger.cpp
namespace MiraiCP {
    Logger Logger::logger;
    void Logger::log_interface(const std::string &content, int level) {
        handler_trigger(content, level);
        LibLoader::LoaderApi::loggerInterface(content, ("plugin/" + MiraiCP::CPPPlugin::config.getName()), -1, level);
    }
    void IdLogger::log_interface(const std::string &content, int level) {
        handler_trigger(content, level);
        LibLoader::LoaderApi::loggerInterface(content, "", static_cast<long long>(id), level);
    }
} // namespace MiraiCP
//from include/LowLevelAPI.cpp
#include <utility>
namespace LibLoader::LoaderApi {
    const interface_funcs *get_loader_apis();
}
namespace MiraiCP {
    using json = nlohmann::json;
    std::string LowLevelAPI::send0(std::string content, json c, int retryTime, bool miraicode,
                                   const std::string &errorInfo) {
        nlohmann::json tmp{{"content", std::move(content)}, {"contact", std::move(c)}};
        nlohmann::json j{{"source", tmp.dump()}, {"miraiCode", miraicode}, {"retryTime", retryTime}};
        return KtOperation::ktOperation(KtOperation::Send, std::move(j), true, errorInfo);
    }
    LowLevelAPI::info LowLevelAPI::info0(const std::string &source) {
        MIRAICP_ERROR_HANDLE(source, "");
        auto j = nlohmann::json::parse(source);
        info re{Tools::json_stringmover(j, "nickornamecard"), Tools::json_stringmover(j, "avatarUrl")};
        return re;
    }
    std::string LowLevelAPI::getInfoSource(std::string c) {
        nlohmann::json j{{"source", std::move(c)}};
        return KtOperation::ktOperation(KtOperation::RefreshInfo, std::move(j));
    }
    std::string LowLevelAPI::uploadImg0(std::string path, std::string c) {
        nlohmann::json j{{"fileName", std::move(path)}, {"source", std::move(c)}};
        return KtOperation::ktOperation(KtOperation::UploadImg, std::move(j));
    }
    bool checkSafeCall() {
        return LibLoader::LoaderApi::get_loader_apis() != nullptr;
    }
} // namespace MiraiCP
//from include/Member.cpp
namespace MiraiCP {
#define LOC_CLASS_NAMESPACE Member
    using json = nlohmann::json;
    auto GetMemberFromPool(QQID id, QQID groupid, QQID botid) noexcept {
        using Tools::idpair;
        static std::unordered_map<idpair, std::unordered_map<QQID, std::shared_ptr<Member::DataType>>> Pool;
        idpair pr{botid, groupid};
        auto &Val = Pool[pr][id];
        if (!Val) {
            Val = std::make_shared<Member::DataType>(groupid);
            Val->_id = id;
            Val->_botid = botid;
            Val->_type = MIRAI_MEMBER;
        }
        return Val;
    }
    auto GetMemberFromPool(const json &in_json) {
        try {
            return GetMemberFromPool(in_json["id"], in_json["groupid"], in_json["botid"]);
        } catch (const nlohmann::detail::exception &) {
            throw IllegalArgumentException("构造Member时传入的json异常", MIRAICP_EXCEPTION_WHERE);
        }
    }
    Member::Member(QQID id, QQID groupid, QQID botid)
        : Contact(GetMemberFromPool(id, groupid, botid)) {
        forceRefreshNextTime();
    }
    Member::Member(nlohmann::json in_json) : Contact(GetMemberFromPool(in_json)) {
        auto ActualDataPtr = GetDataInternal();
        assert(ActualDataPtr != nullptr);
        bool needrefresh = false;
        if (in_json.contains("nickornamecard")) ActualDataPtr->_nickOrNameCard = Tools::json_stringmover(in_json, "nickornamecard");
        else
            needrefresh = true;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_avatarUrl = Tools::json_stringmover(in_json, "avatarUrl");
        else
            needrefresh = true;
        if (in_json.contains("anonymous")) ActualDataPtr->_anonymous = in_json["anonymous"].get<bool>();
        else
            needrefresh = true;
        if (needrefresh) forceRefreshNextTime();
    }
    void Member::mute(long long sec) const {
        json j{{"time", sec}, {"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::MuteM, std::move(j));
        if (re == "E4")
            throw MuteException(MIRAICP_EXCEPTION_WHERE);
    }
    void Member::kick(std::string reason) {
        json j{{"message", std::move(reason)}, {"contactSource", toString()}};
        KtOperation::ktOperation(KtOperation::KickM, std::move(j));
        forceRefreshNextTime();
    }
    void Member::modifyAdmin(bool admin) {
        if (anonymous()) return;
        json j{{"admin", admin}, {"contactSource", toString()}};
        KtOperation::ktOperation(KtOperation::ModifyAdmin, std::move(j));
        forceRefreshNextTime();
    }
    void Member::changeNameCard(std::string_view newName) {
        if (anonymous()) return;
        json j{{"contactSource", toString()}, {"newName", newName}};
        KtOperation::ktOperation(KtOperation::ChangeNameCard, std::move(j));
        forceRefreshNextTime();
    }
    void Member::sendNudge() {
        if (anonymous()) return;
        json j{{"contactSource", toString()}};
        std::string re = KtOperation::ktOperation(KtOperation::SendNudge, std::move(j));
        if (re == "E1")
            throw IllegalStateException("发送戳一戳失败，登录协议不为phone", MIRAICP_EXCEPTION_WHERE);
    }
    void MemberData::deserialize(nlohmann::json in_json) {
        _groupid = in_json["groupid"];
        _anonymous = in_json["anonymous"].get<bool>();
        IContactData::deserialize(std::move(in_json));
    }
    void MemberData::refreshInfo() {
        if (_anonymous) return;
        auto tempserialize = internalToString();
        std::string result = LowLevelAPI::getInfoSource(tempserialize);
        if (result == "E1")
            throw MemberException(1, MIRAICP_EXCEPTION_WHERE);
        if (result == "E2")
            throw MemberException(2, MIRAICP_EXCEPTION_WHERE);
        {
            LowLevelAPI::info tmp = LowLevelAPI::info0(result);
            this->_nickOrNameCard = tmp.nickornamecard;
            this->_avatarUrl = tmp.avatarUrl;
        }
        {
            json j{{"contactSource", std::move(tempserialize)}};
            _permission = stoi(KtOperation::ktOperation(KtOperation::QueryM, std::move(j)));
        }
    }
    IMPL_GETTER(anonymous)
    IMPL_GETTER(permission)
#undef LOC_CLASS_NAMESPACE
} // namespace MiraiCP
//from include/MessageChain.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    std::string MessageChain::toMiraiCode() const {
        return Tools::VectorToString(this->toMiraiCodeVector(), "");
    }
    MessageSource MessageChain::quoteAndSend0(std::string msg, QQID groupid) {
        json sign{{"MiraiCode", true},
                  {"groupid",   groupid}};
        json obj{{"messageSource", source->serializeToString()},
                 {"msg",           std::move(msg)},
                 {"sign",          sign.dump()}};
        std::string re = KtOperation::ktOperation(KtOperation::SendWithQuote, std::move(obj));
        return MessageSource::deserializeFromString(re);
    }
    //message chain
    MessageChain MessageChain::deserializationFromMiraiCode(const std::string &m) {
        size_t pos = 0;
        size_t lastPos = -1;
        MessageChain mc;
        if (m.length() <= 7) {
            return MessageChain(PlainText(m));
        }
        do {
            if (m.length() - 7 - pos > 0 && m.substr(pos, 7) == "[mirai:") {
                if (pos - lastPos > 1)
                    mc.add(PlainText(m.substr(lastPos + 1, pos - lastPos - 1))); // plain text
                size_t back = MessageChain::findEnd(m, pos);
                if (back == (size_t) -1) throw IllegalStateException("", MIRAICP_EXCEPTION_WHERE);
                std::string tmp = m.substr(pos, back - pos);
                tmp = Tools::replace(std::move(tmp), "[mirai:", "");
                size_t i = tmp.find(':'); // first :
                int t = SingleMessage::getKey(tmp.substr(0, i));
                switch (t) {
                    case 0:
                        // no miraiCode key is PlainText
                        Logger::logger.error("无法预料的错误, 信息: " + m);
                        break;
                    case 1:
                        mc.add(At(std::stoll(tmp.substr(i + 1, tmp.length() - i - 1))));
                        break;
                    case 2:
                        mc.add(AtAll());
                        break;
                    case 3:
                        mc.add(Image(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case 4:
                        mc.add(LightApp(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case 5: {
                        size_t comma = tmp.find(',');
                        mc.add(ServiceMessage(std::stoi(tmp.substr(i + 1, comma - i - 1)),
                                              tmp.substr(comma + 1, tmp.length() - comma - 1)));
                        break;
                    }
                    case 6: {
                        //[mirai:file:/b53231e8-46dd-11ec-8ba5-5452007bd6c0,102,run.bat,55]
                        size_t comma1 = tmp.find(',');
                        size_t comma2 = tmp.find(',', comma1 + 1);
                        size_t comma3 = tmp.find(',', comma2 + 1);
                        mc.add(RemoteFile(tmp.substr(i + 1, comma1 - i - 1),
                                          std::stoi(tmp.substr(comma1 + 1, comma2 - comma1 - 1)),
                                          tmp.substr(comma2 + 1, comma3 - comma2 - 1),
                                          std::stoll(tmp.substr(comma3 + 1, tmp.length() - comma3 - 1))));
                        break;
                    }
                    case 7:
                        mc.add(Face(std::stoi(tmp.substr(i + 1, tmp.length() - i - 1))));
                        break;
                    case 8:
                        mc.add(FlashImage(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case 9: {
                        //[mirai:musicshare:name,title,summary,jUrl,pUrl,mUrl,brief]
                        auto temp = Tools::split(tmp.substr(i + 1, tmp.length() - i - 1), ",");
                        mc.add(MusicShare(temp[0], temp[1], temp[2], temp[3], temp[4], temp[5], temp[6]));
                        break;
                    }
                    default:
                        Logger::logger.error(
                                "MiraiCP碰到了意料之中的错误(原因:部分SimpleMessage在MiraiCode解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: MiraiCode:" +
                                m);
                        mc.add(UnSupportMessage("[mirai:" + tmp));
                        break;
                }
                pos = back;
                lastPos = pos;
                if (t == 1)
                    lastPos++;
            }
            pos++;
        } while (pos < m.length());
        if (lastPos + 1 < m.length())
            mc.add(PlainText(m.substr(lastPos + 1, m.length() - lastPos - 1))); // plain text
        return mc;
    }
    MessageChain MessageChain::deserializationFromMessageSourceJson(const json &tmp, bool origin) {
        json j = tmp;
        if (origin)
            j = tmp["originalMessage"];
        MessageChain mc;
        if (j.empty()) return mc;
        if (j[0]["type"] == "MessageOrigin") {
            if (j[0]["kind"] == "MUSIC_SHARE") {
                mc.add(MusicShare(j[1]["kind"], j[1]["title"], j[1]["summary"], j[1]["jumpUrl"], j[1]["pictureUrl"],
                                  j[1]["musicUrl"], j[1]["brief"]));
                return mc;
            }
            mc.add(OnlineForwardedMessage::deserializationFromMessageSourceJson(j));
            return mc;
        }
        for (auto node: j) {
            if (node["type"] == "SimpleServiceMessage") {
                mc.add(ServiceMessage(node["serviceId"], node["content"]));
                continue;
            }
            if (node["type"] == "LightApp") {
                mc.add(LightApp(node["content"]));
                continue;
            }
            if (node["type"] == "OnlineAudio") {
                mc.add(OnlineAudio(node["filename"], node["fileMd5"], node["fileSize"], node["codec"], node["length"],
                                   node["urlForDownload"]));
                continue;
            }
            if (node["type"] == "FileMessage") {
                mc.add(Group(tmp["targetId"].get<QQID>(), tmp["botId"].get<QQID>()).getFileById(node["id"]).plus(
                        node["internalId"]));
                continue;
            }
            if (node["type"] == "MarketFace") {
                mc.add(MarketFace(node["delegate"]["faceId"]));
                break;
            }
            switch (SingleMessage::getKey(node["type"])) {
                case -2:
                    mc.add(QuoteReply(MessageSource::deserializeFromString(node["source"].dump())));
                    break;
                case 0:
                    mc.add(PlainText(node["content"].get<std::string>()));
                    break;
                case 1:
                    mc.add(At(node["target"]));
                    break;
                case 2:
                    mc.add(AtAll());
                    break;
                case 3:
                    mc.add(Image(node["imageId"]));
                    break;
                case 7:
                    mc.add(Face(node["id"]));
                    break;
                case 8:
                    mc.add(FlashImage(node["imageId"]));
                    break;
                default:
                    Logger::logger.warning(
                            "MiraiCP碰到了意料之中的错误(原因:接受到的SimpleMessage在MessageSource解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: MessageSource:" +
                            j.dump());
                    mc.add(UnSupportMessage(node.dump()));
            }
        }
        return mc;
    }
} // namespace MiraiCP
//from include/MessageSource.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    void MessageSource::recall() const {
        json j{{"source", serializeToString()}};
        std::string re = KtOperation::ktOperation(KtOperation::Recall, std::move(j));
        if (re == "E2") throw RecallException(MIRAICP_EXCEPTION_WHERE);
    }
    MessageSource::MessageSource(std::string ids,
                                 std::string internalids,
                                 std::string source)
        : ids(std::move(ids)),
          internalids(std::move(internalids)),
          source(std::move(source)) {}
    std::string MessageSource::serializeToString() const {
        return source;
    }
    MessageSource MessageSource::deserializeFromString(const std::string &source) {
        json j = json::parse(source);
        try {
            return {j["ids"].dump(), j["internalIds"].dump(), source};
        } catch (json::type_error &e) {
            Logger::logger.error("消息源序列化出错，格式不符合(MessageSource::deserializeFromString)");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw IllegalArgumentException(std::string("消息源序列化出错，格式不符合(MessageSource::deserializeFromString), ") + e.what(), MIRAICP_EXCEPTION_WHERE);
        }
    }
} // namespace MiraiCP
//from include/MiraiCode.cpp
namespace MiraiCP {
    std::string MiraiCode::toString() {
        return Tools::escapeFromMiraiCode(this->content);
    }
    MiraiCode::MiraiCode(const std::string &a, bool convert) { // NOLINT(google-explicit-constructor)
        if (!convert)
            content = a;
        else
            content = Tools::escapeToMiraiCode(a);
    }
} // namespace MiraiCP
//from include/Schedule.cpp
//
// Created by antares on 11/10/22.
//
void MiraiCP::schedule(size_t time, std::string msg) {
    schedule(std::chrono::seconds(time), std::move(msg));
}
// todo(Antares): 之后改为优先队列，轮询，降低线程池的占用
void MiraiCP::schedule(std::chrono::seconds sec, std::string msg) {
    ThreadTask::addTask(
            [sec](std::string t) {
                std::this_thread::sleep_for(sec);
                Event::broadcast(TimeOutEvent(std::move(t)));
            },
            std::move(msg));
}
//from include/SingleMessage.cpp
#include <json.hpp>
namespace MiraiCP {
    using json = nlohmann::json;
    nlohmann::json SingleMessage::toJson() const {
        nlohmann::json re;
        re["key"] = "miraicode";
        re["content"] = this->toMiraiCode();
        return re;
    }
    // 静态成员
    std::unordered_map<int, std::string> SingleMessage::messageType{
            {-5, "MarketFace"},
            {-4, "OnlineForwardedMessage"},
            {-3, "OnlineAudio"},
            {-2, "QuoteReply"},
            {-1, "unSupportMessage"},
            {0, "plainText"},
            {1, "at"},
            {2, "atAll"},
            {3, "image"},
            {4, "app"},
            {5, "service"},
            {6, "file"},
            {7, "face"},
            {8, "FlashImage"},
            {9, "MusicShare"}};
    QuoteReply::QuoteReply(const SingleMessage &m) : SingleMessage(m) {
        if (m.type != -2) throw IllegalArgumentException("cannot convert type(" + std::to_string(m.type) + "to QuoteReply", MIRAICP_EXCEPTION_WHERE);
        source = MessageSource::deserializeFromString(m.content);
    }
    // 结束静态成员
    nlohmann::json PlainText::toJson() const {
        nlohmann::json j;
        j["key"] = "plaintext";
        j["content"] = content;
        return j;
    }
    int SingleMessage::getKey(const std::string &value) {
        for (const auto &a: messageType) {
            if (Tools::iequal(a.second, value)) return a.first;
        }
        return -1;
    }
    std::string SingleMessage::toMiraiCode() const {
        // Logger::logger.info("base");
        if (type > 0)
            if (type == 1)
                return "[mirai:at:" + content + "] ";
            else if (type == 2)
                return "[mirai:atall] ";
            else
                return "[mirai:" + messageType[type] + this->prefix + Tools::escapeToMiraiCode(content) + "]";
        else
            return content;
    }
    PlainText::PlainText(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 0)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to PlainText", MIRAICP_EXCEPTION_WHERE);
        this->content = sg.content;
    }
    nlohmann::json At::toJson() const {
        nlohmann::json j;
        j["key"] = "at";
        j["content"] = std::to_string(this->target);
        return j;
    }
    At::At(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 1)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to At", MIRAICP_EXCEPTION_WHERE);
        this->target = std::stol(sg.content);
    }
    nlohmann::json AtAll::toJson() const {
        nlohmann::json j;
        j["key"] = "atall";
        return j;
    }
    nlohmann::json Image::toJson() const {
        nlohmann::json j;
        j["key"] = "image";
        j["imageid"] = this->id;
        j["size"] = this->size;
        j["width"] = this->width;
        j["height"] = this->height;
        j["type"] = this->imageType;
        return j;
    }
    Image::Image(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 3 && sg.type != 8) throw IllegalArgumentException("传入的SingleMessage应该是Image类型", MIRAICP_EXCEPTION_WHERE);
        this->id = sg.content;
        this->size = this->width = this->height = 0;
        this->imageType = 5;
    }
    bool Image::isUploaded(QQID botid) {
        if (!this->md5.has_value()) this->refreshInfo();
        if (this->size == 0) throw IllegalArgumentException("size不能为0", MIRAICP_EXCEPTION_WHERE);
        nlohmann::json tmp = this->toJson();
        tmp["botid"] = botid;
        std::string re = KtOperation::ktOperation(KtOperation::ImageUploaded, std::move(tmp));
        return re == "true";
    }
    nlohmann::json FlashImage::toJson() const {
        nlohmann::json j;
        j["key"] = "Flashimage";
        j["imageid"] = this->id;
        j["size"] = this->size;
        j["width"] = this->width;
        j["height"] = this->height;
        j["type"] = this->imageType;
        return j;
    }
    nlohmann::json LightApp::toJson() const {
        nlohmann::json j;
        j["key"] = "lightapp";
        j["content"] = this->content;
        return j;
    }
    LightApp::LightApp(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 3)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to LighApp", MIRAICP_EXCEPTION_WHERE);
    }
    std::string LightApp::toMiraiCode() const {
        return "[mirai:app:" + Tools::escapeToMiraiCode(content) + "]";
    }
    nlohmann::json ServiceMessage::toJson() const {
        nlohmann::json j;
        j["key"] = "servicemessage";
        j["content"] = this->content;
        j["id"] = this->id;
        return j;
    }
    std::string ServiceMessage::toMiraiCode() const {
        return "[mirai:service" + this->prefix + Tools::escapeToMiraiCode(content) + "]";
    }
    ServiceMessage::ServiceMessage(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 4)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to ServiceMessage", MIRAICP_EXCEPTION_WHERE);
    }
    nlohmann::json Face::toJson() const {
        nlohmann::json j;
        j["key"] = "face";
        j["id"] = this->id;
        return j;
    }
    nlohmann::json UnSupportMessage::toJson() const {
        nlohmann::json j;
        j["key"] = "unsupportmessage";
        j["content"] = this->content;
        return j;
    }
    //远程文件(群文件)
    RemoteFile::RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p,
                           struct Dinfo d, struct Finfo f) : SingleMessage(RemoteFile::type(), i + "," + std::to_string(ii) + "," +
                                                                                                       Tools::escapeToMiraiCode(std::move(n)) +
                                                                                                       "," +
                                                                                                       std::to_string(s)),
                                                             id(i),
                                                             internalid(ii),
                                                             name(std::move(n)),
                                                             size(s),
                                                             path(std::move(p)),
                                                             dinfo(std::move(d)),
                                                             finfo(f) {}
    RemoteFile::RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s) : SingleMessage(6, i + "," + std::to_string(ii) + "," +
                                                                                                                         Tools::escapeToMiraiCode(std::move(n)) +
                                                                                                                         "," +
                                                                                                                         std::to_string(s)),
                                                                                                id(i),
                                                                                                internalid(ii),
                                                                                                name(std::move(n)),
                                                                                                size(s) {}
    RemoteFile RemoteFile::deserializeFromString(const std::string &source) {
        json j;
        try {
            j = json::parse(source);
        } catch (json::parse_error &e) {
            Logger::logger.error("格式化json失败，RemoteFile::deserializeFromString");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw e;
        }
        try {
            auto re = RemoteFile(j["id"], j["internalid"], j["name"], j["finfo"]["size"]);
            if (j.contains("dinfo")) {
                struct Dinfo d {
                    j["dinfo"]["url"],
                            j["dinfo"]["md5"],
                            j["dinfo"]["sha1"]
                };
                re.dinfo = d;
            }
            if (j["finfo"].contains("uploaderid")) {
                struct Finfo f {
                    j["finfo"]["size"],
                            j["finfo"]["uploaderid"],
                            j["finfo"]["expirytime"],
                            j["finfo"]["uploadtime"],
                            j["finfo"]["lastmodifytime"]
                };
                re.finfo = f;
            }
            if (j.contains("path"))
                re.path = j["path"];
            return re;
        } catch (json::type_error &e) {
            Logger::logger.error("json格式化失败，位置:RemoteFile");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw e;
        }
    }
    RemoteFile RemoteFile::plus(unsigned int ii) {
        RemoteFile tmp(*this);
        tmp.internalid = ii;
        tmp.content = id + "," + std::to_string(ii) + "," + Tools::escapeToMiraiCode(std::move(name)) + "," +
                      std::to_string(size);
        return tmp;
    }
    std::string RemoteFile::serializeToString() {
        json j;
        if (this->dinfo.has_value()) {
            j["dinfo"]["url"] = this->dinfo->url;
            j["dinfo"]["md5"] = this->dinfo->md5;
            j["dinfo"]["shar1"] = this->dinfo->sha1;
        }
        if (this->finfo.has_value()) {
            j["finfo"]["size"] = this->finfo->size;
            j["finfo"]["uploaderid"] = this->finfo->uploaderid;
            j["finfo"]["expirytime"] = this->finfo->expirytime;
            j["finfo"]["uploadtime"] = this->finfo->uploadtime;
            j["finfo"]["lastmodifytime"] = this->finfo->lastmodifytime;
        }
        j["id"] = this->id;
        j["internalid"] = this->internalid;
        j["name"] = this->name;
        j["size"] = this->size;
        if (this->path.has_value())
            j["path"] = this->path.value();
        return j.dump();
    }
    /*图片类实现*/
    void Image::refreshInfo() {
        std::string re = KtOperation::ktOperation(KtOperation::QueryImgInfo, toJson());
        if (re == "E1")
            throw RemoteAssetException("图片id格式错误", MIRAICP_EXCEPTION_WHERE);
        json j = json::parse(re);
        this->url = Tools::json_stringmover(j, "url");
        this->md5 = Tools::json_stringmover(j, "md5");
        this->size = j["size"];
        this->width = j["width"];
        this->height = j["height"];
        this->imageType = j["type"];
    }
    Image Image::deserialize(const std::string &str) {
        json j = json::parse(str);
        return Image(
                j["imageid"],
                j["size"],
                j["width"],
                j["height"],
                j["type"]);
    }
    FlashImage FlashImage::deserialize(const std::string &str) {
        json j = json::parse(str);
        return FlashImage(
                j["imageid"],
                j["size"],
                j["width"],
                j["height"],
                j["type"]);
    }
} // namespace MiraiCP
//from include/ThreadTask.cpp
//
// Created by antares on 11/8/22.
//
#include <atomic>
#include <deque>
#include <shared_mutex>
namespace MiraiCP::ThreadTask::internal {
    // todo(Antares): add verbose log
    using functionType = std::function<void()>;
    using functionPointerType = std::shared_ptr<functionType>;
    using storerType = std::unordered_map<size_t, functionPointerType>;
    using storerIteratorType = storerType::iterator;
    inline auto &get_function_storer() {
        static storerType function_storer;
        return function_storer;
    }
    inline auto &get_mutex() {
        static std::shared_mutex mtx;
        return mtx;
    }
    size_t get_auto_incr_id() {
        static std::atomic<size_t> id = 0;
        return id++;
    }
    void push_task(size_t id, functionPointerType func) {
        bool insert;
        {
            std::unique_lock lk(get_mutex());
            insert = get_function_storer().insert({id, std::move(func)}).second;
        }
        if (!insert) {
            Logger::logger.error("Fatal: task id " + std::to_string(id) + " is already taken by another task!");
            return;
        }
        LibLoader::LoaderApi::pushTaskWithId(task_interface, id);
    }
    void remove_task(size_t id) {
        size_t erased;
        {
            std::unique_lock lk(get_mutex());
            erased = get_function_storer().erase(id);
        }
        if (0 == erased) {
            Logger::logger.error("Invalid task id " + std::to_string(id) + " is requested to erase");
        }
    }
    /// @note dev: we can't send a std::function object to libLoader,
    ///  so one appropriate way is that store the function in a data structure and call it in a wrapper function.
    void task_interface(size_t id) {
        static_assert(std::is_same_v<LibLoader::LoaderApi::task_func_with_id, decltype(&task_interface)>);
        storerIteratorType iter;
        functionPointerType fPtr;
        {
            std::shared_lock lck(get_mutex());
            iter = get_function_storer().find(id);
            if (iter == get_function_storer().end()) {
                Logger::logger.error("Invalid task id " + std::to_string(id) + " is requested to run");
                return;
            }
            fPtr = iter->second;
        }
        // running task!
        (*fPtr)();
    }
} // namespace MiraiCP::ThreadTask::internal
//from include/Tools.cpp
#include <regex>
namespace MiraiCP::Tools {
    // 工具函数实现
    std::string replace(std::string str, std::string_view from, std::string_view to) {
        size_t start_pos = 0;
        while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
            str.replace(start_pos, from.length(), to);
            start_pos += to.length(); // Handles case where 'to' is a substd::string of 'from'
        }
        return str;
    }
    inline void split(const std::string &s, std::vector<std::string> &tokens, const std::string &delimiters = ",") {
        std::string::size_type lastPos = s.find_first_not_of(delimiters, 0);
        std::string::size_type pos = s.find_first_of(delimiters, lastPos);
        while (std::string::npos != pos || std::string::npos != lastPos) {
            tokens.emplace_back(s.substr(lastPos, pos - lastPos));
            lastPos = s.find_first_not_of(delimiters, pos);
            pos = s.find_first_of(delimiters, lastPos);
        }
    }
    std::vector<QQID> StringToVector(std::string temp) {
        if (temp.empty()) return {};
        if (temp[0] == '[' && temp[temp.size() - 1] == ']') {
            temp.erase(temp.begin());
            temp.pop_back();
        }
        std::vector<std::string> strResult;
        split(temp, strResult);
        std::vector<QQID> ans;
        ans.reserve(strResult.size());
        for (auto &str: strResult) {
            ans.emplace_back(stoull(str));
        }
        return ans;
    }
    std::string escapeFromMiraiCode(const std::string &s) {
        //[	\[
        //]	\]
        //:	\:
        //,	\,
        //\	\\ /
        return replace(replace(replace(replace(replace(s,
                                                       "\\\\", "\\"),
                                               "\\,", ","),
                                       "\\:", ":"),
                               "\\]", "]"),
                       "\\[", "[");
    }
    std::string escapeToMiraiCode(const std::string &s) {
        //[	\[
        //]	\]
        //:	\:
        //,	\,
        //\	\\ /
        return replace(replace(replace(replace(replace(s,
                                                       "\\", "\\\\"),
                                               ",", "\\,"),
                                       ":", "\\:"),
                               "]", "\\]"),
                       "[", "\\[");
    }
    bool starts_with(std::string_view f, std::string_view s) { return f.rfind(s, 0) == 0; }
    bool icompareChar(const char &c1, const char &c2) {
        return c1 == c2 || std::toupper(c1) == std::toupper(c2);
    }
    bool iequal(std::string_view str1, std::string_view str2) {
        return ((str1.size() == str2.size()) &&
                std::equal(str1.begin(), str1.end(), str2.begin(), &icompareChar));
    }
    std::vector<std::string> split(const std::string &text, const std::string &delim) {
        std::regex ws_re(delim + "+");
        return {std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1), std::sregex_token_iterator()};
    }
} // namespace MiraiCP::Tools
//from include/loaderApi.cpp
#include <string>
#include <vector>
namespace LibLoader::LoaderApi {
    static const interface_funcs *loader_apis = nullptr;
    MIRAICP_EXPORT void set_loader_apis(const LibLoader::LoaderApi::interface_funcs *apis) {
        loader_apis = apis;
    }
    MIRAICP_EXPORT void reset_loader_apis() {
        loader_apis = nullptr;
    }
    /// 这个函数是给本cpp以外的文件使用的，大概率用不到
    const interface_funcs *get_loader_apis() {
        return loader_apis;
    }
    using MiraiCP::PluginNotAuthorizedException;
    using MiraiCP::PluginNotEnabledException;
    // check the func ptr existance before use it
    inline void checkApi(void *funcptr) {
        if (loader_apis == nullptr) [[unlikely]] {
            throw PluginNotEnabledException(MIRAICP_EXCEPTION_WHERE);
        } else if (funcptr == nullptr) [[unlikely]] {
            throw PluginNotAuthorizedException(MIRAICP_EXCEPTION_WHERE);
        }
    }
    /// interfaces for plugins
    MiraiCPString pluginOperation(const MiraiCPString &s) {
        checkApi((void *) loader_apis->_pluginOperation);
        return loader_apis->_pluginOperation(s);
    }
    void loggerInterface(const MiraiCPString &content, const MiraiCPString &name, long long id, int level) {
        checkApi((void *) loader_apis->_loggerInterface);
        loader_apis->_loggerInterface(content, name, id, level);
    }
    MiraiCPString showAllPluginId() {
        checkApi((void *) loader_apis->_showAllPluginId);
        return loader_apis->_showAllPluginId();
    }
    void pushTask(task_func func) {
        checkApi((void *) loader_apis->_pushTask);
        loader_apis->_pushTask(func);
    }
    void pushTaskWithId(task_func_with_id func, size_t id) {
        checkApi((void *) loader_apis->_pushTaskWithId);
        loader_apis->_pushTaskWithId(func, id);
    }
    void enablePluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_enablePluginById);
        loader_apis->_enablePluginById(id);
    }
    void disablePluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_disablePluginById);
        loader_apis->_disablePluginById(id);
    }
    void enableAllPlugins() {
        checkApi((void *) loader_apis->_enableAllPlugins);
        loader_apis->_enableAllPlugins();
    }
    void disableAllPlugins() {
        checkApi((void *) loader_apis->_disableAllPlugins);
        loader_apis->_disableAllPlugins();
    }
    void loadNewPlugin(const MiraiCPString &path, bool activateNow) {
        checkApi((void *) loader_apis->_loadNewPlugin);
        loader_apis->_loadNewPlugin(path, activateNow);
    }
    void unloadPluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_unloadPluginById);
        loader_apis->_unloadPluginById(id);
    }
    void reloadPluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_reloadPluginById);
        loader_apis->_reloadPluginById(id);
    }
} // namespace LibLoader::LoaderApi
namespace MiraiCP::LoaderApi {
    void loggerInterface(const std::string &content, const std::string &name, long long int id, int level) {
        LibLoader::LoaderApi::loggerInterface(content, name, id, level);
    }
    std::vector<std::string> showAllPluginId() {
        nlohmann::json::array_t PluginIdList = nlohmann::json::parse(LibLoader::LoaderApi::showAllPluginId().toString());
        return {PluginIdList.begin(), PluginIdList.end()};
    }
    void enablePluginById(const std::string &id) {
        LibLoader::LoaderApi::enablePluginById(id);
    }
    void disablePluginById(const std::string &id) {
        LibLoader::LoaderApi::disablePluginById(id);
    }
    void enableAllPlugins() {
        LibLoader::LoaderApi::enableAllPlugins();
    }
    void disableAllPlugins() {
        LibLoader::LoaderApi::disableAllPlugins();
    }
    void loadNewPlugin(const std::string &path, bool enableNow) {
        LibLoader::LoaderApi::loadNewPlugin(path, enableNow);
    }
    void unloadPluginById(const std::string &id) {
        LibLoader::LoaderApi::unloadPluginById(id);
    }
    void reloadPluginById(const std::string &id) {
        LibLoader::LoaderApi::reloadPluginById(id);
    }
} // namespace MiraiCP::LoaderApi
//from include/utils.cpp
// -----------------------
#include <iostream>
// 开始对接libloader接口代码
using json = nlohmann::json;
namespace LibLoader::LoaderApi {
    const interface_funcs *get_loader_apis();
    MIRAICP_EXPORT void set_loader_apis(const LibLoader::LoaderApi::interface_funcs *apis);
    MIRAICP_EXPORT void reset_loader_apis();
} // namespace LibLoader::LoaderApi
extern "C" {
/// 插件开启入口
MIRAICP_EXPORT void FUNC_ENTRANCE(const LibLoader::LoaderApi::interface_funcs &funcs) {
    static_assert(std::is_same_v<decltype(&FUNC_ENTRANCE), LibLoader::plugin_entrance_func_ptr>);
    using namespace MiraiCP;
    Event::clear();
    LibLoader::LoaderApi::set_loader_apis(&funcs);
    assert(LibLoader::LoaderApi::get_loader_apis() != nullptr);
    Logger::logger.info("开始启动插件: " + MiraiCP::CPPPlugin::config.getId());
    try {
        enrollPlugin();
        // plugin == nullptr 无插件实例加载
        if (CPPPlugin::plugin != nullptr) {
            CPPPlugin::plugin->onEnable();
        }
    } catch (const MiraiCPExceptionBase &e) {
        std::cerr.flush();
        e.raise();
        Logger::logger.error("插件(id=" + CPPPlugin::config.getId() + ", name=" + CPPPlugin::config.name + ")启动失败");
        // throw IllegalStateException(e.what(), e.filename, e.lineNum);
    } catch (const std::exception &e) {
        std::cerr.flush();
        Logger::logger.error(e.what());
        Logger::logger.error("插件(id=" + CPPPlugin::config.getId() + ", name=" + CPPPlugin::config.name + ")启动失败");
        // throw IllegalStateException(e.what(), MIRAICP_EXCEPTION_WHERE);
    } catch (...) {
        std::cerr.flush();
        Logger::logger.error("插件(id=" + CPPPlugin::config.getId() + ", name=" + CPPPlugin::config.name + ")启动失败");
        // throw IllegalStateException("", MIRAICP_EXCEPTION_WHERE);
    }
}
/// 插件结束(也可能是暂时的disable)
MIRAICP_EXPORT void FUNC_EXIT() {
    static_assert(std::is_same_v<decltype(&FUNC_EXIT), LibLoader::plugin_func_ptr>);
    using namespace MiraiCP;
    Logger::logger.info("开始禁用插件：" + MiraiCP::CPPPlugin::config.getId());
    Event::clear();
    if (CPPPlugin::plugin != nullptr) CPPPlugin::plugin->onDisable();
    CPPPlugin::plugin.reset();
    // 无法保证用户插件析构函数是否调用api，在plugin.reset()之前不可reset loader api
    LibLoader::LoaderApi::reset_loader_apis();
}
/// 消息解析分流
/// env != null, call from jni
MIRAICP_EXPORT void FUNC_EVENT(const MiraiCP::MiraiCPString &c) {
    static_assert(std::is_same_v<decltype(&FUNC_EVENT), LibLoader::plugin_event_func_ptr>);
    using namespace MiraiCP;
    std::string content = c;
    json j;
    try {
        j = json::parse(content);
    } catch (json::parse_error &e) {
        Logger::logger.error("消息解析分流：格式化json错误");
        Logger::logger.error("For debug: " + content);
        Logger::logger.error(e.what());
        return;
    }
    int type = j["type"].get<int>();
    if (type != eventTypes::Command && Event::noRegistered(type)) return;
    try {
        Event::incomingEvent(std::move(j), type);
    } catch (json::type_error &e) {
        Logger::logger.error("json格式化异常,位置C-Handle");
        Logger::logger.error(e.what());
        Logger::logger.error("info:", content);
    } catch (MiraiCPExceptionBase &e) {
        Event::broadcast<MiraiCPExceptionEvent>(MiraiCPExceptionEvent(&e));
        e.raise();
    } catch (const std::exception &e) {
        Logger::logger.error(e.what());
        Logger::logger.error("info:", content);
    }
    // 如果产生了无法处理的异常，直接退出插件
    // loader端将处理这个异常并将绑定的线程结束掉
    // 如果存在其他线程，可能导致段错误
}
/// 获取 Plugin Info
/// 如果未正确定义，插件无法正确加载
/// 该函数不可调用loader api；因为会在入口函数调用前先调用，loader api未初始化
MIRAICP_EXPORT const MiraiCP::PluginConfig *PLUGIN_INFO() {
    static_assert(std::is_same_v<decltype(&PLUGIN_INFO), LibLoader::plugin_info_func_ptr>);
    //    if (MiraiCP::CPPPlugin::config.getId().empty())
    //        throw std::exception();
    return &MiraiCP::CPPPlugin::config; // never nullptr
}
}
//结束对接JNI接口代码
//from common/MiraiCPStringInternal.cpp
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// -----------------------
#ifdef MIRAICP_LIB_LOADER
#endif
#include <cstring>
namespace MiraiCP {
    // avoid calling this if _size == 0
    void MiraiCPString::construction() {
        str = (char *) ::std::malloc(sizeof(char) * (_size + 1));
        if (str == nullptr) {
#ifdef MIRAICP_LIB_LOADER
            LibLoader::logger.error("MiraiCPString::construction: malloc failed when trying to malloc size " + std::to_string(_size + 1));
#endif
            throw std::bad_alloc();
        }
    }
    MiraiCPString::~MiraiCPString() { // do not inherit MiraiCPString!!
        if (str != nullptr) {
            // ensure deconstruction is paired to construction
            free_this(str);
            str = nullptr;
        }
    }
    MiraiCPString::MiraiCPString(const MiraiCPString &other) {
        _size = other._size;
        if (_size == 0) return;
        construction();
        assert(str != nullptr);
        memcpy(str, other.str, _size * sizeof(char));
        str[_size] = 0;
    }
    MiraiCPString::MiraiCPString(MiraiCPString &&temp) noexcept {
        swap(temp);
    }
    MiraiCPString::MiraiCPString(const char *char_str) {
        if (char_str == nullptr) return;
        _size = strlen(char_str);
        if (0 == _size) return;
        construction();
        assert(str != nullptr);
        memcpy(str, char_str, _size * sizeof(char));
        str[_size] = 0;
    }
    MiraiCPString::MiraiCPString(const std::string &string_str) {
        _size = string_str.size();
        if (!_size) return;
        construction();
        assert(str != nullptr);
        memcpy(str, string_str.c_str(), _size * sizeof(char));
        str[_size] = 0;
    }
    const char *MiraiCPString::copyToCharPtr() const {
        if (str == nullptr || _size == 0) return new char[1]{0};
        char *t = new char[_size + 1];
        memcpy(t, str, (_size + 1) * sizeof(char));
        return t;
    }
    bool MiraiCPString::operator==(const MiraiCPString &another) const {
        return another._size == _size && (_size == 0 || strcmp(another.str, str) == 0);
    }
    MiraiCPString &MiraiCPString::operator=(const MiraiCPString &another) {
        MiraiCPString temp(another);
        swap(temp);
        return *this;
    }
    MiraiCPString &MiraiCPString::operator=(MiraiCPString &&another) noexcept {
        swap(another);
        return *this;
    }
    void MiraiCPString::swap(MiraiCPString &other) noexcept {
        std::swap(str, other.str);
        std::swap(_size, other._size);
        std::swap(free_this, other.free_this);
    }
} // namespace MiraiCP
//from common/PluginConfig.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    json PluginConfig::serialize() {
        json j;
        j["name"] = name;
        j["version"] = version;
        j["author"] = author;
        j["description"] = description;
        j["time"] = time;
        j["id"] = id;
        return j;
    }
    std::string PluginConfig::serialize2string() {
        return serialize().dump();
    }
} // namespace MiraiCP
//from common/redirectCout.cpp
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// -----------------------
#include <iostream>
#include <memory>
#include <sstream>
#ifdef MIRAICP_LIB_LOADER
#else
#endif
class OStreamRedirector {
    // 旧的缓冲区目标
    std::streambuf *old;
    // 被重定向的流
    std::ostream *obj;
    std::ostream oldStream;
public:
    ~OStreamRedirector() {
        obj->rdbuf(old);
        obj = nullptr;
        old = nullptr;
    }
    /**
         * @brief 重定向 obj 的流
         * @param obj 需要重定向的流
         * @param new_buffer 重定向到的新缓冲区
         */
    explicit OStreamRedirector(std::ostream *in_obj, std::streambuf *newBuffer) : old(in_obj->rdbuf(newBuffer)),
                                                                                  obj(in_obj), oldStream(old) {}
private:
    // print directly
    friend void print(const std::string &);
};
class OString : public std::ostream {
    class OStringBuf : public std::streambuf {
        friend class OString;
        typedef void (*Recorder)(std::string);
        //
        explicit OStringBuf(bool inIsInfoLevel) : isInfoLevel(inIsInfoLevel) {}
        ~OStringBuf() override = default;
        //
        std::ostringstream result{};
        Recorder recorder = nullptr;
        bool isInfoLevel;
        //
        // 输出缓冲区内容, 相当于 flush
        std::string out();
        // std::streambuf interface
        int sync() override {
            record(out());
            return 0;
        }
        // std::streambuf interface
        // 加入缓冲区
        int overflow(std::streambuf::int_type c) override {
            if (c == EOF)
                record(out());
            else
                result.put((std::streambuf::char_type) c);
            return c;
        }
        void record(std::string message) {
            if (recorder) [[unlikely]] {
                recorder(std::move(message));
            }
        }
    };
public:
    using Recorder = OStringBuf::Recorder;
private:
    // 缓冲区
    OStringBuf sbuf;
public:
    // 输出是否为 info 级别
    explicit OString(bool info) : std::ostream(&sbuf), sbuf(info) {}
    ~OString() override = default;
    void setRecorder(Recorder recorder) {
        sbuf.recorder = recorder;
    }
};
// --- impl ---
OString outTarget(true);
OString errTarget(false);
std::unique_ptr<OStreamRedirector> outRedirector;
std::unique_ptr<OStreamRedirector> errRedirector;
struct RedirectedOstreamPair {
public:
    std::ostream *out = &std::cout;
    std::ostream *err = &std::cerr;
} RedirectedOstreamPointers;
std::string OString::OStringBuf::out() {
    std::string resultstr = result.str();
    result.str("");
#ifdef MIRAICP_LIB_LOADER
    auto &localLogger = LibLoader::logger;
#else
    auto &localLogger = MiraiCP::Logger::logger;
#endif
    if (isInfoLevel)
        localLogger.info(resultstr);
    else
        localLogger.error(resultstr);
    return resultstr;
}
void MiraiCP::Redirector::reset() {
    outRedirector.reset();
    errRedirector.reset();
}
void print(const std::string &str) {
    if (outRedirector == nullptr) {
        std::cout << str << std::endl;
    } else {
        outRedirector->oldStream << str;
        outRedirector->oldStream.flush();
    }
}
void MiraiCP::Redirector::setRedirectedObjs(std::ostream *outStream, std::ostream *errStream) {
    RedirectedOstreamPointers = {outStream, errStream};
}
void MiraiCP::Redirector::start() {
    outRedirector = std::make_unique<OStreamRedirector>(RedirectedOstreamPointers.out, outTarget.rdbuf());
    errRedirector = std::make_unique<OStreamRedirector>(RedirectedOstreamPointers.err, errTarget.rdbuf());
}
namespace MiraiCP::Redirector {
    /// @note dev: this function is only used for tests;
    ///  should never be declared in source headers
    MIRAICP_EXPORT void SetCoutRecorder(void (*recorder)(std::string)) {
        outTarget.setRecorder(recorder);
    }
    /// @note dev: this function is only used for tests;
    ///  should never be declared in source headers
    MIRAICP_EXPORT void SetCerrRecorder(void (*recorder)(std::string)) {
        errTarget.setRecorder(recorder);
    }
} // namespace MiraiCP::Redirector
