// This file is generated automatically by buildScript;
// When contributing to this repository, please DO NOT edit this file.
// Copyright (c) 2020 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <MiraiCP.hpp>
//from Bot.cpp
namespace MiraiCP {
    Group Bot::getGroup(QQID groupid, JNIEnv *env) const {
        return {groupid, this->id, env};
    }
    Friend Bot::getFriend(QQID i, JNIEnv *env) const {
        return Friend(i, this->id, env);
    }
    bool Bot::operator==(const Contact &c) const {
        return this->id == c.id();
    }
    void Bot::refreshInfo(JNIEnv *env) {
        if (this->id == 0)
            return;
        nlohmann::json j;
        j["source"] = Contact(4, 0, 0, "", this->id).toString();
        LowLevelAPI::info tmp = LowLevelAPI::info0(Config::koperation(Config::RefreshInfo, j, env));
        this->_avatarUrl = tmp.avatarUrl;
        this->_nick = tmp.nickornamecard;
    }
    std::vector<QQID> Bot::getFriendList(JNIEnv *env) const {
        nlohmann::json j;
        j["botid"] = this->id;
        std::string temp = Config::koperation(Config::QueryBFL, j, env);
        return Tools::StringToVector(std::move(temp));
    }
    std::string Bot::FriendListToString() {
        return Tools::VectorToString(getFriendList());
    }
    std::vector<QQID> Bot::getGroupList(JNIEnv *env) const {
        nlohmann::json j;
        j["botid"] = this->id;
        std::string temp = Config::koperation(Config::QueryBGL, j, env);
        return Tools::StringToVector(std::move(temp));
    }
    std::string Bot::GroupListToString() const {
        return Tools::VectorToString(getGroupList());
    }
} // namespace MiraiCP
//from CPPPlugin.cpp
namespace MiraiCP {
    PluginLogger *CPPPlugin::pluginLogger = nullptr;
    CPPPlugin *CPPPlugin::plugin = nullptr;
} // namespace MiraiCP
//from Command.cpp
namespace MiraiCP {
    CommandManager CommandManager::commandManager = CommandManager();
}
//from Config.cpp
namespace MiraiCP::Config {
    jclass CPPLib = nullptr;
    jmethodID KOperation = nullptr;
    // 不可以赋值, 不然会覆盖
    int pluginId;
    /*
    配置类实现
    throw: InitxException 即找不到对应签名
    */
    void construct(JNIEnv *env) {
        if (env == nullptr) env = ThreadManager::getEnv();
        CPPLib = reinterpret_cast<jclass>(env->NewGlobalRef(
                env->FindClass("tech/eritquearcus/miraicp/shared/CPPLib")));
        if (CPPLib == nullptr) {
            throw APIException("初始化错误，找不到CPPLib类", MIRAICP_EXCEPTION_WHERE);
        }
        KOperation = env->GetStaticMethodID(CPPLib, "KOperation", "(Ljava/lang/String;)Ljava/lang/String;");
    }
    void destruct() {
        ThreadManager::getEnv()->DeleteGlobalRef(CPPLib);
    }
    std::string koperation(operation_set type, const nlohmann::json &data, JNIEnv *env, bool catchErr, const std::string &errorInfo) {
        if (env == nullptr) env = ThreadManager::getEnv();
        nlohmann::json j;
        j["type"] = type;
        j["data"] = data;
        std::string re = Tools::jstring2str((jstring) env->CallStaticObjectMethod(CPPLib,
                                                                                  KOperation,
                                                                                  Tools::str2jstring(j.dump().c_str(), env)),
                                            env);
        if (catchErr) ErrorHandle(re, errorInfo);
        return re;
    }
} // namespace MiraiCP::Config
//from Contact.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    MessageSource Contact::sendMsg0(const std::string &msg, int retryTime, bool miraicode, JNIEnv *env) const {
        if (msg.empty()) {
            throw IllegalArgumentException("不能发送空信息, 位置: Contact::SendMsg", MIRAICP_EXCEPTION_WHERE);
        }
        std::string re = LowLevelAPI::send0(msg, this->toJson(), retryTime, miraicode, env,
                                            "reach a error area, Contact::SendMiraiCode");
        ErrorHandle(re, "");
        return MessageSource::deserializeFromString(re);
    }
    MessageSource Contact::quoteAndSend0(const std::string &msg, MessageSource ms, JNIEnv *env) {
        json obj;
        json sign;
        obj["messageSource"] = ms.serializeToString();
        obj["msg"] = msg;
        sign["MiraiCode"] = true;
        sign["groupid"] = this->groupid();
        obj["sign"] = sign.dump();
        std::string re = Config::koperation(Config::SendWithQuote, obj, env);
        ErrorHandle(re, "");
        return MessageSource::deserializeFromString(re);
    }
    Image Contact::uploadImg(const std::string &path, JNIEnv *env) const {
        std::string re = LowLevelAPI::uploadImg0(path, this->toString(), env);
        if (re == "E2")
            throw UploadException("上传图片大小超过30MB,路径:" + path, MIRAICP_EXCEPTION_WHERE);
        return Image::deserialize(re);
    }
    FlashImage Contact::uploadFlashImg(const std::string &path, JNIEnv *env) const {
        std::string re = LowLevelAPI::uploadImg0(path, this->toString(), env);
        if (re == "E2")
            throw UploadException("上传图片大小超过30MB,路径:" + path, MIRAICP_EXCEPTION_WHERE);
        return FlashImage::deserialize(re);
    }
    Contact Contact::deserialize(const std::string &source) {
        json j;
        try {
            j = json::parse(source);
        } catch (json::parse_error &e) {
            Logger::logger.error("json序列化错误 Contact::deserializationFromString");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
        }
        return Contact::deserialize(j);
    }
    Contact Contact::deserialize(nlohmann::json j) {
        return Contact(j["type"],
                       j["id"],
                       j["groupid"],
                       j["nickornamecard"],
                       j["botid"],
                       j["anonymous"]);
    }
    MessageSource Contact::sendVoice0(const std::string &path, JNIEnv *env) {
        json j;
        json source;
        source["path"] = path;
        j["source"] = source.dump();
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::Voice, j, env);
        if (re == "E1") {
            throw UploadException("上传语音文件格式不对(必须为.amr/.silk)或文件不存在", MIRAICP_EXCEPTION_WHERE);
        } else if (re == "E2") {
            throw UploadException("上传语音文件大小超过服务器限制，一般限制在1MB上下", MIRAICP_EXCEPTION_WHERE);
        }
        return MessageSource::deserializeFromString(re);
    }
} // namespace MiraiCP
//from Event.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    Event Event::processor = Event();
    void GroupInviteEvent::operation0(const std::string &source, QQID botid, bool accept, JNIEnv *env) {
        nlohmann::json j;
        j["text"] = source;
        j["accept"] = accept;
        j["botid"] = botid;
        std::string re = Config::koperation(Config::Gioperation, j, env);
        if (re == "E") Logger::logger.error("群聊邀请事件同意失败(可能因为重复处理),id:" + source);
    }
    MessageChain PrivateMessageEvent::nextMessage(long time, bool halt, JNIEnv *env) const {
        json j;
        j["contactSource"] = this->sender.toString();
        j["time"] = time;
        j["halt"] = halt;
        std::string r = Config::koperation(Config::NextMsg, j, env);
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageSourceJson(json::parse(re["messageSource"].get<std::string>())).plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    MessageChain GroupMessageEvent::nextMessage(long time, bool halt, JNIEnv *env) const {
        json j;
        j["contactSource"] = this->group.toString();
        j["time"] = time;
        j["halt"] = halt;
        std::string r = Config::koperation(Config::NextMsg, j, env);
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageSourceJson(json::parse(re["messageSource"].get<std::string>())).plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    MessageChain GroupMessageEvent::senderNextMessage(long time, bool halt, JNIEnv *env) const {
        json j;
        j["contactSource"] = this->sender.toString();
        j["time"] = time;
        j["halt"] = halt;
        std::string r = Config::koperation(Config::NextMsg, j, env);
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageSourceJson(json::parse(re["messageSource"].get<std::string>())).plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    void NewFriendRequestEvent::operation0(const std::string &source, QQID botid, bool accept, JNIEnv *env, bool ban) {
        nlohmann::json j;
        j["text"] = source;
        j["accept"] = accept;
        j["botid"] = botid;
        j["ban"] = ban;
        std::string re = Config::koperation(Config::Nfroperation, j, env);
        if (re == "E") Logger::logger.error("好友申请事件同意失败(可能因为重复处理),id:" + source);
    }
    void MemberJoinRequestEvent::operate(std::string_view s, QQID botid, bool sign, const std::string &msg, JNIEnv *env) {
        nlohmann::json j;
        j["source"] = s;
        j["botid"] = botid;
        j["sign"] = sign;
        j["msg"] = msg;
        Config::koperation(Config::MemberJoinRequest, j, env);
    }
} // namespace MiraiCP
//from Exception.cpp
namespace MiraiCP {
    void MiraiCPExceptionBase::basicRaise() const {
        Logger::logger.error(this->what());
    }
    void MiraiCPExceptionBase::raise() const {
        this->basicRaise();
        if (!filename.empty() && lineNum != 0) {
            Logger::logger.error("文件名:" + filename + "\n行号:" + std::to_string(lineNum));
        }
    }
} // namespace MiraiCP
//from ForwardedMessage.cpp
#include <utility>
namespace MiraiCP {
    using json = nlohmann::json;
    json ForwardedMessage::nodesToJson() {
        json value;
        for (const ForwardedNode &node: nodes) {
            json temp;
            temp["id"] = node.id;
            temp["time"] = node.time;
            if (node.isForwarded()) {
                temp["isForwardedMessage"] = true;
                temp["message"] = std::get<std::shared_ptr<ForwardedMessage>>(node.message)->nodesToJson().dump();
                if (display.has_value())
                    temp["display"] = display->toJson();
            } else
                temp["message"] = std::get<MessageChain>(node.message).toMiraiCode();
            temp["name"] = node.name;
            value.emplace_back(std::move(temp));
        }
        json tmp = this->sendmsg;
        tmp["value"] = std::move(value);
        return tmp;
    }
    //发送这个聊天记录
    MessageSource ForwardedMessage::sendTo(Contact *c, JNIEnv *env) {
        json temp;
        json text;
        text["id"] = c->id();
        text["groupid"] = c->groupid();
        text["type"] = c->type();
        text["content"] = this->nodesToJson();
        temp["text"] = text.dump();
        temp["botid"] = c->botid();
        if (display.has_value())
            temp["display"] = display->toJson();
        std::string re = Config::koperation(Config::Buildforward, temp, env);
        ErrorHandle(re, "");
        return MessageSource::deserializeFromString(re);
    }
    ForwardedMessage ForwardedMessage::deserializationFromMessageSourceJson(const json &j) {
        std::vector<ForwardedNode> nodes;
        try {
            for (auto &&a: j) {
                if (a["messageChain"][0].contains("kind") && a["messageChain"][0]["kind"] == "FORWARD") {
                    nodes.emplace_back(a["senderId"], a["senderName"], ForwardedMessage::deserializationFromMessageSourceJson(a["messageChain"][1]["nodeList"]), a["time"], ForwardedMessageDisplayStrategy::defaultStrategy());
                } else {
                    nodes.emplace_back(a["senderId"], a["senderName"], MessageChain::deserializationFromMessageSourceJson(a["messageChain"], false), a["time"]);
                }
            }
        } catch (json::exception &e) {
            throw APIException("ForwardedMessage格式化异常", MIRAICP_EXCEPTION_WHERE);
        }
        return {std::move(nodes), ForwardedMessageDisplayStrategy::defaultStrategy()};
    }
    OnlineForwardedMessage OnlineForwardedMessage::deserializationFromMessageSourceJson(const json &j) {
        std::vector<ForwardedNode> nodes;
        try {
            for (auto &&a: j[1]["nodeList"]) {
                if (a["messageChain"][0].contains("kind") && a["messageChain"][0]["kind"] == "FORWARD") {
                    nodes.emplace_back(a["senderId"], a["senderName"], ForwardedMessage::deserializationFromMessageSourceJson(a["messageChain"][1]["nodeList"]), a["time"], ForwardedMessageDisplayStrategy::defaultStrategy());
                } else {
                    nodes.emplace_back(a["senderId"], a["senderName"], MessageChain::deserializationFromMessageSourceJson(a["messageChain"], false), a["time"]);
                }
            }
        } catch (json::parse_error &e) {
            throw APIException("OnlineForwardedMessage格式化异常", MIRAICP_EXCEPTION_WHERE);
        }
        //if (j[0].contains("resourceId") && !j[0]["resourceId"].is_null())
        return OnlineForwardedMessage(j[0]["origin"], /*j[0]["resourceId"],*/ std::move(nodes));
        //else
        // return OnlineForwardedMessage(j[0]["origin"], std::nullopt, std::move(nodes));
    }
    ForwardedNode::ForwardedNode(QQID id, std::string name, ForwardedMessage _message, int t, std::optional<ForwardedMessageDisplayStrategy> display)
        : id(id), name(std::move(name)),
          message(std::make_shared<ForwardedMessage>(std::move(_message))),
          time(t), isForwardedMessage(true), display(std::move(display)) {}
    /*
    ForwardedNode::ForwardedNode(Contact *c, MessageChain message, int t) : id(c->id()), name(c->nickOrNameCard()),
                                                                            message(std::move(message)),
                                                                            time(t) {}
    ForwardedNode::ForwardedNode(QQID id, std::string name, ForwardedMessage &message, int t) : id(id), name(std::move(name)), forwardedMsg(&message), time(t) {}
    */
    bool OnlineForwardedMessage::operator==(const OnlineForwardedMessage &m) const {
        if (this->nodelist.size() != m.nodelist.size())
            return false;
        int i = 0;
        return std::all_of(this->nodelist.begin(), this->nodelist.end(), [&](const auto &n) {
            return n.message == m[i++].message;
        });
        //        for (int i = 0; i < this->nodelist.size(); i++)
        //            if (this->nodelist[i].message != m[i].message)
        //                return false;
        //        return true;
    }
    ForwardedMessage OnlineForwardedMessage::toForwardedMessage(std::optional<ForwardedMessageDisplayStrategy> display) const {
        return {this->nodelist, std::move(display)};
    }
} // namespace MiraiCP
//from Friend.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    /*好友类实现*/
    Friend::Friend(QQID id, QQID botid, JNIEnv *env) : Contact() {
        this->_type = MIRAI_FRIEND;
        this->_id = id;
        this->_botid = botid;
        refreshInfo(env);
    }
    void Friend::deleteFriend(JNIEnv *env) {
        json j;
        j["source"] = this->toString();
        j["quit"] = true;
        Config::koperation(Config::RefreshInfo, j, env);
    }
    void Friend::refreshInfo(JNIEnv *env) {
        std::string temp = LowLevelAPI::getInfoSource(this->toString(), env);
        if (temp == "E1") {
            throw FriendException(MIRAICP_EXCEPTION_WHERE);
        }
        LowLevelAPI::info tmp = LowLevelAPI::info0(temp);
        this->_nickOrNameCard = tmp.nickornamecard;
        this->_avatarUrl = tmp.avatarUrl;
    }
    void Friend::sendNudge() {
        json j;
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::SendNudge, j);
        if (re == "E1")
            throw IllegalStateException("发送戳一戳失败，登录协议不为phone/ipad", MIRAICP_EXCEPTION_WHERE);
    }
} // namespace MiraiCP
//from Group.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    std::string Group::MemberListToString() {
        return Tools::VectorToString(getMemberList());
    }
    std::vector<Group::OnlineAnnouncement> Group::getAnnouncementsList(JNIEnv *env) {
        json j;
        j["source"] = this->toString();
        j["announcement"] = true;
        std::string re = Config::koperation(Config::RefreshInfo, j, env);
        std::vector<OnlineAnnouncement> oa;
        for (const json &e: json::parse(re)) {
            oa.push_back(Group::OnlineAnnouncement::deserializeFromJson(e));
        }
        return oa;
    }
    void Group::OnlineAnnouncement::deleteThis() {
        json j, i;
        i["botid"] = this->botid;
        i["groupid"] = this->groupid;
        i["fid"] = this->fid;
        i["type"] = 1;
        j["identify"] = i.dump();
        std::string re = Config::koperation(Config::Announcement, j);
        if (re == "E1")
            throw IllegalArgumentException("无法根据fid找到群公告(群公告不存在)", MIRAICP_EXCEPTION_WHERE);
        if (re == "E3")
            throw IllegalStateException("群公告状态异常", MIRAICP_EXCEPTION_WHERE);
    }
    json Group::AnnouncementParams::serializeToJson() {
        json j;
        j["sendToNewMember"] = this->send2new;
        j["isPinned"] = this->pinned;
        j["showEditCard"] = this->showEditCard;
        j["showPopup"] = this->showPopup;
        j["requireConfirmation"] = this->requireConfirm;
        return j;
    }
    Group::OnlineAnnouncement Group::OfflineAnnouncement::publishTo(const Group &g) {
        json j, i, s;
        i["botid"] = g.botid();
        i["groupid"] = g.id();
        i["type"] = 2;
        j["identify"] = i.dump();
        s["content"] = this->content;
        s["params"] = this->params.serializeToJson();
        j["source"] = s.dump();
        std::string re = Config::koperation(Config::Announcement, j);
        return Group::OnlineAnnouncement::deserializeFromJson(json::parse(re));
    }
    Group::OnlineAnnouncement Group::OnlineAnnouncement::deserializeFromJson(const json &j) {
        Group::AnnouncementParams ap(
                j["params"]["sendToNewMember"],
                j["params"]["requireConfirmation"],
                j["params"]["isPinned"],
                j["params"]["showEditCard"],
                j["params"]["showPopup"]);
        return Group::OnlineAnnouncement(
                j["content"],
                ap,
                j["groupid"],
                j["senderid"],
                j["botid"],
                j["time"],
                j["fid"],
                j["confirmationNum"],
                j["imageid"]);
    }
    std::vector<unsigned long long> Group::getMemberList(JNIEnv *env) {
        nlohmann::json j;
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::QueryML, j, env);
        if (re == "E1") {
            throw GroupException(MIRAICP_EXCEPTION_WHERE);
        }
        return Tools::StringToVector(std::move(re));
    }
    Group::Group(QQID groupid, QQID botid, JNIEnv *env) : Contact() {
        this->_type = MIRAI_GROUP;
        this->_id = groupid;
        this->_botid = botid;
        refreshInfo(env);
    }
    void Group::quit(JNIEnv *env) {
        nlohmann::json j;
        j["source"] = this->toString();
        j["quit"] = true;
        Config::koperation(Config::RefreshInfo, j, env);
    }
    void Group::refreshInfo(JNIEnv *env) {
        std::string re = LowLevelAPI::getInfoSource(this->toString(), env);
        LowLevelAPI::info tmp = LowLevelAPI::info0(re);
        this->_nickOrNameCard = std::move(tmp.nickornamecard);
        this->_avatarUrl = std::move(tmp.avatarUrl);
        nlohmann::json j = nlohmann::json::parse(re)["setting"];
        this->setting.name = j["name"];
        this->setting.isMuteAll = j["isMuteAll"];
        this->setting.isAllowMemberInvite = j["isAllowMemberInvite"];
        this->setting.isAutoApproveEnabled = j["isAutoApproveEnabled"];
        this->setting.isAnonymousChatEnabled = j["isAnonymousChatEnabled"];
    }
    void Group::updateSetting(JNIEnv *env) {
        json j;
        json tmp;
        j["name"] = this->setting.name;
        j["isMuteAll"] = this->setting.isMuteAll;
        j["isAllowMemberInvite"] = this->setting.isAllowMemberInvite;
        j["isAutoApproveEnabled"] = this->setting.isAutoApproveEnabled;
        j["isAnonymousChatEnabled"] = this->setting.isAnonymousChatEnabled;
        tmp["source"] = j.dump();
        tmp["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::GroupSetting, tmp, env);
        refreshInfo(env);
    }
    RemoteFile Group::sendFile(const std::string &path, const std::string &filepath, JNIEnv *env) {
        json tmp;
        json source;
        source["path"] = path;
        source["filepath"] = filepath;
        tmp["source"] = source.dump();
        tmp["contactSource"] = this->toString();
        std::string callback = Config::koperation(Config::SendFile, tmp, env);
        if (callback == "E2") throw UploadException("找不到" + filepath + "位置:C-uploadfile", MIRAICP_EXCEPTION_WHERE);
        if (callback == "E3")
            throw UploadException("Upload error:路径格式异常，应为'/xxx.xxx'或'/xx/xxx.xxx'目前只支持群文件和单层路径, path:" + path, MIRAICP_EXCEPTION_WHERE);
        return RemoteFile::deserializeFromString(callback);
    }
    RemoteFile Group::getFile(const std::string &path, const std::string &id, JNIEnv *env) {
        // source 参数
        if (path.empty() || path == "/")
            return this->getFileById(id, env);
        json tmp;
        json j;
        tmp["id"] = id;
        tmp["path"] = path;
        j["source"] = tmp.dump();
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::RemoteFileInfo, j, env);
        if (re == "E2") throw RemoteAssetException("Get error: 文件路径不存在, path:" + path + ",id:" + id, MIRAICP_EXCEPTION_WHERE);
        return RemoteFile::deserializeFromString(re);
    }
    RemoteFile Group::getFileById(const std::string &id, JNIEnv *env) {
        json tmp;
        json j;
        tmp["id"] = id;
        j["source"] = tmp.dump();
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::RemoteFileInfo, j, env);
        if (re == "E1") throw RemoteAssetException("Get error: 文件路径不存在, id:" + id, MIRAICP_EXCEPTION_WHERE);
        return RemoteFile::deserializeFromString(re);
    }
    Member Group::getOwner(JNIEnv *env) {
        json j;
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::QueryOwner, j, env);
        return Member(stoi(re), this->id(), this->botid());
    }
    std::string Group::getFileListString(const std::string &path, JNIEnv *env) {
        json temp;
        json j;
        temp["id"] = "-1";
        temp["path"] = path;
        j["source"] = temp.dump();
        j["contactSource"] = this->toString();
        return Config::koperation(Config::RemoteFileInfo, j, env);
    }
    std::vector<Group::file_short_info> Group::getFileList(const std::string &path, JNIEnv *env) {
        std::vector<file_short_info> re = std::vector<file_short_info>();
        std::string tmp = getFileListString(path, env);
        json root = json::parse(tmp);
        for (auto &i: root) {
            file_short_info t;
            t.path = i[0];
            t.id = i[1];
            re.push_back(t);
        }
        return re;
    }
    Member Group::getMember(QQID memberid, JNIEnv *env) {
        return Member(memberid, this->id(), this->botid(), env);
    }
    Member Group::operator[](QQID a) {
        return getMember(a);
    }
} // namespace MiraiCP
//from Logger.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    // 静态成员
    Logger Logger::logger = Logger();
    // 结束静态成员
    /*
    日志类实现
    throw: InitException 即找不到签名
    */
    void Logger_interface::init(JNIEnv *env) {
        if (env == nullptr) env = ThreadManager::getEnv();
        this->log = env->GetStaticMethodID(Config::CPPLib, "KSendLog", "(Ljava/lang/String;I)V");
    }
    void Logger_interface::log0(const std::string &content, int level, json j, JNIEnv *env) {
        if (env == nullptr) env = ThreadManager::getEnv();
        if (this->loggerhandler.enable)
            this->loggerhandler.action(content, level);
        env->CallStaticVoidMethod(Config::CPPLib, log, Tools::str2jstring(j.dump().c_str()), (jint) level);
    }
    void Logger::log1(const std::string &content, int level, JNIEnv *env) {
        json j;
        j["id"] = -2;
        j["log"] = content;
        log0(content, level, j, env);
    }
    void IdLogger::log1(const std::string &content, int level, JNIEnv *env) {
        json j;
        j["id"] = id;
        j["log"] = content;
        log0(content, level, j, env);
    }
    void PluginLogger::log1(const std::string &content, int level, JNIEnv *env) {
        json j;
        j["id"] = -1;
        j["name"] = CPPPlugin::plugin->config.id;
        j["log"] = content;
        log0(content, level, j, env);
    }
} // namespace MiraiCP
//from LowLevelAPI.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    std::string LowLevelAPI::send0(const std::string &content, json c, int retryTime, bool miraicode, JNIEnv *env,
                                   const std::string &errorInfo) {
        nlohmann::json j;
        nlohmann::json tmp;
        tmp["content"] = content;
        tmp["contact"] = c;
        j["source"] = tmp.dump();
        j["miraiCode"] = miraicode;
        j["retryTime"] = retryTime;
        return Config::koperation(Config::Send, j, env, true, errorInfo);
    }
    LowLevelAPI::info LowLevelAPI::info0(const std::string &source) {
        info re;
        ErrorHandle(source, "");
        nlohmann::json j = nlohmann::json::parse(source);
        re.avatarUrl = j["avatarUrl"];
        re.nickornamecard = j["nickornamecard"];
        return re;
    }
    std::string LowLevelAPI::getInfoSource(const std::string &c, JNIEnv *env = nullptr) {
        nlohmann::json j;
        j["source"] = c;
        return Config::koperation(Config::RefreshInfo, j, env);
    }
    std::string LowLevelAPI::uploadImg0(const std::string &path, const std::string &c, JNIEnv *env = nullptr) {
        nlohmann::json j;
        j["fileName"] = path;
        j["source"] = c;
        return Config::koperation(Config::UploadImg, j, env);
    }
} // namespace MiraiCP
//from Member.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    /*成员类实现*/
    Member::Member(QQID id, QQID groupid, QQID botid, JNIEnv *env)
        : Contact() {
        this->_type = MIRAI_MEMBER;
        this->_id = id;
        this->_groupid = groupid;
        this->_botid = botid;
        refreshInfo(env);
    }
    void Member::refreshInfo(JNIEnv *env) {
        if (isAnonymous)
            return;
        std::string temp = LowLevelAPI::getInfoSource(this->toString(), env);
        if (temp == "E1")
            throw MemberException(1, MIRAICP_EXCEPTION_WHERE);
        if (temp == "E2")
            throw MemberException(2, MIRAICP_EXCEPTION_WHERE);
        LowLevelAPI::info tmp = LowLevelAPI::info0(temp);
        this->_nickOrNameCard = tmp.nickornamecard;
        this->_avatarUrl = tmp.avatarUrl;
        this->permission = getPermission();
        if (temp == "E1") {
            throw MemberException(1, MIRAICP_EXCEPTION_WHERE);
        }
        if (temp == "E2") {
            throw MemberException(2, MIRAICP_EXCEPTION_WHERE);
        }
    }
    unsigned int Member::getPermission(JNIEnv *env) const {
        if (isAnonymous) return 0;
        json j;
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::QueryM, j, env);
        return stoi(re);
    }
    void Member::mute(int time, JNIEnv *env) {
        json j;
        j["time"] = time;
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::MuteM, j, env);
        if (re == "E4")
            throw MuteException(MIRAICP_EXCEPTION_WHERE);
    }
    void Member::kick(const std::string &reason, JNIEnv *env) {
        json j;
        j["message"] = reason;
        j["contactSource"] = this->toString();
        Config::koperation(Config::KickM, j, env);
    }
    void Member::modifyAdmin(bool admin, JNIEnv *env) {
        if (isAnonymous) return;
        json j;
        j["admin"] = admin;
        j["contactSource"] = this->toString();
        Config::koperation(Config::ModifyAdmin, j, env);
        refreshInfo(env);
    }
    void Member::changeNameCard(std::string_view newName, JNIEnv* env) {
        if (isAnonymous) return;
        json j;
        j["contactSource"] = this->toString();
        j["newName"] = newName;
        Config::koperation(Config::ChangeNameCard, j, env);
        refreshInfo(env);
    }
    void Member::sendNudge() {
        if (isAnonymous) return;
        json j;
        j["contactSource"] = this->toString();
        std::string re = Config::koperation(Config::SendNudge, j);
        if (re == "E1")
            throw IllegalStateException("发送戳一戳失败，登录协议不为phone", MIRAICP_EXCEPTION_WHERE);
    }
} // namespace MiraiCP
//from MessageChain.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    std::string MessageChain::toMiraiCode() const {
        return Tools::VectorToString(this->toMiraiCodeVector(), "");
    }
    MessageSource MessageChain::quoteAndSend0(std::string msg, QQID groupid,
                                              JNIEnv *env) {
        json obj;
        json sign;
        obj["messageSource"] = this->source->serializeToString();
        obj["msg"] = std::move(msg);
        sign["MiraiCode"] = true;
        sign["groupid"] = groupid;
        obj["sign"] = sign.dump();
        std::string re = Config::koperation(Config::SendWithQuote, obj, env);
        return MessageSource::deserializeFromString(re);
    }
    //message chain
    MessageChain MessageChain::deserializationFromMiraiCode(const std::string &m) {
        size_t pos = 0;
        size_t lastPos = -1;
        MessageChain mc;
        if (m.length() <= 7) {
            return MessageChain(PlainText(m));
        }
        do {
            if (m.length() - 7 - pos > 0 && m.substr(pos, 7) == "[mirai:") {
                if (pos - lastPos > 1)
                    mc.add(PlainText(m.substr(lastPos + 1, pos - lastPos - 1))); // plain text
                size_t back = MessageChain::findEnd(m, pos);
                if (back == -1) throw IllegalStateException("", MIRAICP_EXCEPTION_WHERE);
                std::string tmp = m.substr(pos, back - pos);
                tmp = Tools::replace(std::move(tmp), "[mirai:", "");
                size_t i = tmp.find(':'); // first :
                int t = SingleMessage::getKey(tmp.substr(0, i));
                switch (t) {
                    case 0:
                        // no miraiCode key is PlainText
                        Logger::logger.error("无法预料的错误, 信息: " + m);
                        break;
                    case 1:
                        mc.add(At(std::stoll(tmp.substr(i + 1, tmp.length() - i - 1))));
                        break;
                    case 2:
                        mc.add(AtAll());
                        break;
                    case 3:
                        mc.add(Image(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case 4:
                        mc.add(LightApp(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case 5: {
                        size_t comma = tmp.find(',');
                        mc.add(ServiceMessage(std::stoi(tmp.substr(i + 1, comma - i - 1)),
                                              tmp.substr(comma + 1, tmp.length() - comma - 1)));
                        break;
                    }
                    case 6: {
                        //[mirai:file:/b53231e8-46dd-11ec-8ba5-5452007bd6c0,102,run.bat,55]
                        size_t comma1 = tmp.find(',');
                        size_t comma2 = tmp.find(',', comma1 + 1);
                        size_t comma3 = tmp.find(',', comma2 + 1);
                        mc.add(RemoteFile(tmp.substr(i + 1, comma1 - i - 1), std::stoi(tmp.substr(comma1 + 1, comma2 - comma1 - 1)), tmp.substr(comma2 + 1, comma3 - comma2 - 1), std::stoll(tmp.substr(comma3 + 1, tmp.length() - comma3 - 1))));
                        break;
                    }
                    case 7:
                        mc.add(Face(std::stoi(tmp.substr(i + 1, tmp.length() - i - 1))));
                        break;
                    case 8:
                        mc.add(FlashImage(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case 9: {
                        //[mirai:musicshare:name,title,summary,jUrl,pUrl,mUrl,brief]
                        auto temp = Tools::split(tmp.substr(i + 1, tmp.length() - i - 1), ",");
                        mc.add(MusicShare(temp[0], temp[1], temp[2], temp[3], temp[4], temp[5], temp[6]));
                        break;
                    }
                    default:
                        Logger::logger.error(
                                "MiraiCP碰到了意料之中的错误(原因:部分SimpleMessage在MiraiCode解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: MiraiCode:" +
                                m);
                        mc.add(UnSupportMessage("[mirai:" + tmp));
                        break;
                }
                pos = back;
                lastPos = pos;
                if (t == 1)
                    lastPos++;
            }
            pos++;
        } while (pos < m.length());
        if (lastPos + 1 < m.length())
            mc.add(PlainText(m.substr(lastPos + 1, m.length() - lastPos - 1))); // plain text
        return mc;
    }
    MessageChain MessageChain::deserializationFromMessageSourceJson(const json &tmp, bool origin) {
        json j = tmp;
        if (origin)
            j = tmp["originalMessage"];
        MessageChain mc;
        if (j.empty()) return mc;
        if (j[0]["type"] == "MessageOrigin") {
            if (j[0]["kind"] == "MUSIC_SHARE") {
                mc.add(MusicShare(j[1]["kind"], j[1]["title"], j[1]["summary"], j[1]["jumpUrl"], j[1]["pictureUrl"], j[1]["musicUrl"], j[1]["brief"]));
                return mc;
            }
            mc.add(OnlineForwardedMessage::deserializationFromMessageSourceJson(j));
            return mc;
        }
        for (auto node: j) {
            if (node["type"] == "SimpleServiceMessage") {
                mc.add(ServiceMessage(node["serviceId"], node["content"]));
                continue;
            }
            if (node["type"] == "LightApp") {
                mc.add(LightApp(node["content"]));
                continue;
            }
            if (node["type"] == "OnlineAudio") {
                mc.add(OnlineAudio(node["filename"], node["fileMd5"], node["fileSize"], node["codec"], node["length"],
                                   node["urlForDownload"]));
                continue;
            }
            if (node["type"] == "FileMessage") {
                mc.add(Group(tmp["targetId"].get<QQID>(), tmp["botId"].get<QQID>()).getFileById(node["id"]).plus(node["internalId"]));
                continue;
            }
            if (node["type"] == "MarketFace") {
                mc.add(MarketFace(node["delegate"]["faceId"]));
                break;
            }
            switch (SingleMessage::getKey(node["type"])) {
                case -2:
                    mc.add(QuoteReply(MessageSource::deserializeFromString(node["source"].dump())));
                    break;
                case 0:
                    mc.add(PlainText(node["content"].get<std::string>()));
                    break;
                case 1:
                    mc.add(At(node["target"]));
                    break;
                case 2:
                    mc.add(AtAll());
                    break;
                case 3:
                    mc.add(Image(node["imageId"]));
                    break;
                case 7:
                    mc.add(Face(node["id"]));
                    break;
                case 8:
                    mc.add(FlashImage(node["imageId"]));
                    break;
                default:
                    Logger::logger.warning(
                            "MiraiCP碰到了意料之中的错误(原因:接受到的SimpleMessage在MessageSource解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: MessageSource:" +
                            j.dump());
                    mc.add(UnSupportMessage(node.dump()));
            }
        }
        return mc;
    }
} // namespace MiraiCP
//from MessageSource.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    void MessageSource::recall(JNIEnv *env) const {
        json j;
        j["source"] = this->serializeToString();
        std::string re = Config::koperation(Config::Recall, j, env);
        if (re == "Y") return;
        if (re == "E2") throw RecallException(MIRAICP_EXCEPTION_WHERE);
    }
    MessageSource::MessageSource(std::string ids,
                                 std::string internalids,
                                 std::string source)
        : ids(std::move(ids)),
          internalids(std::move(internalids)),
          source(std::move(source)) {}
    std::string MessageSource::serializeToString() const {
        return source;
    }
    MessageSource MessageSource::deserializeFromString(const std::string &source) {
        json j = json::parse(source);
        try {
            return {j["ids"].dump(), j["internalIds"].dump(), source};
        } catch (json::type_error &e) {
            Logger::logger.error("消息源序列化出错，格式不符合(MessageSource::deserializeFromString)");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw IllegalArgumentException(std::string("消息源序列化出错，格式不符合(MessageSource::deserializeFromString), ") + e.what(), MIRAICP_EXCEPTION_WHERE);
        }
    }
} // namespace MiraiCP
//from MiraiCode.cpp
namespace MiraiCP {
    std::string MiraiCode::toString() {
        return Tools::escapeFromMiraiCode(this->content);
    }
    MiraiCode::MiraiCode(const std::string &a, bool convert) { // NOLINT(google-explicit-constructor)
        if (!convert)
            content = a;
        else
            content = Tools::escapeToMiraiCode(a);
    }
} // namespace MiraiCP
//from PluginConfig.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    json PluginConfig::serialize() {
        json j;
        j["name"] = name;
        j["version"] = version;
        j["author"] = author;
        j["description"] = description;
        j["time"] = time;
        j["id"] = id;
        return j;
    }
} // namespace MiraiCP
//from SingleMessage.cpp
#include <json.hpp>
namespace MiraiCP {
    using json = nlohmann::json;
    // 静态成员
    std::unordered_map<int, std::string> SingleMessage::messageType{
            {-5, "MarketFace"},
            {-4, "OnlineForwardedMessage"},
            {-3, "OnlineAudio"},
            {-2, "QuoteReply"},
            {-1, "unSupportMessage"},
            {0, "plainText"},
            {1, "at"},
            {2, "atAll"},
            {3, "image"},
            {4, "app"},
            {5, "service"},
            {6, "file"},
            {7, "face"},
            {8, "FlashImage"},
            {9, "MusicShare"}};
    QuoteReply::QuoteReply(const SingleMessage &m) : SingleMessage(m) {
        if (m.type != -2) throw IllegalArgumentException("cannot convert type(" + std::to_string(m.type) + "to QuoteReply", MIRAICP_EXCEPTION_WHERE);
        source = MessageSource::deserializeFromString(m.content);
    }
    // 结束静态成员
    nlohmann::json PlainText::toJson() const {
        nlohmann::json j;
        j["key"] = "plaintext";
        j["content"] = content;
        return j;
    }
    int SingleMessage::getKey(const std::string &value) {
        for (const auto &a: messageType) {
            if (Tools::iequal(a.second, value)) return a.first;
        }
        return -1;
    }
    std::string SingleMessage::toMiraiCode() const {
        // Logger::logger.info("base");
        if (type > 0)
            if (type == 1)
                return "[mirai:at:" + content + "] ";
            else if (type == 2)
                return "[mirai:atall] ";
            else
                return "[mirai:" + messageType[type] + this->prefix + Tools::escapeToMiraiCode(content) + "]";
        else
            return content;
    }
    PlainText::PlainText(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 0)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to PlainText", MIRAICP_EXCEPTION_WHERE);
        this->content = sg.content;
    }
    nlohmann::json At::toJson() const {
        nlohmann::json j;
        j["key"] = "at";
        j["content"] = std::to_string(this->target);
        return j;
    }
    At::At(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 1)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to At", MIRAICP_EXCEPTION_WHERE);
        this->target = std::stol(sg.content);
    }
    nlohmann::json AtAll::toJson() const {
        nlohmann::json j;
        j["key"] = "atall";
        return j;
    }
    nlohmann::json Image::toJson() const {
        nlohmann::json j;
        j["key"] = "image";
        j["imageid"] = this->id;
        j["size"] = this->size;
        j["width"] = this->width;
        j["height"] = this->height;
        j["type"] = this->imageType;
        return j;
    }
    Image::Image(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 3 && sg.type != 8) throw IllegalArgumentException("传入的SingleMessage应该是Image类型", MIRAICP_EXCEPTION_WHERE);
        this->id = sg.content;
        this->size = this->width = this->height = 0;
        this->imageType = 5;
    }
    bool Image::isUploaded(QQID botid, JNIEnv *env) {
        if (!this->md5.has_value()) this->refreshInfo();
        if (this->size == 0) throw IllegalArgumentException("size不能为0", MIRAICP_EXCEPTION_WHERE);
        nlohmann::json tmp = this->toJson();
        tmp["botid"] = botid;
        std::string re = Config::koperation(Config::ImageUploaded, tmp, env);
        return re == "true";
    }
    nlohmann::json FlashImage::toJson() const {
        nlohmann::json j;
        j["key"] = "Flashimage";
        j["imageid"] = this->id;
        j["size"] = this->size;
        j["width"] = this->width;
        j["height"] = this->height;
        j["type"] = this->imageType;
        return j;
    }
    nlohmann::json LightApp::toJson() const {
        nlohmann::json j;
        j["key"] = "lightapp";
        j["content"] = this->content;
        return j;
    }
    LightApp::LightApp(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 3)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to LighApp", MIRAICP_EXCEPTION_WHERE);
    }
    std::string LightApp::toMiraiCode() const {
        return "[mirai:app:" + Tools::escapeToMiraiCode(content) + "]";
    }
    nlohmann::json ServiceMessage::toJson() const {
        nlohmann::json j;
        j["key"] = "servicemessage";
        j["content"] = this->content;
        j["id"] = this->id;
        return j;
    }
    std::string ServiceMessage::toMiraiCode() const {
        return "[mirai:service:" + this->prefix + Tools::escapeToMiraiCode(content) + "]";
    }
    ServiceMessage::ServiceMessage(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.type != 4)
            throw IllegalArgumentException(
                    "Cannot convert(" + MiraiCP::SingleMessage::messageType[sg.type] + ") to ServiceMessage", MIRAICP_EXCEPTION_WHERE);
    }
    nlohmann::json Face::toJson() const {
        nlohmann::json j;
        j["key"] = "face";
        j["id"] = this->id;
        return j;
    }
    nlohmann::json UnSupportMessage::toJson() const {
        nlohmann::json j;
        j["key"] = "unsupportmessage";
        j["content"] = this->content;
        return j;
    }
    //远程文件(群文件)
    RemoteFile::RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p,
                           struct Dinfo d, struct Finfo f) : SingleMessage(RemoteFile::type(), i + "," + std::to_string(ii) + "," +
                                                                                                       Tools::escapeToMiraiCode(std::move(n)) +
                                                                                                       "," +
                                                                                                       std::to_string(s)),
                                                             id(i),
                                                             internalid(ii),
                                                             name(std::move(n)),
                                                             size(s),
                                                             path(std::move(p)),
                                                             dinfo(std::move(d)),
                                                             finfo(f) {}
    RemoteFile::RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s) : SingleMessage(6, i + "," + std::to_string(ii) + "," +
                                                                                                                         Tools::escapeToMiraiCode(std::move(n)) +
                                                                                                                         "," +
                                                                                                                         std::to_string(s)),
                                                                                                id(i),
                                                                                                internalid(ii),
                                                                                                name(std::move(n)),
                                                                                                size(s) {}
    RemoteFile RemoteFile::deserializeFromString(const std::string &source) {
        json j;
        try {
            j = json::parse(source);
        } catch (json::parse_error &e) {
            Logger::logger.error("格式化json失败，RemoteFile::deserializeFromString");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw e;
        }
        try {
            auto re = RemoteFile(j["id"], j["internalid"], j["name"], j["finfo"]["size"]);
            if (j.contains("dinfo")) {
                struct Dinfo d {
                    j["dinfo"]["url"],
                            j["dinfo"]["md5"],
                            j["dinfo"]["sha1"]
                };
                re.dinfo = d;
            }
            if (j["finfo"].contains("uploaderid")) {
                struct Finfo f {
                    j["finfo"]["size"],
                            j["finfo"]["uploaderid"],
                            j["finfo"]["expirytime"],
                            j["finfo"]["uploadtime"],
                            j["finfo"]["lastmodifytime"]
                };
                re.finfo = f;
            }
            if (j.contains("path"))
                re.path = j["path"];
            return re;
        } catch (json::type_error &e) {
            Logger::logger.error("json格式化失败，位置:RemoteFile");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw e;
        }
    }
    RemoteFile RemoteFile::plus(unsigned int ii) {
        RemoteFile tmp(*this);
        tmp.internalid = ii;
        tmp.content = id + "," + std::to_string(ii) + "," + Tools::escapeToMiraiCode(std::move(name)) + "," +
                      std::to_string(size);
        return tmp;
    }
    std::string RemoteFile::serializeToString() {
        json j;
        if (this->dinfo.has_value()) {
            j["dinfo"]["url"] = this->dinfo->url;
            j["dinfo"]["md5"] = this->dinfo->md5;
            j["dinfo"]["shar1"] = this->dinfo->sha1;
        }
        if (this->finfo.has_value()) {
            j["finfo"]["size"] = this->finfo->size;
            j["finfo"]["uploaderid"] = this->finfo->uploaderid;
            j["finfo"]["expirytime"] = this->finfo->expirytime;
            j["finfo"]["uploadtime"] = this->finfo->uploadtime;
            j["finfo"]["lastmodifytime"] = this->finfo->lastmodifytime;
        }
        j["id"] = this->id;
        j["internalid"] = this->internalid;
        j["name"] = this->name;
        j["size"] = this->size;
        if (this->path.has_value())
            j["path"] = this->path.value();
        return j.dump();
    }
    /*图片类实现*/
    void Image::refreshInfo(JNIEnv *env) {
        std::string re = Config::koperation(Config::QueryImgInfo, this->toJson(), env);
        if (re == "E1")
            throw RemoteAssetException("图片id格式错误", MIRAICP_EXCEPTION_WHERE);
        json j = json::parse(re);
        this->url = j["url"];
        this->md5 = j["md5"];
        this->size = j["size"];
        this->width = j["width"];
        this->height = j["height"];
        this->imageType = j["type"];
    }
    Image Image::deserialize(const std::string &str) {
        json j = json::parse(str);
        return Image(
                j["imageid"],
                j["size"],
                j["width"],
                j["height"],
                j["type"]);
    }
    FlashImage FlashImage::deserialize(const std::string &str) {
        json j = json::parse(str);
        return FlashImage(
                j["imageid"],
                j["size"],
                j["width"],
                j["height"],
                j["type"]);
    }
} // namespace MiraiCP
//from ThreadManager.cpp
namespace MiraiCP {
    // 静态成员
    std::map<std::string, ThreadManager::ThreadInfo> ThreadManager::threads = std::map<std::string, ThreadInfo>();
    std::recursive_mutex ThreadManager::mtx = std::recursive_mutex();
    JavaVM *ThreadManager::gvm = nullptr;
    long ThreadManager::JNIVersion = 0;
    // 结束静态成员
    void ThreadManager::setEnv(JNIEnv *e) {
        std::lock_guard lk(mtx);
        if (!ThreadManager::included(ThreadManager::getThreadId())) {
            ThreadInfo tmp{e, false};
            ThreadManager::threads.insert(std::pair<std::string, ThreadInfo>(ThreadManager::getThreadId(), tmp));
        } else {
            ThreadManager::threads[ThreadManager::getThreadId()].e = e;
        }
    }
    void ThreadManager::newEnv(const char *threadName) {
        JNIEnv *env = nullptr;
        JavaVMAttachArgs args{static_cast<int>(JNIVersion),
                              const_cast<char *>(threadName),
                              nullptr};
        gvm->AttachCurrentThread((void **) &env, &args);
        ThreadInfo tmp{env, true};
        ThreadManager::threads.insert(std::pair<std::string, ThreadInfo>(ThreadManager::getThreadId(), tmp));
        Logger::logger.info("refresh env");
    };
    void ThreadManager::detach() {
        std::lock_guard lk(mtx);
        if (ThreadManager::included(ThreadManager::getThreadId())) {
            bool att = ThreadManager::threads[ThreadManager::getThreadId()].attach;
            ThreadManager::threads.erase(ThreadManager::getThreadId());
            if (att)
                gvm->DetachCurrentThread();
        }
    }
    bool ThreadManager::included(const std::string &id) {
        if (ThreadManager::threads.empty() || ThreadManager::threads.count(id) == 0)
            return false;
        return true;
    }
    JNIEnv *ThreadManager::getEnv() {
        JNIEnv *tmp;
        {
            std::lock_guard lk(mtx);
            if (!ThreadManager::included(getThreadId())) {
                ThreadManager::newEnv();
            }
            tmp = ThreadManager::threads[ThreadManager::getThreadId()].e;
        }
        return tmp;
    }
} // namespace MiraiCP
//from Tools.cpp
#include <regex>
#include <utf8.h>
namespace MiraiCP::Tools {
    /*工具类实现*/
    std::string jstring2str(jstring jStr, JNIEnv *env) {
        if (env == nullptr) env = ThreadManager::getEnv();
        if (!jStr) {
            Logger::logger.error("警告:kotlin部分返回空字符串, 位置:Tools::jstring2str");
            return "";
        }
        std::u16string s = reinterpret_cast<const char16_t *>(env->GetStringChars(jStr, nullptr));
        if (s.length() == 0) {
            Logger::logger.error("警告:kotlin部分返回空字符串, 位置:Tools::jstring2str");
            return "";
        }
        std::string x;
        utf8::utf16to8(s.begin(), s.end(), std::back_inserter(x));
        return x;
    }
    jstring str2jstring(const char *stra, JNIEnv *env) {
        if (env == nullptr) env = ThreadManager::getEnv();
        if (!stra) {
            Logger::logger.error("警告:C++部分传入空字符串，位置:Tools::str2jstring");
        }
        std::string str(stra);
        std::vector<unsigned short> utf16line;
        utf8::utf8to16(str.begin(), str.end(), std::back_inserter(utf16line));
        auto *c = new jchar[utf16line.size()];
        for (int i = 0; i < utf16line.size(); i++) {
            c[i] = utf16line[i];
        }
        return env->NewString((jchar *) c, (jsize) utf16line.size());
    }
    std::string replace(std::string str, std::string_view from, std::string_view to) {
        size_t start_pos = 0;
        while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
            str.replace(start_pos, from.length(), to);
            start_pos += to.length(); // Handles case where 'to' is a substd::string of 'from'
        }
        return str;
    }
    std::vector<QQID> StringToVector(std::string temp) {
        std::vector<QQID> result;
        temp.erase(temp.begin());
        temp.pop_back();
        std::regex ws_re("[,]+");
        std::vector<std::string> v(std::sregex_token_iterator(temp.begin(), temp.end(), ws_re, -1),
                                   std::sregex_token_iterator());
        result.reserve(v.size());
        std::for_each(v.begin(), v.end(), [&](auto &&s) { result.emplace_back(std::stoull(s)); });
        // for (auto &&s: v)
        //     result.emplace_back(std::stoull(s));
        return result;
    }
    std::string escapeFromMiraiCode(const std::string &s) {
        //[	\[
        //]	\]
        //:	\:
        //,	\,
        //\	\\ /
        return replace(replace(replace(replace(replace(s,
                                                       "\\\\", "\\"),
                                               "\\,", ","),
                                       "\\:", ":"),
                               "\\]", "]"),
                       "\\[", "[");
    }
    std::string escapeToMiraiCode(const std::string &s) {
        //[	\[
        //]	\]
        //:	\:
        //,	\,
        //\	\\ /
        return replace(replace(replace(replace(replace(s,
                                                       "\\", "\\\\"),
                                               ",", "\\,"),
                                       ":", "\\:"),
                               "]", "\\]"),
                       "[", "\\[");
    }
    bool starts_with(std::string_view f, std::string_view s) { return f.rfind(s, 0) == 0; }
    bool icompareChar(const char &c1, const char &c2) {
        return c1 == c2 || std::toupper(c1) == std::toupper(c2);
    }
    bool iequal(std::string_view str1, std::string_view str2) {
        return ((str1.size() == str2.size()) &&
                std::equal(str1.begin(), str1.end(), str2.begin(), &icompareChar));
    }
    std::vector<std::string> split(const std::string &text, const std::string &delim) {
        std::regex ws_re(delim + "+");
        return {std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1), std::sregex_token_iterator()};
    }
} // namespace MiraiCP::Tools
//from utils.cpp
// 开始对接JNI接口代码
using json = nlohmann::json;
namespace MiraiCP::JNIApi {
    /*
    * 作用:判断是否连接上本插件，勿改
    * 参数:env 必备，job 必备
    * 返回值:jstring (用str2jstring把string类型转成jsrting) 发送返回的字符串
    */
    // env != null, call from jni
    JNIEXPORT jstring Verify(JNIEnv *env, jobject, jstring id) {
        using namespace MiraiCP;
        ThreadManager::setEnv(env);
        MiraiCP::ThreadManager::JNIVersion = env->GetVersion();
        try {
            //初始化日志模块
            Config::construct();
            Logger::logger.init();
            enrollPlugin();
            // plugin == nullptr 无插件实例加载
            if (CPPPlugin::plugin != nullptr) {
                CPPPlugin::pluginLogger = new PluginLogger(&Logger::logger);
                CPPPlugin::plugin->onEnable();
            }
        } catch (const MiraiCPExceptionBase &e) {
            e.raise();
        }
        json j = (CPPPlugin::plugin != nullptr) ? CPPPlugin::plugin->config.serialize() : json::parse("{}");
        j["MiraiCPversion"] = MiraiCPVersion;
        Config::pluginId = std::stoi(Tools::jstring2str(id));
        return Tools::str2jstring(j.dump().c_str());
        //验证机制，返回当前SDK版本
    }
    /*
     * 插件结束事件
     * env != null, call from jni
     */
    JNIEXPORT jobject PluginDisable(JNIEnv *env, jobject job) {
        if (CPPPlugin::plugin == nullptr) return job;
        using namespace MiraiCP;
        ThreadManager::setEnv(env);
        try {
            CPPPlugin::plugin->onDisable();
        } catch (const MiraiCPExceptionBase &e) {
            e.raise();
        }
        CPPPlugin::plugin = nullptr;
        return job;
    }
    /*返回空值*/
    JNIEXPORT jstring returnNull() {
        return MiraiCP::Tools::str2jstring("MIRAICP_NULL");
    }
    /*
    * 消息解析分流
     * env != null, call from jni
    */
    JNIEXPORT jstring Event(JNIEnv *env, jobject, jstring content) {
        using namespace MiraiCP;
        ThreadManager::setEnv(env);
        std::string tmp = Tools::jstring2str(content, env);
        json j;
        try {
            j = json::parse(tmp);
        } catch (json::parse_error &e) {
            APIException("格式化json错误", MIRAICP_EXCEPTION_WHERE).raise();
            Logger::logger.error("For debug:" + j.dump());
            Logger::logger.error(e.what(), false);
            return returnNull();
        }
        int type = j["type"].get<int>();
        if (eventTypes(type) != eventTypes::Command && Event::noRegistered(type)) return returnNull();
        try {
            switch (eventTypes(type)) {
                case eventTypes::GroupMessageEvent: {
                    //GroupMessage
                    Event::broadcast<GroupMessageEvent>(
                            GroupMessageEvent(j["group"]["botid"],
                                              Group(Group::deserialize(j["group"])),
                                              Member(Member::deserialize(j["member"])),
                                              MessageChain::deserializationFromMessageSourceJson(json::parse(j["source"].get<std::string>()))
                                                      .plus(MessageSource::deserializeFromString(j["source"].get<std::string>()))));
                    break;
                }
                case eventTypes::PrivateMessageEvent: {
                    //私聊消息
                    Event::broadcast<PrivateMessageEvent>(
                            PrivateMessageEvent(j["friend"]["botid"],
                                                Friend(Friend::deserialize(j["friend"])),
                                                MessageChain::deserializationFromMessageSourceJson(json::parse(j["source"].get<std::string>()))
                                                        .plus(MessageSource::deserializeFromString(j["source"].get<std::string>()))));
                    break;
                }
                case eventTypes::GroupInviteEvent:
                    //群聊邀请
                    Event::broadcast<GroupInviteEvent>(
                            GroupInviteEvent(
                                    j["source"]["botid"],
                                    j["request"],
                                    j["source"]["inviternick"],
                                    j["source"]["inviterid"],
                                    j["source"]["groupname"],
                                    j["source"]["groupid"]));
                    break;
                case eventTypes::NewFriendRequestEvent:
                    //好友
                    Event::broadcast<NewFriendRequestEvent>(
                            NewFriendRequestEvent(
                                    j["source"]["botid"],
                                    j["request"],
                                    j["source"]["fromid"],
                                    j["source"]["fromgroupid"],
                                    j["source"]["fromnick"],
                                    j["source"]["message"]));
                    break;
                case eventTypes::MemberJoinEvent:
                    //新成员加入
                    Event::broadcast<MemberJoinEvent>(
                            MemberJoinEvent(
                                    j["group"]["botid"],
                                    j["jointype"],
                                    Member(Member::deserialize(j["member"])),
                                    Group(Group::deserialize(j["group"])),
                                    j["inviterid"]));
                    break;
                case eventTypes::MemberLeaveEvent:
                    //群成员退出
                    Event::broadcast<MemberLeaveEvent>(MemberLeaveEvent(
                            j["group"]["botid"],
                            j["leavetype"],
                            j["memberid"],
                            Group(Group::deserialize(j["group"])),
                            j["operatorid"]));
                    break;
                case eventTypes::RecallEvent:
                    Event::broadcast<RecallEvent>(RecallEvent(
                            j["botid"],
                            j["etype"],
                            j["time"],
                            j["authorid"],
                            j["operatorid"],
                            j["ids"],
                            j["internalids"],
                            j["groupid"]));
                    break;
                case eventTypes::BotJoinGroupEvent:
                    Event::broadcast<BotJoinGroupEvent>(BotJoinGroupEvent(
                            j["group"]["botid"],
                            j["etype"],
                            Group(Group::deserialize(j["group"])),
                            j["inviterid"]));
                    break;
                case eventTypes::GroupTempMessageEvent:
                    Event::broadcast<GroupTempMessageEvent>(GroupTempMessageEvent(
                            j["group"]["botid"],
                            Group(Group::deserialize(j["group"])),
                            Member(Member::deserialize(j["member"])),
                            MessageChain::deserializationFromMessageSourceJson(json::parse(j["message"].get<std::string>()))
                                    .plus(MessageSource::deserializeFromString(j["source"]))));
                    break;
                case eventTypes::TimeOutEvent:
                    Event::broadcast(TimeOutEvent(j["msg"]));
                    break;
                case eventTypes::BotOnlineEvent:
                    Event::broadcast(BotOnlineEvent(j["botid"]));
                    break;
                case eventTypes::NudgeEvent:
                    Event::broadcast(NudgeEvent(Contact::deserialize(j["from"]),
                                                Contact::deserialize(j["target"]),
                                                Contact::deserialize(j["subject"]),
                                                j["botid"]));
                    break;
                case eventTypes::BotLeaveEvent:
                    Event::broadcast(BotLeaveEvent(j["groupid"], j["botid"]));
                    break;
                case eventTypes::MemberJoinRequestEvent: {
                    std::optional<Group> a;
                    std::optional<Member> b;
                    Contact temp = Contact::deserialize(j["group"]);
                    if (temp.id() == 0)
                        a = std::nullopt;
                    else
                        a = Group(temp);
                    temp = Contact::deserialize(j["inviter"]);
                    if (temp.id() == 0)
                        b = std::nullopt;
                    else
                        b = Member(temp);
                    Event::broadcast(MemberJoinRequestEvent(a, b, temp.botid(), j["requester"], j["requestData"]));
                    break;
                }
                case eventTypes::MessagePreSendEvent: {
                    Event::broadcast(MessagePreSendEvent(Contact::deserialize(j["target"]), MessageChain::deserializationFromMessageSourceJson(j["message"].get<std::string>(), false), j["botid"]));
                    break;
                }
                case eventTypes::Command: {
                    // command
                    std::optional<Contact> c = std::nullopt;
                    if (j.contains("contact")) c = Contact::deserialize(j["contact"]);
                    CommandManager::commandManager[j["bindId"]]->onCommand(c, Bot(j["botid"]), MessageChain::deserializationFromMessageSourceJson((j.contains("message") ? j["message"].get<std::string>() : ""), false));
                    break;
                }
                default:
                    throw APIException("Unreachable code", MIRAICP_EXCEPTION_WHERE);
            }
        } catch (json::type_error &e) {
            Logger::logger.error("json格式化异常,位置C-Handle");
            Logger::logger.error(e.what());
            Logger::logger.error("info:", tmp);
            return Tools::str2jstring("ERROR");
        } catch (MiraiCPExceptionBase &e) {
            Event::broadcast<MiraiCPExceptionEvent>(MiraiCPExceptionEvent(&e));
            e.raise();
            return Tools::str2jstring("ERROR");
        } catch (const std::exception &e) {
            // 这里如果不catch全部exception就会带崩jvm
            Logger::logger.error(e.what());
            Logger::logger.error("info:", tmp);
            return Tools::str2jstring("ERROR");
        }
        return returnNull();
    }
    // env != null
    int registerMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) {
        jclass clazz = env->FindClass(className);
        if (clazz == nullptr) {
            return JNI_FALSE;
        }
        //注册native方法
        if (env->RegisterNatives(clazz, gMethods, numMethods) < 0) {
            return JNI_FALSE;
        }
        return JNI_TRUE;
    }
    JNINativeMethod method_table[]{
            {(char *) "Verify", (char *) "(Ljava/lang/String;)Ljava/lang/String;", (jstring *) Verify},
            {(char *) "Event", (char *) "(Ljava/lang/String;)Ljava/lang/String;", (jstring *) Event},
            {(char *) "PluginDisable", (char *) "()Ljava/lang/Void;", (jobject *) PluginDisable}};
} // namespace MiraiCP::JNIApi
extern "C" JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *) {
    JNIEnv *env = nullptr;
    if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }
    assert(env != nullptr);
    MiraiCP::ThreadManager::gvm = vm;
    // 注册native方法
    if (!MiraiCP::JNIApi::registerMethods(env, "tech/eritquearcus/miraicp/shared/CPPLib", MiraiCP::JNIApi::method_table, 3)) {
        return JNI_ERR;
    }
    return JNI_VERSION_1_6;
}
//结束对接JNI接口代码
