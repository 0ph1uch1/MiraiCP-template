// This file is generated automatically by buildScript;
    // When contributing to this repository, please DO NOT edit this file.
    // Copyright (c) 2020 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <MiraiCP.hpp>
//from src/sdk/Bot.cpp
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <atomic>
#include <memory>
#include <mutex>
namespace MiraiCP {
//    struct InternalBot : public IMiraiData {
//        std::string _avatarUrl;
//        std::string _nickOrNameCard;
//        QQID _id;
//        explicit InternalBot(QQID in_botid) : _id(in_botid) {}
//        ~InternalBot() override = default;
//
//        void deserialize(nlohmann::json in_json) override {} // should never be called
//
//        nlohmann::json internalToJson() const override {
//            return {{"botId", _id}, {"id", _id}, {"type", MIRAI_BOT}};
//        }
//
//        void refreshInfo() override {
//            nlohmann::json j{{"source", internalToString()}};
//            LowLevelAPI::info tmp = LowLevelAPI::info0(KtOperation::ktOperation(KtOperation::RefreshInfo, std::move(j)));
//            _avatarUrl = std::move(tmp.avatarUrl);
//            _nickOrNameCard = std::move(tmp.nickOrNameCard);
//        }
//    };
    inline std::shared_ptr<IContactData> get_bot(QQID id) {
        static std::unordered_map<QQID, std::shared_ptr<IContactData>> BotPool;
        static std::mutex mtx;
        std::lock_guard<std::mutex> lck(mtx);
        auto &Ptr = BotPool.try_emplace(id).first->second;
        if (!Ptr){
            Ptr = std::make_shared<IContactData>();
            Ptr->_id = id;
            Ptr->_type = MIRAI_BOT;
            Ptr->_botId = id;
            Ptr->forceRefreshNextTime();
        }
        return Ptr;
    }
    Group Bot::getGroup(QQID groupid) const {
        return {groupid, InternalData->_id};
    }
    Friend Bot::getFriend(QQID i) const {
        return {i, InternalData->_id};
    }
    std::vector<QQID> Bot::getFriendList() const {
        nlohmann::json j{{"contact", toJson()},
                         {"type",    KtOperation::QueryBotListCode::FriendList}};
        std::string temp = KtOperation::ktOperation(KtOperation::QueryBotList, j);
        return Tools::StringToVector(std::move(temp));
    }
    std::string Bot::FriendListToString() const {
        return Tools::VectorToString(getFriendList());
    }
    std::vector<QQID> Bot::getGroupList() const {
        nlohmann::json j{{"contact", toJson()},
                         {"type",    KtOperation::QueryBotListCode::GroupList}};
        std::string temp = KtOperation::ktOperation(KtOperation::QueryBotList, j);
        return Tools::StringToVector(std::move(temp));
    }
    std::string Bot::GroupListToString() const {
        return Tools::VectorToString(getGroupList());
    }
    Bot::Bot(QQID in_id): Contact(get_bot(in_id)) {
    }
    std::string Bot::nick() {
        refreshInfo();
        std::shared_lock<std::shared_mutex> _lck(InternalData->getMutex());
        return InternalData->_nickOrNameCard;
    }
    std::string Bot::avatarUrl() {
        refreshInfo();
        std::shared_lock<std::shared_mutex> _lck(InternalData->getMutex());
        return InternalData->_avatarUrl;
    }
} // namespace MiraiCP
//from src/sdk/CPPPlugin.cpp
namespace MiraiCP {
    // 静态区代码一般不会使用logger，虽是ub，但应该不会造成影响；
    // 静态区强行调用的话，因为loggerInterface尚未传入，若logger尚未初始化，访问Logger::logger将是ub
    // 可以考虑把logger做成纯静态实现？以及最好做成 Logger * const
    Logger *CPPPlugin::pluginLogger = &Logger::logger;
    std::unique_ptr<CPPPlugin> CPPPlugin::plugin = nullptr;
} // namespace MiraiCP
//from src/sdk/Command.cpp
namespace MiraiCP {
    CommandManager CommandManager::commandManager = CommandManager();
}
//from src/sdk/Contact.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    std::shared_ptr<Contact> Contact::deserializeToPointer(nlohmann::json j) {
        uint8_t thistype = j["type"];
        switch (thistype) {
            case MIRAI_FRIEND: {
                return std::make_shared<Friend>(std::move(j));
            }
            case MIRAI_MEMBER: {
                return std::make_shared<Member>(std::move(j));
            }
            case MIRAI_GROUP: {
                return std::make_shared<Group>(std::move(j));
            }
            default:
                assert(0);
                break;
        }
        return {};
    }
    MessageSource Contact::sendVoiceImpl(std::string path) const {
        json j{{"path", std::move(path)},
               {"contact", toJson()}};
        std::string re = KtOperation::ktOperation(KtOperation::Voice, j);
        if (re == "E1") {
            throw UploadException("上传语音文件格式不对(必须为.amr/.silk)或文件不存在", MIRAICP_EXCEPTION_WHERE);
        } else if (re == "E2") {
            throw UploadException("上传语音文件大小超过服务器限制，一般限制在1MB上下", MIRAICP_EXCEPTION_WHERE);
        }
        return MessageSource::deserializeFromString(re);
    }
    void IContactData::deserialize(nlohmann::json in_json) {
        using Tools::json_stringmover;
        _nickOrNameCard = json_stringmover(in_json, "nickOrNameCard");
        _avatarUrl = json_stringmover(in_json, "avatarUrl");
    }
    void IContactData::refreshInfo() {
        // default to Friend
        std::string temp = LowLevelAPI::getInfoSource(internalToJson());
        MIRAICP_ERROR_HANDLE(temp, "");
        LowLevelAPI::info tmp = LowLevelAPI::info0(temp);
        this->_nickOrNameCard = tmp.nickOrNameCard;
        this->_avatarUrl = tmp.avatarUrl;
    }
    nlohmann::json IContactData::internalToJson() const {
        return {{"id", _id}, {"botId", _botId}, {"type", _type}};
    }
    void IContactData::updateJson(json &json_to_update) const {
        json_to_update.update(toJson(), true);
    }
    nlohmann::json GroupRelatedData::internalToJson() const {
        auto result = IContactData::internalToJson();
        result["groupId"] = _groupId;
        return result;
    }
    MessageSource Contact::quoteAndSend0(std::string msg, const MessageSource &ms) const {
        json obj{{"messageSource", ms.serializeToString()},
                 {"msg",           std::move(msg)},
                 {"contact",        toJson()}};
        std::string re = KtOperation::ktOperation(KtOperation::SendWithQuote, obj);
        return MessageSource::deserializeFromString(re);
    }
    Image Contact::uploadImg(const std::string &path) const {
        std::string re = LowLevelAPI::uploadImg0(path, toJson());
        if (re == "E2")
            throw UploadException("上传图片大小超过30MB,路径:" + path, MIRAICP_EXCEPTION_WHERE);
        return Image::deserialize(re);
    }
    FlashImage Contact::uploadFlashImg(const std::string &path) const {
        std::string re = LowLevelAPI::uploadImg0(path, toJson());
        if (re == "E2")
            throw UploadException("上传图片大小超过30MB,路径:" + path, MIRAICP_EXCEPTION_WHERE);
        return FlashImage::deserialize(re);
    }
    MessageSource Contact::sendMsgImpl(std::string msg) const {
        if (msg.empty()) {
            throw IllegalArgumentException("不能发送空信息, 位置: Contact::SendMsg", MIRAICP_EXCEPTION_WHERE);
        }
        nlohmann::json j{{"message", std::move(msg)}, {"contact", toJson()}};
        auto re = KtOperation::ktOperation(KtOperation::Send, j, true, "reach a error area, Contact::sendMsgImpl");
        return MessageSource::deserializeFromString(re);
    }
} // namespace MiraiCP
//from src/sdk/Event.cpp
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
namespace MiraiCP {
    using json = nlohmann::json;
    Event Event::processor;
    GroupMessageEvent::GroupMessageEvent(BaseEventData j) : BotEvent(j.botId),
                                                            group(j.subject->id, j.botId),
                                                            sender(j.object->id, j.object->groupId, j.botId),
                                                            message(MessageChain::deserializationFromMessageJson(
                                                                    json::parse(j.eventData["message"].get<std::string>()))
                                                                            .plus(MessageSource::deserializeFromString(
                                                                                    j.eventData["source"].get<std::string>()))) {
    }
    MessageChain GroupMessageEvent::nextMessage(long time, bool halt) const {
        json j{{"contact", this->group.toJson()},
               {"time",    time},
               {"halt",    halt}};
        std::string r = KtOperation::ktOperation(KtOperation::NextMsg, j);
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageJson(nlohmann::json::parse(Tools::json_stringmover(re, "message"))).plus(
                MessageSource::deserializeFromString(re["messageSource"]));
    }
    MessageChain GroupMessageEvent::senderNextMessage(long time, bool halt) const {
        json j{{"contact", this->sender.toJson()},
               {"time",    time},
               {"halt",    halt}};
        std::string r = KtOperation::ktOperation(KtOperation::NextMsg, j);
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageJson(
                json::parse(re["message"].get<std::string>())).plus(
                MessageSource::deserializeFromString(re["messageSource"]));
    }
    PrivateMessageEvent::PrivateMessageEvent(BaseEventData j) : BotEvent(j.botId),
                                                                 sender(j.subject->id, j.subject->botId),
                                                                message(MessageChain::deserializationFromMessageJson(
                                                                        json::parse(j.eventData["message"].get<std::string>()))
                                                                                .plus(MessageSource::deserializeFromString(
                                                                                        j.eventData["source"].get<std::string>()))) {
    }
    MessageChain PrivateMessageEvent::nextMessage(long time, bool halt) const {
        json j{{"contact", this->sender.toJson()},
               {"time",    time},
               {"halt",    halt}};
        std::string r = KtOperation::ktOperation(KtOperation::NextMsg, j);
        if (r == "E1")
            throw TimeOutException("取下一条信息超时", MIRAICP_EXCEPTION_WHERE);
        json re = json::parse(r);
        return MessageChain::deserializationFromMessageJson(json::parse(re["message"].get<std::string>()))
                .plus(MessageSource::deserializeFromString(re["messageSource"]));
    }
    GroupInviteEvent::GroupInviteEvent(BaseEventData j) : BotEvent(j.botId),
                                                          source(Tools::json_stringmover(j.eventData, "request")),
                                                          inviterNick(
                                                                  Tools::json_stringmover(j.eventData, "invitorNick")),
                                                          groupName(Tools::json_stringmover(j.eventData, "groupName")),
                                                          group(j.subject->id, j.subject->botId),
                                                          inviter(j.object->id, j.object->botId),
                                                          requestEventId(j.eventData["requestEventId"]) {
    }
    void GroupInviteEvent::operation0(const std::string &source, QQID botid, bool accept) {
        nlohmann::json j{{"source", source},
                         {"sign",   accept},
                         {"botId",  botid}};
        std::string re = KtOperation::ktOperation(KtOperation::Gioperation, j);
        if (re == "E") Logger::logger.error("群聊邀请事件同意失败(可能因为重复处理),id:" + source);
    }
    NewFriendRequestEvent::NewFriendRequestEvent(BaseEventData j) : BotEvent(j.botId),
                                                                     source(Tools::json_stringmover(j.eventData, "request")),
                                                                     from(j.object->id, j.object->botId),
                                                                     fromGroup(j.subject == std::nullopt ? std::nullopt : std::optional(Group(j.subject->id, j.subject->botId))),
                                                                     nick(Tools::json_stringmover(j.eventData, "requesterNick")),
                                                                     message(Tools::json_stringmover(j.eventData, "message")),
                                                                     requestEventId(j.eventData["requestEventId"]) {
    }
    void NewFriendRequestEvent::operation0(const std::string &source, QQID botId, bool accept, bool ban) {
        nlohmann::json j{{"source", source},
                         {"sign",   accept},
                         {"botId",  botId},
                         {"ban",    ban}};
        std::string re = KtOperation::ktOperation(KtOperation::Nfroperation, j);
        if (re == "E") Logger::logger.error("好友申请事件同意失败(可能因为重复处理),id:" + source);
    }
    MemberJoinEvent::MemberJoinEvent(BaseEventData j) : BotEvent(j.botId),
                                                        type(joinType(j.eventData["eventType"].get<int>())),
                                                        member(j.object->id, j.subject->groupId, j.botId),
                                                        group(j.subject->id, j.subject->botId),
                                                        inviter(j.object == std::nullopt ? std::nullopt : std::optional(
                                                                Member(j.object->id, j.object->groupId,
                                                                       j.object->botId))) {
    }
    MemberLeaveEvent::MemberLeaveEvent(BaseEventData j) : BotEvent(j.botId),
                                                           member(j.object->id, j.object->groupId, j.object->botId),
                                                           group(j.subject->id, j.subject->botId),
                                                           operater(!j.eventData.contains("operator") ? std::nullopt : std::optional(Member(j.eventData["operator"]["id"], j.eventData["operator"]["groupId"], j.eventData["operator"]["botId"]))),
                                                           type(j.eventData["eventType"]){
    }
    FriendRecallEvent::FriendRecallEvent(BaseEventData j) : BotEvent(j.botId),
                                                            time(j.eventData["messageTime"]),
                                                            author(j.eventData["author"]["id"], j.eventData["author"]["botId"]),
                                                            operater(j.object->id, j.object->botId),
                                                            ids(j.eventData["messageIds"].dump()),
                                                            internalIds(j.eventData["messageInternalIds"].dump()) {
    }
    MemberRecallEvent::MemberRecallEvent(BaseEventData j) : BotEvent(j.subject->botId),
                                                            time(j.eventData["messageTime"]),
                                                            author(j.eventData["author"]["id"], j.eventData["author"]["groupId"], j.eventData["author"]["botId"]),
                                                            operater(j.object->id, j.object->groupId, j.object->botId),
                                                            ids(j.eventData["messageIds"].dump()),
                                                            internalIds(j.eventData["messageInternalIds"].dump()) {
    }
    BotJoinGroupEvent::BotJoinGroupEvent(BaseEventData j) : BotEvent(j.botId),
                                                            group(j.subject->id, j.subject->botId),
                                                            inviter(j.eventData.contains("inviter") ? std::optional(
                                                                    Member(j.eventData["inviter"]["id"],
                                                                           j.eventData["inviter"]["groupId"],
                                                                           j.eventData["inviter"]["botId"]))
                                                                                                    : std::nullopt),
                                                            type(j.eventData["eventType"]) {
    }
    GroupTempMessageEvent::GroupTempMessageEvent(BaseEventData j) : BotEvent(j.botId),
                                                                     group(j.subject->id, j.subject->botId),
                                                                     sender(j.object->id, j.object->groupId, j.object->botId),
                                                                     message(MessageChain::deserializationFromMessageJson(
                                                                             json::parse(j.eventData["message"].get<std::string>()))
                                                                                     .plus(MessageSource::deserializeFromString(
                                                                                             j.eventData["source"]))) {
    }
    NudgeEvent::NudgeEvent(BaseEventData j) : BotEvent(j.botId),
                                              from(j.object->toContactPointer()),
                                              target(BaseEventData::BuiltInContact(
                                                      j.eventData["target"]).toContactPointer()),
                                              subject(j.subject->toContactPointer()) {
    }
    BotLeaveEvent::BotLeaveEvent(BaseEventData j) : BotEvent(j.botId),
                                                     group(j.subject->id, j.subject->botId),
                                                     type(j.eventData["eventType"]),
                                                     operater(j.object->id, j.object->groupId,j.object->botId){
    }
    MemberJoinRequestEvent::MemberJoinRequestEvent(BaseEventData j) : BotEvent(j.botId),
                                                                      source(Tools::json_jsonmover(j.eventData,
                                                                                                   "requestData")),
                                                                      group(j.subject->id, j.subject->botId),
                                                                      inviter(j.eventData.contains("inviter")
                                                                              ? std::optional(
                                                                                      Member(Tools::json_jsonmover(
                                                                                              j.eventData, "inviter")))
                                                                              : std::nullopt),
                                                                      from(j.object->id, j.object->groupId,
                                                                           j.object->botId),
                                                                      fromNick(Tools::json_jsonmover(j.eventData,
                                                                                                     "fromNick")),
                                                                      message(Tools::json_jsonmover(j.eventData,
                                                                                                    "message")) {
    }
    void MemberJoinRequestEvent::operate(std::string_view s, QQID botid, bool sign, const std::string &msg) {
        nlohmann::json j{{"source", s},
                         {"botId",  botid},
                         {"sign",   sign},
                         {"msg",    msg}};
        KtOperation::ktOperation(KtOperation::MemberJoinRequest, j);
    }
    MessagePreSendEvent::MessagePreSendEvent(BaseEventData j) : BotEvent(j.botId),
                                                                target(j.subject->toContactPointer()),
                                                                message(MessageChain::deserializationFromMessageJson(
                                                                        nlohmann::json::parse(
                                                                                Tools::json_stringmover(j.eventData, "message")))) {
    }
    void Event::incomingEvent(BaseEventData j, int type) {
        switch (type) {
            case eventTypes::GroupMessageEvent: {
                Event::broadcast(GroupMessageEvent(std::move(j)));
                break;
            }
            case eventTypes::FriendMessageEvent: {
                Event::broadcast(PrivateMessageEvent(std::move(j)));
                break;
            }
            case eventTypes::GroupTempMessageEvent: {
                Event::broadcast(GroupTempMessageEvent(std::move(j)));
                break;
            }
//          case IMessageEvent::MessageEventType::StrangerMessageEvent: {
//              // todo Implement StrangerMessageEvent (ea)
//          }
            case eventTypes::GroupInviteEvent: {
                //群聊邀请
                Event::broadcast(GroupInviteEvent(std::move(j)));
                break;
            }
            case eventTypes::NewFriendRequestEvent: {
                //好友
                Event::broadcast(NewFriendRequestEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberJoinEvent: { //新成员加入
                Event::broadcast(MemberJoinEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberLeaveEvent: {
                //群成员退出
                Event::broadcast(MemberLeaveEvent(std::move(j)));
                break;
            }
            case eventTypes::FriendRecallEvent: {
                Event::broadcast(RecallEvent::FriendRecallEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberRecallEvent: {
                Event::broadcast(RecallEvent::MemberRecallEvent(std::move(j)));
                break;
            }
            case eventTypes::BotJoinGroupEvent: {
                Event::broadcast(BotJoinGroupEvent(std::move(j)));
                break;
            }
            case eventTypes::TimeOutEvent: {
                Event::broadcast(TimeOutEvent(Tools::json_stringmover(j.eventData, "msg")));
                break;
            }
            case eventTypes::BotOnlineEvent: {
                Event::broadcast(BotOnlineEvent(j.botId));
                break;
            }
            case eventTypes::NudgeEvent: {
                Event::broadcast(NudgeEvent(std::move(j)));
                break;
            }
            case eventTypes::BotLeaveEvent: {
                Event::broadcast(BotLeaveEvent(std::move(j)));
                break;
            }
            case eventTypes::MemberJoinRequestEvent: {
                Event::broadcast(MemberJoinRequestEvent(std::move(j)));
                break;
            }
            case eventTypes::MessagePreSendEvent: {
                Event::broadcast(MessagePreSendEvent(std::move(j)));
                break;
            }
            case eventTypes::Command: {
                // command
                CommandManager::commandManager[j.eventData["bindId"]]->onCommand(
                        j.eventData.contains("contact") ? Contact::deserializeToPointer(Tools::json_jsonmover(j.eventData, "contact")) : nullptr,
                        Bot(j.botId),
                        MessageChain::deserializationFromMessageJson(
                                json::parse(Tools::json_stringmover(j.eventData, "message"))));
                break;
            }
            default: {
                throw APIException("Unreachable code", MIRAICP_EXCEPTION_WHERE);
            }
        }
    }
    BaseEventData::BaseEventData(nlohmann::json j) {
        this->botId = 0;
        if (j.contains("subject")) {
            this->botId = j["subject"]["botId"].get<QQID>();
            this->subject = BuiltInContact(Tools::json_jsonmover(j, "subject"));
        }
        if (j.contains("object")) {
            this->botId = j["object"]["botId"].get<QQID>();
            this->object = BuiltInContact(Tools::json_jsonmover(j, "object"));
        }
        this->eventData = Tools::json_jsonmover(j, "eventData");
    }
    BaseEventData::BuiltInContact::BuiltInContact(nlohmann::json in_json) {
        if (in_json.empty()) {
            return;
        }
        this->botId = in_json["botId"];
        this->id = in_json["id"];
        if (in_json.contains("groupId"))
            this->groupId = in_json["groupId"];
        this->type = ContactType(in_json["type"]);
    }
    std::shared_ptr<Contact> BaseEventData::BuiltInContact::toContactPointer() {
        switch (this->type) {
            case ContactType::TypeFriend:
                return std::make_shared<Friend>(this->id, this->botId);
            case ContactType::TypeGroup:
                return std::make_shared<Group>(this->id, this->botId);
            case ContactType::TypeMember:
                return std::make_shared<Member>(this->id, this->groupId, this->botId);
            case ContactType::TypeBot:
                // bot
                return std::make_shared<Bot>(this->id);
            case ContactType::TypeStranger:
                // todo Implement Stranger (ea)
            case ContactType::TypeAnonymousMember:
                // todo anonymous member
            default:
                throw APIException("Type of builtInContact doesn't match or implement", MIRAICP_EXCEPTION_WHERE);
        }
    }
} // namespace MiraiCP
//from src/sdk/Exception.cpp
namespace MiraiCP {
    void MiraiCPExceptionBase::basicRaise() const {
        Logger::logger.error(this->what());
    }
    void MiraiCPExceptionBase::raise() const {
        this->basicRaise();
        if (!filename.empty() && lineNum != 0) {
            Logger::logger.error("文件名:" + filename + "\n行号:" + std::to_string(lineNum));
        }
    }
    std::string MiraiCPThreadException::getThreadIdStr(const std::thread::id &id) {
        static std::stringstream ss;
        ss << id;
        auto result = ss.str();
        ss.str("");
        return result;
    }
    void ErrorHandle0(const std::string &name, int line, const std::string &re, const std::string &ErrorMsg) {
        if (re == "EF")
            throw FriendException(name, line);
        if (re == "EG")
            throw GroupException(name, line);
        if (re == "EM")
            throw MemberException(1, name, line);
        if (re == "EMM")
            throw MemberException(2, name, line);
        if (re == "EB")
            throw BotException("找不到bot:" + re, name, line);
        if (re == "EA")
            throw APIException(ErrorMsg, name, line);
        if (re == "EC")
            throw EventCancelledException("发送信息被取消", name, line);
        if (re == "ET")
            throw TimeOutException("发送信息超时", name, line);
        if (re == "EP")
            throw BotException(name, line);
        // equal to Tools::start_with
        if (re.rfind("EBM", 0) == 0)
            throw BotIsBeingMutedException(std::stoi(re.substr(3)), name, line);
    }
} // namespace MiraiCP
//from src/sdk/ForwardedMessage.cpp
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
namespace MiraiCP {
    using json = nlohmann::json;
    ForwardedNode::ForwardedNode(QQID id, std::string name, ForwardedMessage _message, int t)
        : id(id), name(std::move(name)),
          message(MessageChain(std::move(_message))),
          time(t), isForwardedMessage(true) {}
    bool ForwardedMessageDisplayStrategy::operator==(const ForwardedMessageDisplayStrategy &other) const {
        return this->toJson() == other.toJson();
    }
    bool ForwardedMessage::operator==(const ForwardedMessage &m) const {
        if (this->nodes.size() != m.nodes.size()) return false;
        int i = 0;
        if(!(this->display == m.display)) return false;
        return std::all_of(this->nodes.begin(), this->nodes.end(), [&i, &m](const auto &n) {
            return n.message == m[i++].message;
        });
    }
    json ForwardedMessage::nodesToJson() const { // NOLINT(misc-no-recursion)
        auto value = json::array();
        for (const ForwardedNode &node: nodes) {
            json temp{{"senderId", node.id},
                      {"time", node.time},
                      {"senderName", node.name},
                      {"messageChain", node.message.toJson()}};
            value.emplace_back(std::move(temp));
        }
        return value;
    }
    //发送这个聊天记录
    MessageSource ForwardedMessage::sendTo(Contact *c) const{
        auto msg = toJson();
        msg.update(display.toJson());
        json req{{"contact", c->toJson()},
                 {"msg", json::array({msg}).dump()}};
        std::string re = KtOperation::ktOperation(KtOperation::Buildforward, req);
        MIRAICP_ERROR_HANDLE(re, "");
        return MessageSource::deserializeFromString(re);
    }
    ForwardedMessage ForwardedMessage::deserializationFromMessageJson(const json &msg) {
        if(!(msg.contains("type") && msg["type"]=="ForwardMessage") && msg.contains("nodeList"))
            throw std::invalid_argument("json is not a ForwardMessage");
        ForwardedMessageDisplayStrategy display;
        if(msg.contains("title") && msg.contains("brief") && msg.contains("source") && msg.contains("summary") && msg.contains("preview"))
            display = ForwardedMessageDisplayStrategy::fromJson(msg);
        else
            display = ForwardedMessageDisplayStrategy::defaultStrategy();
        std::vector<ForwardedNode> nodes;
        auto &j = msg["nodeList"];
        if(!j.is_array())
            throw IllegalArgumentException("OnlineForwardedMessage参数异常, 应为 array", MIRAICP_EXCEPTION_WHERE);
        try {
            for (auto &&a: j) {
                if (a["messageChain"][0].contains("kind") && a["messageChain"][0]["kind"] == "FORWARD") {
                    nodes.emplace_back(a["senderId"], a["senderName"], ForwardedMessage::deserializationFromMessageJson(a["messageChain"][1]["nodeList"]), a["time"]);
                } else {
                    nodes.emplace_back(a["senderId"], a["senderName"], MessageChain::deserializationFromMessageJson(a["messageChain"]), a["time"]);
                }
            }
        } catch (const json::parse_error &) {
            throw APIException("OnlineForwardedMessage格式化异常", MIRAICP_EXCEPTION_WHERE);
        }
        return ForwardedMessage(std::move(nodes), display);
    }
    nlohmann::json ForwardedMessage::toJson() const {
        return {{"type", "ForwardMessage"},
                          {"preview", display.preview},
                          {"source", display.source},
                          {"title", display.title},
                          {"brief", display.brief},
                          {"summary", display.summary},
                          {"nodeList", nodesToJson()}};
    }
} // namespace MiraiCP
//from src/sdk/Friend.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    auto GetFriendPool(QQID id, QQID botid) noexcept {
        static std::unordered_map<QQID, std::unordered_map<QQID, std::shared_ptr<Friend::DataType>>> Pool;
        auto &val = Pool[botid][id];
        if (!val) {
            val = std::make_shared<Friend::DataType>();
            val->_id = id;
            val->_botId = botid;
            val->_type = MIRAI_FRIEND;
        }
        return val;
    }
    auto GetFriendPool(const json &in_json) {
        try {
            return GetFriendPool(in_json["id"], in_json["id2"]);
        } catch (const nlohmann::detail::exception &) {
            throw IllegalArgumentException("构造Friend时传入的json异常", MIRAICP_EXCEPTION_WHERE);
        }
    }
    /*好友类实现*/
    Friend::Friend(QQID id, QQID botid) : Contact(GetFriendPool(id, botid)) {
        forceRefreshNextTime(); //InternalData->requestRefresh();
    }
    Friend::Friend(nlohmann::json in_json) : Contact(GetFriendPool(in_json)) {
        auto ActualDataPtr = GetDataInternal();
        assert(ActualDataPtr != nullptr);
        bool needRefresh = false;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_nickOrNameCard = Tools::json_stringmover(in_json, "nickOrNameCard");
        else
            needRefresh = true;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_avatarUrl = Tools::json_stringmover(in_json, "avatarUrl");
        else
            needRefresh = true;
        if (needRefresh) forceRefreshNextTime();
    }
    void Friend::deleteFriend() {
        json j{{"contact", this->toJson()}, {"quit", true}};
        MIRAICP_ERROR_HANDLE(KtOperation::ktOperation(KtOperation::RefreshInfo, j), "");
    }
    //    void Friend::refreshInfo() {
    //        InternalData->requestRefresh();
    //        //        std::string temp = LowLevelAPI::getInfoSource(this->toString());
    //        //        if (temp == "E1") {
    //        //            throw FriendException(MIRAICP_EXCEPTION_WHERE);
    //        //        }
    //        //        LowLevelAPI::info tmp = LowLevelAPI::info0(temp);
    //        //        this->_nickOrNameCard = tmp.nickOrNameCard;
    //        //        this->_avatarUrl = tmp.avatarUrl;
    //    }
    void Friend::sendNudge() {
        std::string re = KtOperation::ktOperation(KtOperation::SendNudge, toJson());
        if (re == "E1")
            throw IllegalStateException("发送戳一戳失败，登录协议不为phone/ipad", MIRAICP_EXCEPTION_WHERE);
    }
} // namespace MiraiCP
//from src/sdk/Group.cpp
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
namespace MiraiCP {
#define LOC_CLASS_NAMESPACE Group
    using json = nlohmann::json;
    std::string Group::MemberListToString() {
        return Tools::VectorToString(getMemberList());
    }
    auto GetGroupFromPool(QQID groupid, QQID botid) noexcept {
        static std::unordered_map<QQID, std::unordered_map<QQID, std::shared_ptr<Group::DataType>>> Pool;
        auto &Val = Pool[botid][groupid];
        if (!Val) {
            Val = std::make_shared<Group::DataType>(groupid);
            Val->_botId = botid;
            Val->_id = groupid;
            Val->_type = MIRAI_GROUP;
        }
        return Val;
    }
    auto GetGroupFromPool(const json &in_json) {
        try {
            return GetGroupFromPool(in_json["id"], in_json["id2"]);
        } catch (const nlohmann::detail::exception &) {
            throw IllegalArgumentException("构造Group时传入的json异常", MIRAICP_EXCEPTION_WHERE);
        }
    }
    Group::Group(QQID groupId, QQID botId) : Contact(GetGroupFromPool(groupId, botId)) {
        forceRefreshNextTime();
    }
    Group::Group(json in_json) : Contact(GetGroupFromPool(in_json)) {
        auto ActualDataPtr = GetDataInternal();
        assert(ActualDataPtr != nullptr);
        bool needRefresh = false;
        if (in_json.contains("nickOrNameCard")) ActualDataPtr->_nickOrNameCard = Tools::json_stringmover(in_json, "nickOrNameCard");
        else
            needRefresh = true;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_avatarUrl = Tools::json_stringmover(in_json, "avatarUrl");
        else
            needRefresh = true;
        if (needRefresh) forceRefreshNextTime();
    }
    std::vector<Group::OnlineAnnouncement> Group::getAnnouncementsList() {
        json j{{"contact", toJson()}, {"announcement", true}};
        std::string re = KtOperation::ktOperation(KtOperation::RefreshInfo, j);
        std::vector<OnlineAnnouncement> oa;
        for (const json &e: json::parse(re)) {
            oa.push_back(Group::OnlineAnnouncement::deserializeFromJson(e));
        }
        return oa;
    }
    void Group::OnlineAnnouncement::deleteThis() {
        json j{{"botId",   botId},
               {"groupId", groupId},
               {"fid",     fid},
               {"type",    KtOperation::AnnouncementOperationCode::Delete}};
        std::string re = KtOperation::ktOperation(KtOperation::Announcement, j);
        if (re == "E1")
            throw IllegalArgumentException("无法根据fid找到群公告(群公告不存在)", MIRAICP_EXCEPTION_WHERE);
        if (re == "E3")
            throw IllegalStateException("群公告状态异常", MIRAICP_EXCEPTION_WHERE);
    }
    json Group::AnnouncementParams::serializeToJson() {
        return {
                {"sendToNewMember", send2new},
                {"isPinned", pinned},
                {"showEditCard", showEditCard},
                {"showPopup", showPopup},
                {"requireConfirmation", requireConfirm}};
    }
    Group::OnlineAnnouncement Group::OfflineAnnouncement::publishTo(const Group &g) {
        json j{{"botId",   g.botid()},
               {"groupId", g.id()},
               {"type",    KtOperation::AnnouncementOperationCode::Publish},
               {"source",  {{"content", content},
                       {"params",  params.serializeToJson()}}}};
        std::string re = KtOperation::ktOperation(KtOperation::Announcement, j);
        MIRAICP_ERROR_HANDLE(re, "");
        return Group::OnlineAnnouncement::deserializeFromJson(json::parse(re));
    }
    Group::OnlineAnnouncement Group::OnlineAnnouncement::deserializeFromJson(const json &j) {
        return Group::OnlineAnnouncement{
                j["content"],
                j["botId"],
                j["groupId"],
                j["senderId"],
                j["time"],
                j["fid"],
                j["imageId"],
                j["confirmationNum"],
                {j["params"]["sendToNewMember"],
                 j["params"]["requireConfirmation"],
                 j["params"]["isPinned"],
                 j["params"]["showEditCard"],
                 j["params"]["showPopup"]}};
    }
    std::vector<QQID> Group::getMemberList() {
        nlohmann::json j{{"contact", toJson()},
                         {"type",    KtOperation::QueryBotListCode::MemberList}};
        std::string re = KtOperation::ktOperation(KtOperation::QueryBotList, j);
        MIRAICP_ERROR_HANDLE(re, "");
        return Tools::StringToVector(std::move(re));
    }
    void Group::quit() {
        nlohmann::json j{{"contact", toJson()}, {"quit", true}};
        MIRAICP_ERROR_HANDLE(KtOperation::ktOperation(KtOperation::RefreshInfo, j), "");
    }
    void Group::updateSetting(GroupData::GroupSetting newSetting) {
        json j{{"name", std::move(newSetting.name)},
                 {"isMuteAll", newSetting.isMuteAll},
                 {"isAllowMemberInvite", newSetting.isAllowMemberInvite},
                 {"isAutoApproveEnabled", newSetting.isAutoApproveEnabled},
                 {"isAnonymousChatEnabled", newSetting.isAnonymousChatEnabled},
                 {"contact", toJson()}};
        MIRAICP_ERROR_HANDLE(KtOperation::ktOperation(KtOperation::GroupSetting, j), "");
        InternalData->forceRefreshNextTime();
    }
    RemoteFile Group::sendFile(const std::string &path, const std::string &filepath) {
        json j{{"path", path}, {"filePath", filepath}, {"contact", toJson()}};
        auto re = KtOperation::ktOperation(KtOperation::SendFile, j);
        if (re == "E2") throw UploadException("找不到" + filepath + "位置:C-uploadfile", MIRAICP_EXCEPTION_WHERE);
        if (re == "E3")
            throw UploadException("Upload error:路径格式异常，应为'/xxx.xxx'或'/xx/xxx.xxx'目前只支持群文件和单层路径, path:" + path, MIRAICP_EXCEPTION_WHERE);
        MIRAICP_ERROR_HANDLE(re, "");
        return RemoteFile::deserializeFromString(re);
    }
    RemoteFile Group::getFile(const std::string &path, const std::string &id) {
        // source 参数
        if (path.empty() || path == "/")
            return this->getFileById(id);
        json j{{"id", id}, {"path", path}, {"contact", toJson()}};
        std::string re = KtOperation::ktOperation(KtOperation::RemoteFileInfo, j);
        if (re == "E2") throw RemoteAssetException("Get error: 文件路径不存在, path:" + path + ",id:" + id, MIRAICP_EXCEPTION_WHERE);
        MIRAICP_ERROR_HANDLE(re, "");
        return RemoteFile::deserializeFromString(re);
    }
    RemoteFile Group::getFileById(const std::string &id) {
        json j{{"id", id}, {"path", "-1"}, {"contact", toJson()}};
        std::string re = KtOperation::ktOperation(KtOperation::RemoteFileInfo, j);
        if (re == "E1") throw RemoteAssetException("Get error: 文件路径不存在, id:" + id, MIRAICP_EXCEPTION_WHERE);
        MIRAICP_ERROR_HANDLE(re, "");
        return RemoteFile::deserializeFromString(re);
    }
    Member Group::getOwner() {
        std::string re = KtOperation::ktOperation(KtOperation::QueryOwner, toJson());
        MIRAICP_ERROR_HANDLE(re, "");
        return Member(std::stoll(re), this->id(), this->botid());
    }
    std::string Group::getFileListString(const std::string &path) {
        json j{{"id", "-1"}, {"path", path}, {"contact", toJson()}};
        auto re = KtOperation::ktOperation(KtOperation::RemoteFileInfo, j);
        MIRAICP_ERROR_HANDLE(re, "");
        return re;
    }
    std::vector<Group::file_short_info> Group::getFileList(const std::string &path) {
        std::vector<file_short_info> re = std::vector<file_short_info>();
        std::string tmp = getFileListString(path);
        json root = json::parse(tmp);
        for (auto &i: root) {
            file_short_info t;
            t.path = i[0];
            t.id = i[1];
            re.push_back(t);
        }
        return re;
    }
    Member Group::getMember(QQID memberid) {
        return Member(memberid, this->id(), this->botid());
    }
    Member Group::operator[](QQID a) {
        return getMember(a);
    }
    IMPL_GETTER(setting)
    void GroupData::refreshInfo() {
        std::string re = LowLevelAPI::getInfoSource(internalToJson());
        LowLevelAPI::info tmp = LowLevelAPI::info0(re);
        this->_nickOrNameCard = std::move(tmp.nickOrNameCard);
        this->_avatarUrl = std::move(tmp.avatarUrl);
        nlohmann::json j = nlohmann::json::parse(re)["setting"];
        this->_setting.name = Tools::json_stringmover(j, "name");
        this->_setting.isMuteAll = j["isMuteAll"];
        this->_setting.isAllowMemberInvite = j["isAllowMemberInvite"];
        this->_setting.isAutoApproveEnabled = j["isAutoApproveEnabled"];
        this->_setting.isAnonymousChatEnabled = j["isAnonymousChatEnabled"];
    }
    void GroupData::deserialize(nlohmann::json in_json) {
        _groupId = in_json["groupId"];
        IContactData::deserialize(std::move(in_json));
    }
#undef LOC_CLASS_NAMESPACE
} // namespace MiraiCP
//from src/sdk/IMiraiData.cpp
// Copyright (c) 2022 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#include <mutex>
namespace MiraiCP {
    void IMiraiData::requestRefresh() {
        if (!MiraiCP::checkSafeCall() || Locker._inited.exchange(true)) return;
        std::unique_lock<std::shared_mutex> _lck(Locker._mtx);
        refreshInfo();
    }
    void IMiraiData::forceRefreshNextTime() {
        Locker._inited = false;
    }
    std::string IMiraiData::toString() const {
        return toJson().dump();
    }
    nlohmann::json IMiraiData::toJson() const {
        std::shared_lock<std::shared_mutex> lck(Locker._mtx);
        return internalToJson();
    }
    nlohmann::json IMiraiData::internalToString() const {
        return internalToJson().dump();
    }
} // namespace MiraiCP
//from src/sdk/KtOperation.cpp
// -----------------------
namespace MiraiCP::KtOperation {
    std::string ktOperation(operation_set type, const nlohmann::json& data, bool catchErr, const std::string &errorInfo) {
        return ktOperationStr(type, data.dump(), catchErr, errorInfo);
    }
    std::string ktOperationStr(operation_set type, const std::string& data, bool catchErr, const std::string &errorInfo) {
        nlohmann::json j{{"type", type}, {"data", data}};
        std::string re = LibLoader::LoaderApi::pluginOperation(j.dump());
        if (catchErr) {
            MIRAICP_ERROR_HANDLE(re, errorInfo);
        }
        return re;
    }
} // namespace MiraiCP::KtOperation
//from src/sdk/Logger.cpp
namespace MiraiCP {
    Logger Logger::logger;
    void Logger::log_interface(const std::string &content, int level) {
        handler_trigger(content, level);
        LibLoader::LoaderApi::loggerInterface(content, ("plugin/" + MiraiCP::CPPPlugin::config.getName()), -1, level);
    }
    void IdLogger::log_interface(const std::string &content, int level) {
        handler_trigger(content, level);
        LibLoader::LoaderApi::loggerInterface(content, "", static_cast<long long>(id), level);
    }
} // namespace MiraiCP
//from src/sdk/LowLevelAPI.cpp
#include <utility>
namespace LibLoader::LoaderApi {
    const interface_funcs *get_loader_apis();
}
namespace MiraiCP {
    using json = nlohmann::json;
    LowLevelAPI::info LowLevelAPI::info0(const std::string &source) {
        MIRAICP_ERROR_HANDLE(source, "");
        auto j = nlohmann::json::parse(source);
        info re{Tools::json_stringmover(j, "nickOrNameCard"), Tools::json_stringmover(j, "avatarUrl")};
        return re;
    }
    std::string LowLevelAPI::getInfoSource(nlohmann::json c) {
        nlohmann::json j{{"contact", std::move(c)}};
        return KtOperation::ktOperation(KtOperation::RefreshInfo, j);
    }
    std::string LowLevelAPI::uploadImg0(std::string path, nlohmann::json c) {
        nlohmann::json j{{"filePath", std::move(path)}, {"contact", c}};
        return KtOperation::ktOperation(KtOperation::UploadImg, j);
    }
    bool checkSafeCall() {
        return LibLoader::LoaderApi::get_loader_apis() != nullptr;
    }
} // namespace MiraiCP
//from src/sdk/Member.cpp
namespace MiraiCP {
#define LOC_CLASS_NAMESPACE Member
    using json = nlohmann::json;
    auto GetMemberFromPool(QQID id, QQID groupId, QQID botid) noexcept {
        using Tools::idpair;
        static std::unordered_map<idpair, std::unordered_map<QQID, std::shared_ptr<Member::DataType>>> Pool;
        idpair pr{botid, groupId};
        auto &Val = Pool[pr][id];
        if (!Val) {
            Val = std::make_shared<Member::DataType>(groupId);
            Val->_id = id;
            Val->_botId = botid;
            Val->_type = MIRAI_MEMBER;
        }
        return Val;
    }
    auto GetMemberFromPool(const json &in_json) {
        try {
            return GetMemberFromPool(in_json["id"], in_json["groupId"], in_json["botId"]);
        } catch (const nlohmann::detail::exception &) {
            throw IllegalArgumentException("构造Member时传入的json异常", MIRAICP_EXCEPTION_WHERE);
        }
    }
    Member::Member(QQID id, QQID groupid, QQID botid)
        : Contact(GetMemberFromPool(id, groupid, botid)) {
        forceRefreshNextTime();
    }
    Member::Member(nlohmann::json in_json) : Contact(GetMemberFromPool(in_json)) {
        auto ActualDataPtr = GetDataInternal();
        assert(ActualDataPtr != nullptr);
        bool needrefresh = false;
        if (in_json.contains("nickOrNameCard")) ActualDataPtr->_nickOrNameCard = Tools::json_stringmover(in_json, "nickOrNameCard");
        else
            needrefresh = true;
        if (in_json.contains("avatarUrl")) ActualDataPtr->_avatarUrl = Tools::json_stringmover(in_json, "avatarUrl");
        else
            needrefresh = true;
        if (in_json.contains("anonymous")) ActualDataPtr->_anonymous = in_json["anonymous"].get<bool>();
        else
            needrefresh = true;
        if (needrefresh) forceRefreshNextTime();
    }
    void Member::mute(long long sec) const {
        json j{{"time", sec}, {"contact", toJson()}};
        std::string re = KtOperation::ktOperation(KtOperation::MuteM, j);
        if (re == "E4")
            throw MuteException(MIRAICP_EXCEPTION_WHERE);
    }
    void Member::kick(std::string reason) {
        json j{{"message", std::move(reason)}, {"contact", toJson()}};
        KtOperation::ktOperation(KtOperation::KickM, j);
        forceRefreshNextTime();
    }
    void Member::modifyAdmin(bool admin) {
        if (anonymous()) return;
        json j{{"admin", admin}, {"contact", toJson()}};
        KtOperation::ktOperation(KtOperation::ModifyAdmin, j);
        forceRefreshNextTime();
    }
    void Member::changeSpecialTitle(std::string_view title) {
        if (anonymous()) return;
        json j{{"title", title}, {"contact", toJson()}};
        KtOperation::ktOperation(KtOperation::ChangeSpecialTitle, j);
        forceRefreshNextTime();
    }
    void Member::changeNameCard(std::string_view newName) {
        if (anonymous()) return;
        json j{{"contact", toJson()}, {"newName", newName}};
        KtOperation::ktOperation(KtOperation::ChangeNameCard, j);
        forceRefreshNextTime();
    }
    void Member::sendNudge() {
        if (anonymous()) return;
        std::string re = KtOperation::ktOperation(KtOperation::SendNudge, toJson());
        if (re == "E1")
            throw IllegalStateException("发送戳一戳失败，登录协议不为phone", MIRAICP_EXCEPTION_WHERE);
    }
    void MemberData::deserialize(nlohmann::json in_json) {
        _groupId = in_json["groupId"];
        _anonymous = in_json["anonymous"].get<bool>();
        IContactData::deserialize(std::move(in_json));
    }
    void MemberData::refreshInfo() {
        if (_anonymous) return;
        std::string result = LowLevelAPI::getInfoSource(internalToJson());
        if (result == "E1")
            throw MemberException(1, MIRAICP_EXCEPTION_WHERE);
        if (result == "E2")
            throw MemberException(2, MIRAICP_EXCEPTION_WHERE);
        {
            LowLevelAPI::info tmp = LowLevelAPI::info0(result);
            this->_nickOrNameCard = tmp.nickOrNameCard;
            this->_avatarUrl = tmp.avatarUrl;
        }
        {
            result = KtOperation::ktOperation(KtOperation::QueryM, internalToJson());
            MIRAICP_ERROR_HANDLE(result, "");
            auto tmp = nlohmann::json::parse(result);
            _permission = tmp["permission"];
            _specialTitle = Tools::json_stringmover(tmp, "specialTitle");
        }
    }
    IMPL_GETTER(anonymous)
    IMPL_GETTER(permission)
    IMPL_GETTER(specialTitle)
#undef LOC_CLASS_NAMESPACE
} // namespace MiraiCP
//from src/sdk/MessageChain.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    std::string MessageChain::toMiraiCode() const {
        return Tools::VectorToString(toMiraiCodeVector(), "");
    }
    nlohmann::json MessageChain::toJson() const {
        nlohmann::json j = nlohmann::json::array();
        for (auto &&a: *this)
            j.emplace_back(a->toJson());
        return j;
    }
    std::string MessageChain::toString() const{
        return toJson().dump();
    }
    //message chain
    MessageChain MessageChain::deserializationFromMiraiCode(const std::string &m) {
        size_t pos = 0;
        size_t lastPos = -1;
        MessageChain mc;
        if (m.length() <= 7) {
            return MessageChain(PlainText(m));
        }
        do {
            if (m.length() - 7 - pos > 0 && m.substr(pos, 7) == "[mirai:") {
                if (pos - lastPos > 1)
                    mc.add(PlainText(m.substr(lastPos + 1, pos - lastPos - 1))); // plain text
                size_t back = MessageChain::findEnd(m, pos);
                if (back == (size_t) -1) throw IllegalStateException("", MIRAICP_EXCEPTION_WHERE);
                std::string tmp = m.substr(pos, back - pos);
                tmp = Tools::replace(std::move(tmp), "[mirai:", "");
                size_t i = tmp.find(':'); // first :
                int t = SingleMessage::getMiraiCodeKey(tmp.substr(0, i));
                switch (t) {
                    case SingleMessageType::PlainText_t:
                        // no miraiCode key is PlainText
                        Logger::logger.error("无法预料的错误, 信息: " + m);
                        break;
                    case SingleMessageType::At_t:
                        mc.add(At(std::stoll(tmp.substr(i + 1, tmp.length() - i - 1))));
                        break;
                    case SingleMessageType::AtAll_t:
                        mc.add(AtAll());
                        break;
                    case SingleMessageType::Image_t:
                        mc.add(Image(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case SingleMessageType::LightApp_t:
                        mc.add(LightApp(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case SingleMessageType::ServiceMessage_t: {
                        size_t comma = tmp.find(',');
                        mc.add(ServiceMessage(std::stoi(tmp.substr(i + 1, comma - i - 1)),
                                              tmp.substr(comma + 1, tmp.length() - comma - 1)));
                        break;
                    }
                    case SingleMessageType::RemoteFile_t: {
                        //[mirai:file:/b53231e8-46dd-11ec-8ba5-5452007bd6c0,102,run.bat,55]
                        size_t comma1 = tmp.find(',');
                        size_t comma2 = tmp.find(',', comma1 + 1);
                        size_t comma3 = tmp.find(',', comma2 + 1);
                        mc.add(RemoteFile(tmp.substr(i + 1, comma1 - i - 1),
                                          std::stoi(tmp.substr(comma1 + 1, comma2 - comma1 - 1)),
                                          tmp.substr(comma2 + 1, comma3 - comma2 - 1),
                                          std::stoll(tmp.substr(comma3 + 1, tmp.length() - comma3 - 1))));
                        break;
                    }
                    case SingleMessageType::Face_t:
                        mc.add(Face(std::stoi(tmp.substr(i + 1, tmp.length() - i - 1))));
                        break;
                    case SingleMessageType::FlashImage_t:
                        mc.add(FlashImage(tmp.substr(i + 1, tmp.length() - i - 1)));
                        break;
                    case SingleMessageType::MusicShare_t: {
                        //[mirai:musicshare:name,title,summary,jUrl,pUrl,mUrl,brief]
                        auto temp = Tools::split(tmp.substr(i + 1, tmp.length() - i - 1), ",");
                        mc.add(MusicShare(temp[0], temp[1], temp[2], temp[3], temp[4], temp[5], temp[6]));
                        break;
                    }
                    default:
                        Logger::logger.error(
                                "MiraiCP碰到了意料之中的错误(原因:部分SimpleMessage在MiraiCode解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: MiraiCode:" +
                                m);
                        mc.add(UnSupportMessage("[mirai:" + tmp));
                        break;
                }
                pos = back;
                lastPos = pos;
                if (t == 1)
                    lastPos++;
            }
            pos++;
        } while (pos < m.length());
        if (lastPos + 1 < m.length())
            mc.add(PlainText(m.substr(lastPos + 1, m.length() - lastPos - 1))); // plain text
        return mc;
    }
    MessageChain MessageChain::deserializationFromMessageSourceJson(json j, bool origin) {
        if (origin)
            j = j["originalMessage"];
        MessageChain mc;
        if (j.empty()) return mc;
        if (!j.is_array()) throw IllegalArgumentException(std::string(__func__) + "输入的json应当是数组类型", MIRAICP_EXCEPTION_WHERE);
        json::array_t jArray = std::move(j);
        if (jArray[0]["type"] == "MessageOrigin") {
            if (jArray[0]["kind"] == "MUSIC_SHARE") {
                if (jArray.size() < 2) throw IllegalArgumentException(std::string(__func__) + "数组长度应至少为2", MIRAICP_EXCEPTION_WHERE);
                mc.add(MusicShare(jArray[1]["kind"], jArray[1]["title"], jArray[1]["summary"], jArray[1]["jumpUrl"], jArray[1]["pictureUrl"],
                                  jArray[1]["musicUrl"], jArray[1]["brief"]));
                return mc;
            }
            // todo del MessageSource deserialization methods
//            mc.add(ForwardedMessage::deserializationFromMessageSourceJson(jArray));
            return mc;
        }
        for (auto &node: jArray) {
            if (node["type"] == "SimpleServiceMessage") {
                mc.add(ServiceMessage(node["serviceId"], node["content"]));
                continue;
            }
            if (node["type"] == "LightApp") {
                mc.add(LightApp(node["content"]));
                continue;
            }
            if (node["type"] == "OnlineAudio") {
                mc.add(OnlineAudio(node["filename"], node["fileMd5"], node["fileSize"], node["codec"], node["length"],
                                   node["urlForDownload"]));
                continue;
            }
            if (node["type"] == "FileMessage") {
                // note: RemoteFile::deserializeFromString() uses j["finfo"]["size"], which is different from here.
                mc.add(RemoteFile(node["id"], node["internalId"], node["name"], node["size"]));
                continue;
            }
            if (node["type"] == "MarketFace") {
                mc.add(MarketFace(node["delegate"]["faceId"]));
                continue;
            }
            switch (SingleMessage::getKey(node["type"])) {
                    // todo(Antares): change to enum in each case
                case -2:
                    mc.add(QuoteReply(MessageSource::deserializeFromString(node["source"].dump())));
                    break;
                case 0:
                    mc.add(PlainText(node["content"].get<std::string>()));
                    break;
                case 1:
                    mc.add(At(node["target"]));
                    break;
                case 2:
                    mc.add(AtAll());
                    break;
                case 3:
                    mc.add(Image(node["imageId"]));
                    break;
                case 7:
                    mc.add(Face(node["id"]));
                    break;
                case 8:
                    mc.add(FlashImage(node["imageId"]));
                    break;
                default:
                    Logger::logger.warning(
                            "MiraiCP碰到了意料之中的错误(原因:接受到的SimpleMessage在MessageSource解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: node:" +
                            node.dump());
                    mc.add(UnSupportMessage(node.dump()));
            }
        }
        return mc;
    }
    MessageChain MessageChain::deserializationFromMessageJson(const json &j) {
        MessageChain mc;
        if (j.empty()) return mc;
        if (!j.is_array())
            throw IllegalArgumentException(std::string(__func__) + "输入的json应当是数组类型", MIRAICP_EXCEPTION_WHERE);
        for (auto &node: j.get<json::array_t>()) {
            switch (SingleMessage::getKey(node["type"])) {
                case SingleMessageType::MusicShare_t:
                    mc.add(MusicShare(node["kind"], node["title"], node["summary"], node["jumpUrl"], node["pictureUrl"],
                                      node["musicUrl"], node["brief"]));
                    break;
                case SingleMessageType::ServiceMessage_t:
                    mc.add(ServiceMessage(node["serviceId"], node["content"]));
                    break;
                case SingleMessageType::LightApp_t:
                    mc.add(LightApp(node["content"]));
                    break;
                case SingleMessageType::OnlineAudio_t:
                    mc.add(OnlineAudio(node["filename"], node["fileMd5"], node["fileSize"], node["codec"],
                                       node["length"],
                                       node["urlForDownload"]));
                    break;
                case SingleMessageType::MarketFace_t:
                    mc.add(MarketFace(node["delegate"]["faceId"]));
                    break;
                case SingleMessageType::RemoteFile_t:
                    // note: RemoteFile::deserializeFromString() uses j["finfo"]["size"], which is different from here.
                    mc.add(RemoteFile(node["id"], node["internalId"], node["name"], node["size"]));
                    break;
                case SingleMessageType::MessageSource_t:
//                    mc.add(MessageSource::deserializeFromString(node.dump()));
                    break;
                case SingleMessageType::QuoteReply_t:
                    mc.add(QuoteReply(MessageSource::deserializeFromString(node["source"].dump())));
                    break;
                case SingleMessageType::UnsupportedMessage_t:
                    mc.add(UnSupportMessage(node["struct"].dump()));
                    break;
                case SingleMessageType::PlainText_t:
                    mc.add(PlainText(node["content"].get<std::string>()));
                    break;
                case SingleMessageType::At_t:
                    mc.add(At(node["target"]));
                    break;
                case SingleMessageType::AtAll_t:
                    mc.add(AtAll());
                    break;
                case SingleMessageType::Image_t:
                    mc.add(Image(node["imageId"], node["size"].get<size_t>(), node["width"].get<int>(),
                                 node["height"].get<int>(), node["imageType"],
                                 node["isEmoji"].get<bool>()));
                    break;
                case SingleMessageType::Face_t:
                    mc.add(Face(node["id"]));
                    break;
                case SingleMessageType::FlashImage_t:
                    mc.add(FlashImage(node["imageId"]));
                    break;
                case SingleMessageType::OnlineForwardedMessage_t:
                    mc.add(ForwardedMessage::deserializationFromMessageJson(node));
                    break;
                default:
                    Logger::logger.warning(
                            "MiraiCP碰到了意料之中的错误(原因:接受到的SimpleMessage在MessageSource解析支持之外)\n请到MiraiCP(github.com/Nambers/MiraiCP)发送issue并复制本段信息使MiraiCP可以支持这种消息: node:" +
                            node.dump());
                    mc.add(UnSupportMessage(node.dump()));
            }
        }
        return mc;
    }
} // namespace MiraiCP
//from src/sdk/MessageSource.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    void MessageSource::recall() const {
        std::string re = KtOperation::ktOperationStr(KtOperation::Recall, serializeToString());
        if (re == "E2") throw RecallException(MIRAICP_EXCEPTION_WHERE);
    }
    MessageSource::MessageSource(std::string ids,
                                 std::string internalids,
                                 std::string source)
        : ids(std::move(ids)),
          internalids(std::move(internalids)),
          source(std::move(source)) {}
    std::string MessageSource::serializeToString() const {
        return source;
    }
    MessageSource MessageSource::deserializeFromString(const std::string &source) {
        json j = json::parse(source);
        try {
            return {j["ids"].dump(), j["internalIds"].dump(), source};
        } catch (json::type_error &e) {
            Logger::logger.error("消息源序列化出错，格式不符合(MessageSource::deserializeFromString)");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw IllegalArgumentException(std::string("消息源序列化出错，格式不符合(MessageSource::deserializeFromString), ") + e.what(), MIRAICP_EXCEPTION_WHERE);
        }
    }
} // namespace MiraiCP
//from src/sdk/MiraiCode.cpp
namespace MiraiCP {
    std::string MiraiCode::toString() {
        return Tools::escapeFromMiraiCode(this->content);
    }
    MiraiCode::MiraiCode(const std::string &a, bool convert) { // NOLINT(google-explicit-constructor)
        if (!convert)
            content = a;
        else
            content = Tools::escapeToMiraiCode(a);
    }
} // namespace MiraiCP
//from src/sdk/Schedule.cpp
//
// Created by antares on 11/10/22.
//
void MiraiCP::schedule(size_t time, const std::string &msg) {
    LibLoader::LoaderApi::timer(CPPPlugin::config.id, msg, time);
}
// todo(Antares): 之后改为优先队列，轮询，降低线程池的占用
void MiraiCP::schedule(std::chrono::seconds sec, const std::string &msg) {
    schedule(sec.count(), msg);
}
//from src/sdk/SingleMessage.cpp
#include <json.hpp>
namespace MiraiCP {
    using json = nlohmann::json;
    nlohmann::json SingleMessage::toJson() const {
        nlohmann::json re;
        re["type"] = "miraicode";
        re["content"] = this->toMiraiCode();
        return re;
    }
    // 静态成员
    const char *const *const SingleMessage::messageType = SingleMessageType::messageTypeInternal + 6;
    const char *const *const SingleMessage::miraiCodeName = SingleMessageType::miraiCodeNameInternal + 6;
    QuoteReply::QuoteReply(const SingleMessage &m) : SingleMessage(m) {
        if (m.internalType != type()) throw IllegalArgumentException("cannot convert type(" + std::to_string(m.internalType) + "to QuoteReply", MIRAICP_EXCEPTION_WHERE);
        source = MessageSource::deserializeFromString(m.content);
    }
    nlohmann::json QuoteReply::toJson() const {
        nlohmann::json re;
        re["type"] = "QuoteReply";
        re["source"] = nlohmann::json::parse(source.source);
        return re;
    }
    nlohmann::json PlainText::toJson() const {
        return {{"type",    SingleMessage::messageType[this->internalType]},
                {"content", content}};
    }
    int SingleMessage::getKey(const std::string &value) {
        for (auto index = Types::Begin; index != Types::End; ++index) {
            if (Tools::iequal(SingleMessage::messageType[index], value)) return index;
        }
        return Types::UnsupportedMessage_t; // default to unSupportMessage
    }
    int SingleMessage::getMiraiCodeKey(const std::string &value) {
        for (auto index = Types::Begin; index != Types::End; ++index) {
            if (Tools::iequal(SingleMessage::miraiCodeName[index], value)) return index;
        }
        return Types::UnsupportedMessage_t; // default to unSupportMessage
    }
    std::string SingleMessage::toMiraiCode() const {
        if (internalType > 0)
            if (internalType == Types::At_t)
                return "[mirai:at:" + content + "] ";
            else if (internalType == Types::AtAll_t)
                return "[mirai:atall] ";
            else
                return "[mirai:" + getTypeString(internalType) + prefix + Tools::escapeToMiraiCode(content) + "]";
        else
            return content;
    }
    PlainText::PlainText(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.internalType != type())
            throw IllegalArgumentException(
                    "Cannot convert(" + getTypeString(sg.internalType) + ") to PlainText", MIRAICP_EXCEPTION_WHERE);
        this->content = sg.content;
    }
    nlohmann::json At::toJson() const {
        return {{"type",   SingleMessage::messageType[this->internalType]},
                {"target", target}};
    }
    At::At(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.internalType != type())
            throw IllegalArgumentException(
                    "Cannot convert(" + getTypeString(sg.internalType) + ") to At", MIRAICP_EXCEPTION_WHERE);
        this->target = std::stol(sg.content);
    }
    nlohmann::json AtAll::toJson() const {
        return {{"type", SingleMessage::messageType[this->internalType]}};
    }
    nlohmann::json Image::toJson() const {
        return {{"type",      SingleMessage::messageType[this->internalType]},
                {"imageId",   id},
                {"size",      size},
                {"width",     width},
                {"height",    height},
                {"imageType", imageType},
                {"isEmoji",   isEmoji}};
    }
    bool Image::isUploaded(QQID botid) {
        if (!this->md5.has_value()) this->refreshInfo();
        if (this->size == 0) throw IllegalArgumentException("size不能为0", MIRAICP_EXCEPTION_WHERE);
        std::string re = KtOperation::ktOperation(KtOperation::ImageUploaded, {{"botId", botid}, {"image", toJson()}});
        return re == "true";
    }
    nlohmann::json FlashImage::toJson() const {
        return {{"type",      SingleMessage::messageType[this->internalType]},
                {"imageId",   id},
                {"size",      size},
                {"width",     width},
                {"height",    height},
                {"imageType", imageType}};
    }
    nlohmann::json LightApp::toJson() const {
        return {{"type",    SingleMessage::messageType[this->internalType]},
                {"content", content}};
    }
    LightApp::LightApp(const SingleMessage &sg) : SingleMessage(sg) {
        // todo(Antares): this was originally 3; why?
        if (sg.internalType != type())
            throw IllegalArgumentException(
                    "Cannot convert(" + getTypeString(sg.internalType) + ") to LighApp", MIRAICP_EXCEPTION_WHERE);
    }
    std::string LightApp::toMiraiCode() const {
        return "[mirai:app:" + Tools::escapeToMiraiCode(content) + "]";
    }
    nlohmann::json ServiceMessage::toJson() const {
        return {{"type",    SingleMessage::messageType[this->internalType]},
                {"content", content},
                {"id",      id}};
    }
    std::string ServiceMessage::toMiraiCode() const {
        return "[mirai:service" + this->prefix + Tools::escapeToMiraiCode(content) + "]";
    }
    ServiceMessage::ServiceMessage(const SingleMessage &sg) : SingleMessage(sg) {
        if (sg.internalType != type())
            throw IllegalArgumentException(
                    "Cannot convert(" + getTypeString(sg.internalType) + ") to ServiceMessage", MIRAICP_EXCEPTION_WHERE);
    }
    nlohmann::json Face::toJson() const {
        return {{"type", SingleMessage::messageType[this->internalType]},
                {"id",   id}};
    }
    nlohmann::json UnSupportMessage::toJson() const {
        return {{"type",    SingleMessage::messageType[this->internalType]},
                {"struct", content}};
    }
    //远程文件(群文件)
    RemoteFile::RemoteFile(
            const std::string &i,
            unsigned int ii,
            std::string n,
            long long s,
            std::string p,
            struct Dinfo d,
            struct Finfo f)
        : SingleMessage(
                  RemoteFile::type(),
                  i + "," + std::to_string(ii) + "," + Tools::escapeToMiraiCode(n) + "," + std::to_string(s)),
          id(i),
          internalid(ii),
          name(std::move(n)),
          size(s),
          path(std::move(p)),
          dinfo(std::move(d)),
          finfo(f) {}
    RemoteFile::RemoteFile(
            const std::string &i,
            unsigned int ii,
            std::string n,
            long long s)
        : SingleMessage(
                  6,
                  i + "," + std::to_string(ii) + "," + Tools::escapeToMiraiCode(n) + "," + std::to_string(s)),
          id(i),
          internalid(ii),
          name(std::move(n)),
          size(s) {}
    RemoteFile RemoteFile::deserializeFromString(const std::string &source) {
        json j;
        try {
            j = json::parse(source);
        } catch (json::parse_error &e) {
            Logger::logger.error("格式化json失败，RemoteFile::deserializeFromString");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw e;
        }
        try {
            auto re = RemoteFile(j["id"], j["internalId"], j["name"], j["detailInfo"]["size"]);
            if (j.contains("downloadInfo")) {
                auto tmp = Tools::json_jsonmover(j, "downloadInfo");
                struct Dinfo d {
                    Tools::json_jsonmover(tmp, "url"),
                    Tools::json_jsonmover(tmp, "md5"),
                        Tools::json_jsonmover(tmp, "sha1")
                };
                re.dinfo = d;
            }
            if (j["detailInfo"].contains("uploaderId")) {
                auto tmp = Tools::json_jsonmover(j, "detailInfo");
                struct Finfo f {
                        Tools::json_jsonmover(tmp, "size"),
                        Tools::json_jsonmover(tmp, "uploaderId"),
                        Tools::json_jsonmover(tmp, "expiryTime"),
                        Tools::json_jsonmover(tmp, "uploadTime"),
                        Tools::json_jsonmover(tmp, "lastModifyTime")
                };
                re.finfo = f;
            }
            if (j.contains("path"))
                re.path = Tools::json_jsonmover(j, "path");
            return re;
        } catch (json::type_error &e) {
            Logger::logger.error("json格式化失败，位置:RemoteFile");
            Logger::logger.error(source);
            Logger::logger.error(e.what());
            throw e;
        }
    }
    RemoteFile RemoteFile::plus(unsigned int ii) {
        RemoteFile tmp(*this);
        tmp.internalid = ii;
        tmp.content = id + "," + std::to_string(ii) + "," + Tools::escapeToMiraiCode(name) + "," +
                      std::to_string(size);
        return tmp;
    }
    std::string RemoteFile::serializeToString() {
        json j;
        if (this->dinfo.has_value()) {
            j["dinfo"]["url"] = this->dinfo->url;
            j["dinfo"]["md5"] = this->dinfo->md5;
            j["dinfo"]["shar1"] = this->dinfo->sha1;
        }
        if (this->finfo.has_value()) {
            j["finfo"]["size"] = this->finfo->size;
            j["finfo"]["uploaderid"] = this->finfo->uploaderid;
            j["finfo"]["expirytime"] = this->finfo->expirytime;
            j["finfo"]["uploadtime"] = this->finfo->uploadtime;
            j["finfo"]["lastmodifytime"] = this->finfo->lastmodifytime;
        }
        j["id"] = this->id;
        j["internalid"] = this->internalid;
        j["name"] = this->name;
        j["size"] = this->size;
        if (this->path.has_value())
            j["path"] = this->path.value();
        return j.dump();
    }
    /*图片类实现*/
    void Image::refreshInfo() {
        std::string re = KtOperation::ktOperation(KtOperation::QueryImgInfo, toJson());
        if (re == "E1")
            throw RemoteAssetException("图片id格式错误", MIRAICP_EXCEPTION_WHERE);
        json j = json::parse(re);
        this->url = Tools::json_stringmover(j, "url");
        this->md5 = Tools::json_stringmover(j, "md5");
        this->size = j["size"];
        this->width = j["width"];
        this->height = j["height"];
        this->imageType = j["imageType"];
        this->isEmoji = j["isEmoji"];
    }
    Image Image::deserialize(const std::string &str) {
        json j = json::parse(str);
        return Image(
                j["imageId"],
                j["size"],
                j["width"],
                j["height"],
                j["imageType"],
                j["isEmoji"]);
    }
    FlashImage FlashImage::deserialize(const std::string &str) {
        json j = json::parse(str);
        return FlashImage(
                j["imageId"],
                j["size"],
                j["width"],
                j["height"],
                j["imageType"]);
    }
    FlashImage::FlashImage(const Image &img) {
        if (img.internalType == FlashImage::type()) {
            *this = static_cast<const FlashImage &>(img); // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        } else if (img.internalType == Image::type()) {
            static_cast<Image &>(*this) = img;
        } else {
            MIRAICP_THROW(IllegalArgumentException, "拷贝构造FlashImage时传入参数无法正确转换");
        }
    }
} // namespace MiraiCP
//from src/sdk/ThreadTask.cpp
//
// Created by antares on 11/8/22.
//
#include <atomic>
#include <deque>
#include <shared_mutex>
namespace MiraiCP::ThreadTask::internal {
    // todo(Antares): add verbose log
    using functionType = std::function<void()>;
    using functionPointerType = std::shared_ptr<functionType>;
    using storerType = std::unordered_map<size_t, functionPointerType>;
    using storerIteratorType = storerType::iterator;
    inline auto &get_function_storer() {
        static storerType function_storer;
        return function_storer;
    }
    inline auto &get_mutex() {
        static std::shared_mutex mtx;
        return mtx;
    }
    size_t get_auto_incr_id() {
        static std::atomic<size_t> id = 0;
        return id++;
    }
    void push_task(size_t id, functionPointerType func) {
        bool insert;
        {
            std::unique_lock lk(get_mutex());
            insert = get_function_storer().insert({id, std::move(func)}).second;
        }
        if (!insert) {
            Logger::logger.error("Fatal: task id " + std::to_string(id) + " is already taken by another task!");
            return;
        }
        LibLoader::LoaderApi::pushTaskWithId(task_interface, id);
    }
    void remove_task(size_t id) {
        size_t erased;
        {
            std::unique_lock lk(get_mutex());
            erased = get_function_storer().erase(id);
        }
        if (0 == erased) {
            Logger::logger.error("Invalid task id " + std::to_string(id) + " is requested to erase");
        }
    }
    /// @note dev: we can't send a std::function object to libLoader,
    ///  so one appropriate way is that store the function in a data structure and call it in a wrapper function.
    void task_interface(size_t id) {
        static_assert(std::is_same_v<LibLoader::LoaderApi::task_func_with_id, decltype(&task_interface)>);
        storerIteratorType iter;
        functionPointerType fPtr;
        {
            std::shared_lock lck(get_mutex());
            iter = get_function_storer().find(id);
            if (iter == get_function_storer().end()) {
                Logger::logger.error("Invalid task id " + std::to_string(id) + " is requested to run");
                return;
            }
            fPtr = iter->second;
        }
        // running task!
        (*fPtr)();
    }
} // namespace MiraiCP::ThreadTask::internal
//from src/sdk/Tools.cpp
#include <regex>
namespace MiraiCP::Tools {
    // 工具函数实现
    std::string replace(std::string str, std::string_view from, std::string_view to) {
        size_t start_pos = 0;
        while ((start_pos = str.find(from, start_pos)) != std::string::npos) {
            str.replace(start_pos, from.length(), to);
            start_pos += to.length(); // Handles case where 'to' is a substd::string of 'from'
        }
        return str;
    }
    inline void split(const std::string &s, std::vector<std::string> &tokens, const std::string &delimiters = ",") {
        std::string::size_type lastPos = s.find_first_not_of(delimiters, 0);
        std::string::size_type pos = s.find_first_of(delimiters, lastPos);
        while (std::string::npos != pos || std::string::npos != lastPos) {
            tokens.emplace_back(s.substr(lastPos, pos - lastPos));
            lastPos = s.find_first_not_of(delimiters, pos);
            pos = s.find_first_of(delimiters, lastPos);
        }
    }
    std::vector<QQID> StringToVector(std::string temp) {
        if (temp.empty()) return {};
        if (temp[0] == '[' && temp[temp.size() - 1] == ']') {
            temp.erase(temp.begin());
            temp.pop_back();
        }
        std::vector<std::string> strResult;
        split(temp, strResult);
        std::vector<QQID> ans;
        ans.reserve(strResult.size());
        for (auto &str: strResult) {
            ans.emplace_back(stoull(str));
        }
        return ans;
    }
    std::string escapeFromMiraiCode(const std::string &s) {
        //[	\[
        //]	\]
        //:	\:
        //,	\,
        //\	\\ /
        return replace(replace(replace(replace(replace(s,
                                                       "\\\\", "\\"),
                                               "\\,", ","),
                                       "\\:", ":"),
                               "\\]", "]"),
                       "\\[", "[");
    }
    std::string escapeToMiraiCode(const std::string &s) {
        //[	\[
        //]	\]
        //:	\:
        //,	\,
        //\	\\ /
        return replace(replace(replace(replace(replace(s,
                                                       "\\", "\\\\"),
                                               ",", "\\,"),
                                       ":", "\\:"),
                               "]", "\\]"),
                       "[", "\\[");
    }
    bool starts_with(std::string_view f, std::string_view s) { return f.rfind(s, 0) == 0; }
    bool icompareChar(const char &c1, const char &c2) {
        return c1 == c2 || std::toupper(c1) == std::toupper(c2);
    }
    bool iequal(std::string_view str1, std::string_view str2) {
        return ((str1.size() == str2.size()) &&
                std::equal(str1.begin(), str1.end(), str2.begin(), &icompareChar));
    }
    std::vector<std::string> split(const std::string &text, const std::string &delim) {
        std::regex ws_re(delim + "+");
        return {std::sregex_token_iterator(text.begin(), text.end(), ws_re, -1), std::sregex_token_iterator()};
    }
} // namespace MiraiCP::Tools
//from src/sdk/loaderApi.cpp
#include <string>
#include <vector>
namespace LibLoader::LoaderApi {
    static const interface_funcs *loader_apis = nullptr;
    MIRAICP_EXPORT void set_loader_apis(const LibLoader::LoaderApi::interface_funcs *apis) noexcept {
        loader_apis = apis;
    }
    MIRAICP_EXPORT void reset_loader_apis() noexcept {
        loader_apis = nullptr;
    }
    /// 这个函数是给本cpp以外的文件使用的，大概率用不到
    const interface_funcs *get_loader_apis() {
        return loader_apis;
    }
    using MiraiCP::PluginNotAuthorizedException;
    using MiraiCP::PluginNotEnabledException;
    // check the func ptr existance before use it
    inline void checkApi(void *funcptr) {
        if (loader_apis == nullptr) [[unlikely]] {
            throw PluginNotEnabledException(MIRAICP_EXCEPTION_WHERE);
        } else if (funcptr == nullptr) [[unlikely]] {
            throw PluginNotAuthorizedException(MIRAICP_EXCEPTION_WHERE);
        }
    }
    /// interfaces for plugins
    MiraiCPString pluginOperation(const MiraiCPString &s) {
        checkApi((void *) loader_apis->_pluginOperation);
        return loader_apis->_pluginOperation(s);
    }
    void loggerInterface(const MiraiCPString &content, const MiraiCPString &name, long long id, int level) {
        checkApi((void *) loader_apis->_loggerInterface);
        loader_apis->_loggerInterface(content, name, id, level);
    }
    MiraiCPString showAllPluginId() {
        checkApi((void *) loader_apis->_showAllPluginId);
        return loader_apis->_showAllPluginId();
    }
    void pushTask(task_func func) {
        checkApi((void *) loader_apis->_pushTask);
        loader_apis->_pushTask(func);
    }
    void pushTaskWithId(task_func_with_id func, size_t id) {
        checkApi((void *) loader_apis->_pushTaskWithId);
        loader_apis->_pushTaskWithId(func, id);
    }
    void timer(const MiraiCPString &id, const MiraiCPString &content, size_t sec) {
        checkApi((void *) loader_apis->_timer);
        loader_apis->_timer(id, content, sec);
    }
    void enablePluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_enablePluginById);
        loader_apis->_enablePluginById(id);
    }
    void disablePluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_disablePluginById);
        loader_apis->_disablePluginById(id);
    }
    void enableAllPlugins() {
        checkApi((void *) loader_apis->_enableAllPlugins);
        loader_apis->_enableAllPlugins();
    }
    void disableAllPlugins() {
        checkApi((void *) loader_apis->_disableAllPlugins);
        loader_apis->_disableAllPlugins();
    }
    void loadNewPlugin(const MiraiCPString &path, bool activateNow) {
        checkApi((void *) loader_apis->_loadNewPlugin);
        loader_apis->_loadNewPlugin(path, activateNow);
    }
    void unloadPluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_unloadPluginById);
        loader_apis->_unloadPluginById(id);
    }
    void reloadPluginById(const MiraiCPString &id) {
        checkApi((void *) loader_apis->_reloadPluginById);
        loader_apis->_reloadPluginById(id);
    }
} // namespace LibLoader::LoaderApi
namespace MiraiCP::LoaderApi {
    void loggerInterface(const std::string &content, const std::string &name, long long int id, int level) {
        LibLoader::LoaderApi::loggerInterface(content, name, id, level);
    }
    std::vector<std::string> showAllPluginId() {
        nlohmann::json::array_t PluginIdList = nlohmann::json::parse(LibLoader::LoaderApi::showAllPluginId().toString());
        return {PluginIdList.begin(), PluginIdList.end()};
    }
    void enablePluginById(const std::string &id) {
        LibLoader::LoaderApi::enablePluginById(id);
    }
    void disablePluginById(const std::string &id) {
        LibLoader::LoaderApi::disablePluginById(id);
    }
    void enableAllPlugins() {
        LibLoader::LoaderApi::enableAllPlugins();
    }
    void disableAllPlugins() {
        LibLoader::LoaderApi::disableAllPlugins();
    }
    void loadNewPlugin(const std::string &path, bool enableNow) {
        LibLoader::LoaderApi::loadNewPlugin(path, enableNow);
    }
    void unloadPluginById(const std::string &id) {
        LibLoader::LoaderApi::unloadPluginById(id);
    }
    void reloadPluginById(const std::string &id) {
        LibLoader::LoaderApi::reloadPluginById(id);
    }
} // namespace MiraiCP::LoaderApi
//from src/sdk/utils.cpp
// -----------------------
#include <iostream>
// 开始对接libloader接口代码
using json = nlohmann::json;
namespace LibLoader::LoaderApi {
    const interface_funcs *get_loader_apis();
    MIRAICP_EXPORT void set_loader_apis(const LibLoader::LoaderApi::interface_funcs *apis) noexcept;
    MIRAICP_EXPORT void reset_loader_apis() noexcept;
} // namespace LibLoader::LoaderApi
extern "C" {
/// 插件开启入口
MIRAICP_EXPORT int FUNC_ENTRANCE(const LibLoader::LoaderApi::interface_funcs &funcs) {
    static_assert(std::is_same_v<decltype(&FUNC_ENTRANCE), LibLoader::plugin_entrance_func_ptr>);
    using namespace MiraiCP;
    Event::clear();
    LibLoader::LoaderApi::set_loader_apis(&funcs);
    assert(LibLoader::LoaderApi::get_loader_apis() != nullptr);
    // logger api is set
    try {
        Logger::logger.info("开始启动插件: " + MiraiCP::CPPPlugin::config.getId());
        enrollPlugin();
        // plugin == nullptr 无插件实例加载
        if (CPPPlugin::plugin != nullptr) {
            CPPPlugin::plugin->onEnable();
        }
    } catch (const MiraiCPExceptionBase &e) {
        try {
            std::cerr.flush();
            e.raise();
            Logger::logger.error("插件(id=" + CPPPlugin::config.getId() + ", name=" + CPPPlugin::config.name + ")启动失败");
        } catch (...) {}
        return PLUGIN_ERROR;
    } catch (const std::exception &e) {
        try {
            std::cerr.flush();
            Logger::logger.error(e.what());
            Logger::logger.error("插件(id=" + CPPPlugin::config.getId() + ", name=" + CPPPlugin::config.name + ")启动失败");
        } catch (...) {}
        return PLUGIN_ERROR;
    } catch (...) {
        try {
            std::cerr.flush();
            Logger::logger.error("插件(id=" + CPPPlugin::config.getId() + ", name=" + CPPPlugin::config.name + ")启动失败");
        } catch (...) {}
        return PLUGIN_ERROR;
    }
    return PLUGIN_NORMAL;
}
/// 插件结束(也可能是暂时的disable)
MIRAICP_EXPORT int FUNC_EXIT() {
    static_assert(std::is_same_v<decltype(&FUNC_EXIT), LibLoader::plugin_func_ptr>);
    using namespace MiraiCP;
    if (LibLoader::LoaderApi::get_loader_apis() == nullptr) return PLUGIN_NORMAL;
    MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Logger::logger.info("开始禁用插件：" + MiraiCP::CPPPlugin::config.getId());)
    Event::clear();
    MIRAICP_CRITICAL_NOEXCEPT_BLOCK(if (CPPPlugin::plugin != nullptr) CPPPlugin::plugin->onDisable();)
    CPPPlugin::plugin.reset();
    // 无法保证用户插件析构函数是否调用api，在plugin.reset()之前不可reset loader api
    LibLoader::LoaderApi::reset_loader_apis();
    return PLUGIN_NORMAL;
}
/// 消息解析分流
/// env != null, call from jni
/// 除了致命问题，该函数不会返回 ERROR
MIRAICP_EXPORT int FUNC_EVENT(const MiraiCP::MiraiCPString &c) {
    static_assert(std::is_same_v<decltype(&FUNC_EVENT), LibLoader::plugin_event_func_ptr>);
    using namespace MiraiCP;
    std::string content = c;
    json j;
    try {
        j = json::parse(content);
    } catch (json::parse_error &e) {
        MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Logger::logger.error("消息解析分流：格式化json错误");
                                        Logger::logger.error("For debug: " + content);
                                        Logger::logger.error(e.what());)
        return PLUGIN_NORMAL;
    }
    int type;
    try {
        if (!j.is_object() || !j.contains("eventId") || !j["eventId"].is_number()) {
            MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Logger::logger.error("Json格式错误：没有eventId这一field或这一field不是数字类型");)
            return PLUGIN_NORMAL;
        }
        type = j["eventId"].get<int>();
        if (type != eventTypes::Command && Event::noRegistered(type)) return PLUGIN_NORMAL;
    } catch (...) {
        MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Logger::logger.error("Json格式错误：解析json时遇到无法预料的异常");)
        return PLUGIN_NORMAL;
    }
    try {
        // core logic
        Event::incomingEvent(BaseEventData(std::move(j)), type);
    } catch (json::type_error &e) {
        MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Logger::logger.error("json格式化异常,位置：FUNC_EVENT");
                                        Logger::logger.error(e.what());
                                        Logger::logger.error(content);)
        return PLUGIN_NORMAL;
    } catch (MiraiCPExceptionBase &e) {
        MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Event::broadcast<MiraiCPExceptionEvent>(MiraiCPExceptionEvent(&e));
                                        e.raise();)
        return PLUGIN_NORMAL;
    } catch (const std::exception &e) {
        MIRAICP_CRITICAL_NOEXCEPT_BLOCK(Logger::logger.error(e.what());
                                        Logger::logger.error("info:", content);)
        return PLUGIN_NORMAL;
    } catch (...) {
        // 如果产生了无法处理的异常，直接退出插件，return 非0值
        // loader端将处理这个异常并直接unload绑定的插件
        // 如果存在其他线程，可能导致段错误
        return PLUGIN_ERROR;
    }
    return PLUGIN_NORMAL;
}
/// 获取 Plugin Info
/// 如果未正确定义，插件无法正确加载
/// 该函数不可调用loader api；因为会在入口函数调用前先调用，loader api未初始化
MIRAICP_EXPORT const MiraiCP::PluginConfig *PLUGIN_INFO() {
    static_assert(std::is_same_v<decltype(&PLUGIN_INFO), LibLoader::plugin_info_func_ptr>);
    //    if (MiraiCP::CPPPlugin::config.getIdSafe().empty())
    //        throw std::exception();
    return &MiraiCP::CPPPlugin::config; // never nullptr
}
}
//结束对接JNI接口代码
//from src/common/MiraiCPStringInternal.cpp
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// -----------------------
#ifdef MIRAICP_LIB_LOADER
#endif
#include <cstring>
namespace MiraiCP {
    // avoid calling this if _size == 0
    void MiraiCPString::construction() {
        str = (char *) ::std::malloc(sizeof(char) * (_size + 1));
        if (str == nullptr) {
#ifdef MIRAICP_LIB_LOADER
            LibLoader::logger.error("MiraiCPString::construction: malloc failed when trying to malloc size " + std::to_string(_size + 1));
#endif
            throw std::bad_alloc();
        }
    }
    MiraiCPString::~MiraiCPString() { // do not inherit MiraiCPString!!
        if (str != nullptr) {
            // ensure deconstruction is paired to construction
            free_this(str);
            str = nullptr;
        }
    }
    MiraiCPString::MiraiCPString(const MiraiCPString &other) {
        _size = other._size;
        if (_size == 0) return;
        construction();
        assert(str != nullptr);
        memcpy(str, other.str, _size * sizeof(char));
        str[_size] = 0;
    }
    MiraiCPString::MiraiCPString(MiraiCPString &&temp) noexcept {
        swap(temp);
    }
    MiraiCPString::MiraiCPString(const char *char_str) {
        if (char_str == nullptr) return;
        _size = strlen(char_str);
        if (0 == _size) return;
        construction();
        assert(str != nullptr);
        memcpy(str, char_str, _size * sizeof(char));
        str[_size] = 0;
    }
    MiraiCPString::MiraiCPString(const std::string &string_str) {
        _size = string_str.size();
        if (!_size) return;
        construction();
        assert(str != nullptr);
        memcpy(str, string_str.c_str(), _size * sizeof(char));
        str[_size] = 0;
    }
    const char *MiraiCPString::copyToCharPtr() const {
        if (str == nullptr || _size == 0) return new char[1]{0};
        char *t = new char[_size + 1];
        memcpy(t, str, (_size + 1) * sizeof(char));
        return t;
    }
    bool MiraiCPString::operator==(const MiraiCPString &another) const {
        return another._size == _size && (_size == 0 || strcmp(another.str, str) == 0);
    }
    MiraiCPString &MiraiCPString::operator=(const MiraiCPString &another) {
        MiraiCPString temp(another);
        swap(temp);
        return *this;
    }
    MiraiCPString &MiraiCPString::operator=(MiraiCPString &&another) noexcept {
        swap(another);
        return *this;
    }
    void MiraiCPString::swap(MiraiCPString &other) noexcept {
        std::swap(str, other.str);
        std::swap(_size, other._size);
        std::swap(free_this, other.free_this);
    }
} // namespace MiraiCP
//from src/common/PluginConfig.cpp
namespace MiraiCP {
    using json = nlohmann::json;
    json PluginConfig::serialize() {
        json j;
        j["name"] = name;
        j["version"] = version;
        j["author"] = author;
        j["description"] = description;
        j["time"] = time;
        j["id"] = id;
        return j;
    }
    std::string PluginConfig::serialize2string() {
        return serialize().dump();
    }
} // namespace MiraiCP
//from src/common/ThreadIdentify.cpp
//
// Created by 60168 on 2023-1-25.
//
#include <mutex>
#include <shared_mutex>
#include <thread>
#include <unordered_map>
#if MIRAICP_MSVC /// Windows case
#include <Windows.h>
#include <processthreadsapi.h>
#include <string>
#define SET_THREADNAME(name)                                   \
    size_t len = strlen(name);                                 \
    std::wstring wst(len + 1, '#');                            \
    size_t num_convert;                                        \
    mbstowcs_s(&num_convert, &wst[0], len + 1, name, len + 1); \
    SetThreadDescription(GetCurrentThread(), &wst[0])
#define GET_THREADNAME(buffer, buffersize)                 \
    wchar_t *wbuf;                                         \
    GetThreadDescription(GetCurrentThread(), &wbuf);       \
    size_t num_convert;                                    \
    wcstombs_s(&num_convert, buf, bufsize, wbuf, bufsize); \
    LocalFree(wbuf);
#elif defined(_POSIX_THREADS) /// pthread case
#ifdef PTHREAD_SET_SUPPORTED
#define SET_THREADNAME(name) pthread_setname_np(pthread_self(), name)
#else
#define SET_THREADNAME(name)
#endif
#ifdef PTHREAD_GET_SUPPORTED
#define GET_THREADNAME(buffer, buffersize) pthread_getname_np(pthread_self(), buffer, buffersize);
#else
#define GET_THREADNAME(buffer, buffersize) buffer[0] = 0
#endif
#else /// others
#define SET_THREADNAME(name)
#define GET_THREADNAME(buffer, buffersize) buffer[0] = 0
#endif
namespace ThreadIdentify {
    thread_local bool isPoolThread = false;
    thread_local bool isLoaderThread = false;
    void IAmPoolThread() {
        isPoolThread = true;
        SET_THREADNAME("LoaderWorker");
    }
    bool isMePoolThread() {
        return isPoolThread;
    }
    void IAmLoaderThread() {
        isLoaderThread = true;
        SET_THREADNAME("libLoader");
    }
    bool isMeLoaderThread() {
        return isLoaderThread;
    }
    using id = std::thread::id;
    std::unordered_map<id, std::string> Identify;
    std::shared_mutex mtx;
    void setMyThreadName(const std::string &name) {
        std::unique_lock _lk(mtx);
        auto success = Identify.insert({std::this_thread::get_id(), name}).second;
        if (!success) {
            // todo
        }
        std::string t;
#if defined(_POSIX_THREADS) && defined(PTHREAD_SET_SUPPORTED)
        // 受限于Linux内核，只取前15个char，否则会失败
        if (name.size() > 15) {
            t.append(std::string_view(name), 15);
        } else {
            t = name;
        }
        SET_THREADNAME(t.c_str());
#else
        t = name;
        SET_THREADNAME(t.c_str());
#endif
    }
    std::string identifyMe() {
        std::shared_lock _lk(mtx);
        return Identify[std::this_thread::get_id()];
    }
} // namespace ThreadIdentify
//from src/common/redirectCout.cpp
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
// -----------------------
#include <iostream>
#include <memory>
#include <sstream>
#ifdef MIRAICP_LIB_LOADER
#else
#endif
class OStreamRedirector {
    // 旧的缓冲区目标
    std::streambuf *old;
    // 被重定向的流
    std::ostream *obj;
    std::ostream oldStream;
public:
    ~OStreamRedirector() {
        obj->rdbuf(old);
        obj = nullptr;
        old = nullptr;
    }
    /**
         * @brief 重定向 obj 的流
         * @param obj 需要重定向的流
         * @param new_buffer 重定向到的新缓冲区
         */
    explicit OStreamRedirector(std::ostream *in_obj, std::streambuf *newBuffer) : old(in_obj->rdbuf(newBuffer)),
                                                                                  obj(in_obj), oldStream(old) {}
private:
    // print directly
    friend void print(const std::string &);
};
class OString : public std::ostream {
    class OStringBuf : public std::streambuf {
        friend class OString;
        typedef void (*Recorder)(std::string);
        //
        explicit OStringBuf(bool inIsInfoLevel) : isInfoLevel(inIsInfoLevel) {}
        ~OStringBuf() override = default;
        //
        std::ostringstream result{};
        Recorder recorder = nullptr;
        bool isInfoLevel;
        //
        // 输出缓冲区内容, 相当于 flush
        std::string out();
        // std::streambuf interface
        int sync() override {
            record(out());
            return 0;
        }
        // std::streambuf interface
        // 加入缓冲区
        int overflow(std::streambuf::int_type c) override {
            if (c == EOF)
                record(out());
            else
                result.put((std::streambuf::char_type) c);
            return c;
        }
        void record(std::string message) {
            if (recorder) [[unlikely]] {
                recorder(std::move(message));
            }
        }
    };
public:
    using Recorder = OStringBuf::Recorder;
private:
    // 缓冲区
    OStringBuf sbuf;
public:
    // 输出是否为 info 级别
    explicit OString(bool info) : std::ostream(&sbuf), sbuf(info) {}
    ~OString() override = default;
    void setRecorder(Recorder recorder) {
        sbuf.recorder = recorder;
    }
};
// --- impl ---
OString outTarget(true);
OString errTarget(false);
std::unique_ptr<OStreamRedirector> outRedirector;
std::unique_ptr<OStreamRedirector> errRedirector;
struct RedirectedOstreamPair {
public:
    std::ostream *out = &std::cout;
    std::ostream *err = &std::cerr;
} RedirectedOstreamPointers;
std::string OString::OStringBuf::out() {
    std::string resultstr = result.str();
    result.str("");
#ifdef MIRAICP_LIB_LOADER
    auto &localLogger = LibLoader::logger;
#else
    auto &localLogger = MiraiCP::Logger::logger;
#endif
    if (isInfoLevel)
        localLogger.info(resultstr);
    else
        localLogger.error(resultstr);
    return resultstr;
}
void MiraiCP::Redirector::reset() {
    outRedirector.reset();
    errRedirector.reset();
}
void print(const std::string &str) {
    if (outRedirector == nullptr) {
        std::cout << str << std::endl;
    } else {
        outRedirector->oldStream << str;
        outRedirector->oldStream.flush();
    }
}
void MiraiCP::Redirector::setRedirectedObjs(std::ostream *outStream, std::ostream *errStream) {
    RedirectedOstreamPointers = {outStream, errStream};
}
void MiraiCP::Redirector::start() {
    outRedirector = std::make_unique<OStreamRedirector>(RedirectedOstreamPointers.out, outTarget.rdbuf());
    errRedirector = std::make_unique<OStreamRedirector>(RedirectedOstreamPointers.err, errTarget.rdbuf());
}
namespace MiraiCP::Redirector {
    /// @note dev: this function is only used for tests;
    ///  should never be declared in source headers
    MIRAICP_EXPORT void SetCoutRecorder(void (*recorder)(std::string)) {
        outTarget.setRecorder(recorder);
    }
    /// @note dev: this function is only used for tests;
    ///  should never be declared in source headers
    MIRAICP_EXPORT void SetCerrRecorder(void (*recorder)(std::string)) {
        errTarget.setRecorder(recorder);
    }
} // namespace MiraiCP::Redirector
