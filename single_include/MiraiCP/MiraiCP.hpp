// This file is generated automatically by amalgamate;
// GitHub repo https://github.com/edlund/amalgamate
// When contributing to this repository, please DO NOT edit this file.
// Copyright (C) 2020-2021 Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
#ifndef MIRAICP_PRO_BOT_H
#define MIRAICP_PRO_BOT_H
#include <jni.h>
#include <string>
#include <vector>
namespace MiraiCP {
    class Friend;  // forward declaration
    class Group;   // forward declaration
    class Contact; // forward declaration
    using QQID = unsigned long long;
    /// 当前bot账号信息
    class Bot {
    private:
        bool inited = false;
        std::string _nick;
        std::string _avatarUrl;
    public:
        /// 该botid
        QQID id;
    private:
        void check() {
            if (!this->inited) {
                refreshInfo();
                this->inited = true;
            }
        }
    public:
        /*!
         * @brief 刷新bot信息
         * @param env
         */
        void refreshInfo(JNIEnv *env = nullptr);
        /// 用id构建机器人
        explicit Bot(QQID i) : id(i) {}
        /// 取好友
        Friend getFriend(QQID i, JNIEnv *env = nullptr) const;
        /// 取群聊
        Group getGroup(QQID groupid, JNIEnv *env = nullptr) const;
        /// 昵称
        std::string nick() {
            check();
            return this->_nick;
        }
        /// 头像下载链接
        std::string avatarUrl() {
            check();
            return this->_avatarUrl;
        }
        /// 取好友列表
        std::vector<QQID> getFriendList(JNIEnv *env = nullptr) const;
        /// 好友列表string形式返回，利于保存
        std::string FriendListToString();
        /// 取群列表
        std::vector<QQID> getGroupList(JNIEnv *env = nullptr) const;
        /// 群列表string形式返回，利于保存
        std::string GroupListToString() const;
        bool operator==(const Contact &c) const;
        bool operator==(const Bot &b) const {
            return this->id == b.id;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_BOT_H
#ifndef MIRAICP_PRO_CPPPLUGIN_H
#define MIRAICP_PRO_CPPPLUGIN_H
// #include "Logger.h"
#ifndef MIRAICP_PRO_LOGGER_H
#define MIRAICP_PRO_LOGGER_H
#include <functional>
#include <sstream>
#include <jni.h>
#include <json.hpp>
// #include "MiraiCode.h"
#ifndef MIRAICP_PRO_MIRAICODE_H
#define MIRAICP_PRO_MIRAICODE_H
#include <string>
namespace MiraiCP {
    /// MiraiCode父类, 指可以被转换成miraicode的类型
    class MiraiCodeable {
    public:
        /// 返回MiraiCode
        virtual std::string toMiraiCode() const = 0;
    };
    /// @brief miraicode字符串
    /// @attention MiraiCode会把非miraicode组成部分(非[mirai:])转码, 输出转码前的文本用toString, 参考: https://github.com/mamoe/mirai/blob/dev/docs/Messages.md#%E8%BD%AC%E4%B9%89%E8%A7%84%E5%88%99
    /// @detail 为了便捷使用，构造函数不以explicit注释
    class MiraiCode : public MiraiCodeable {
    private:
        std::string content;
    public:
        /// 输出当前内容, 会自动转码
        std::string toString();
        /// 和toString作用一样, 不过不会自动转码
        std::string toMiraiCode() const override {
            return content;
        }
        /// 从MiraiCodeable类型初始化一个miraicode字符串
        MiraiCode(MiraiCodeable *a) { // NOLINT(google-explicit-constructor)
            content = a->toMiraiCode();
        }
        /// 从文本初始化一个miraicode字符串, 根据第二个参数决定是否转码, 默认不转码
        /// @attention 如果是传入文本MiraiCode，请勿转码，转码只是为了[mirai:xxx:<应该转码的部分>], 如果<应该转码>的部分里面含有'[]:,'内容，请调用Tools::escapeToMiraiCode转码
        MiraiCode(const std::string &a, bool convert = false);
        MiraiCode operator+(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode operator+(const std::string &a) {
            return {content + a};
        }
        MiraiCode operator+(const MiraiCode &a) {
            return {content + a.content};
        }
        MiraiCode operator+(MiraiCode *a) {
            return {content + a->content};
        }
        MiraiCode &operator=(const std::string &a) {
            this->content = a;
            return *this;
        }
        MiraiCode plus(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode plus(const std::string &a) {
            return MiraiCode(a) + this;
        }
        /// 不执行转义，适用于已经被MiraiCode转义过的字符串
        static MiraiCode MiraiCodeWithoutEscape(const std::string &a) {
            return {a, false};
        }
        /// 不执行转义，因为MiraiCodeable的toMiraiCode已经转义过了
        static MiraiCode MiraiCodeWithoutEscape(MiraiCodeable *a) {
            return {a->toMiraiCode(), false};
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MIRAICODE_H
namespace MiraiCP {
    using QQID = unsigned long long;
    class MiraiCodeable; // forward declaration
    /*!
    * @class Logger
    * @brief 以MiraiCP的名义发送日志, 日志表现格式是: 2021-06-28 09:37:22 [log level]/MiraiCP: [log content], 为最底层的logger
    * @example 发送日志
	* 发送消息级日志
	* @code Logger::logger.info(string) @endcode
	* 发送警告级日志
	* @code Logger::logger.warning(string) @endcode
	* 发送错误级日志
	* @code Logger::logger.error(string) @endcode
    * @example 设置loggerhandler的action(check in version 2.9.0)
    * @code
     * Logger::logger.registerHandle([](std::string content, int level){
    *     \\do some things
    * });
    * @endcode
    */
    class Logger_interface {
        using string = std::string;
    public:
        /// @brief 封装lambda类型
        /// @param string 日志内容
        /// @param 日志级别
        ///     - 0 info
        ///     - 1 warning
        ///     - 2 error
        typedef std::function<void(string, int)> Action;
        /// @brief loggerhandler会在每次log执行前执行一遍，可用于执行自定义的保存操作等
        struct Handler {
            /// @brief 是否启用
            bool enable = true;
            /// @brief 执行的操作，格式为lambda
            Action action = [](const string &content, int level) {};
        };
        Handler loggerhandler;
    protected:
        jmethodID log = nullptr;
    private:
        std::string p() {
            return "";
        }
        template<class T, class... T1>
        std::string p(T val, T1... val1) {
            std::stringstream sstream;
            sstream << val;
            return sstream.str() + p(val1...);
        }
        template<class... T>
        std::string p(std::string a, T... val1) {
            return a + p(val1...);
        }
        template<class... T>
        std::string p(MiraiCodeable &val, T... val1) {
            return val.toMiraiCode() + p(val1...);
        }
    protected:
        void log0(const string &log, int level, nlohmann::json j, JNIEnv *env = nullptr);
        /// @brief 日志底层实现封装
        /// @param log 日志内容
        /// @param level 日志等级
        /// @param env jnienv
        virtual void log1(const string &log, int level, JNIEnv *env = nullptr) = 0;
    public:
        jmethodID getjmethod() {
            return this->log;
        }
        // 初始化 获取methodid
        void init(JNIEnv * = nullptr);
        ///发送普通(info级日志)
        template<class... T>
        void info(T... val) {
            this->log1(p(val...), 0);
        }
        ///发送警告(warning级日志)
        template<class... T>
        void warning(T... val) {
            this->log1(p(val...), 1);
        }
        ///发送错误(error级日志)
        template<class... T>
        void error(T... val) {
            this->log1(p(val...), 2);
        }
        /// @brief 设置loggerhandler的action
        /// @param action 执行的操作
        /// @see Logger::handler
        void registerHandle(Action action) {
            this->loggerhandler.action = std::move(action);
        }
        /// @brief 设置handler的启用状态
        /// @param state 状态，启用或者关闭
        /// @example 设置handler的启用状态(check in version 2.9.0)
        /// @code Logger::logger.setHandleState(ture); @endcode
        void setHandleState(bool state) {
            this->loggerhandler.enable = state;
        }
    };
    class Logger : public Logger_interface {
    private:
        Logger() = default;
    protected:
        /// @brief 日志底层实现封装
        /// @param content 日志内容
        /// @param level 日志等级
        /// @param env jnienv
        void log1(const std::string &content, int level, JNIEnv *env) override;
    public:
        static Logger logger;
    };
    /// 带id(一般为bot账号)的logger
    class IdLogger : public Logger_interface {
    public:
        QQID id;
    protected:
        void log1(const std::string &content, int level, JNIEnv *env) override;
    public:
        IdLogger(QQID id, Logger *l) : id(id) {
            this->loggerhandler = l->loggerhandler;
            this->log = l->getjmethod();
        }
    };
    /// 插件logger
    class PluginLogger : public Logger_interface {
    protected:
        void log1(const std::string &content, int level, JNIEnv *env) override;
    public:
        explicit PluginLogger(Logger *l) {
            this->loggerhandler = l->loggerhandler;
            this->log = l->getjmethod();
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOGGER_H
// #include "PluginConfig.h"
#ifndef MIRAICP_PRO_PLUGINCONFIG_H
#define MIRAICP_PRO_PLUGINCONFIG_H
#include <json.hpp>
namespace MiraiCP {
    class PluginConfig {
    public:
        /// @brief 插件id, 要与别人不一样否则报错无法加载(建议用类包格式，如: io.github.nambers)
        std::string id;
        /// @brief 插件名称
        std::string name;
        /// @brief 插件版本
        std::string version;
        /// @brief 插件作者(及联系方式)
        std::string author;
        /// @brief [optional]插件描述
        std::string description;
        /// @brief [optional]构建时间, 默认为__DATE__宏
        std::string time;
        PluginConfig(std::string id,
                     std::string name,
                     std::string version,
                     std::string author,
                     std::string description = "",
                     std::string time = __DATE__)
            : id(std::move(id)),
              name(std::move(name)),
              version(std::move(version)),
              author(std::move(author)),
              description(std::move(description)),
              time(std::move(time)) {}
        nlohmann::json serialize();
        std::string serialize2string() {
            return serialize().dump();
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_PLUGINCONFIG_H
namespace MiraiCP {
    /// 插件父类
    class CPPPlugin {
    public:
        /// @brief 插件信息
        PluginConfig config;
        /// @brief 插件级logger
        static PluginLogger *pluginLogger;
        static CPPPlugin *plugin;
        /// 插件启用时调用一次
        virtual void onEnable() {}
        virtual void onDisable() {}
        explicit CPPPlugin(PluginConfig c) : config(std::move(c)) {}
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CPPPLUGIN_H
#ifndef MIRAICP_PRO_COMMAND_H
#define MIRAICP_PRO_COMMAND_H
// #include "Config.h"
#ifndef MIRAICP_PRO_CONFIG_H
#define MIRAICP_PRO_CONFIG_H
#include <json.hpp>
#include <jni.h>
namespace MiraiCP {
    /// @brief 配置类声明, 主要存放各种jmethodid, MiraiCP内部使用, 不需要更改或其他操作
    /// @internal 一般为MiraiCP内部调用jni接口使用
    /// @class Config
    namespace Config {
        /// kt中JNI接口类
        extern jclass CPPLib;
        /// 调用mirai方法
        extern jmethodID KOperation;
        /// 本插件id
        extern int pluginId;
        /// 操作id
        enum operation_set {
            /// 撤回信息
            Recall,
            /// 发送信息
            Send,
            /// 查询信息接口
            RefreshInfo,
            /// 上传图片
            UploadImg,
            /// 取好友列表
            QueryBFL,
            /// 取群组列表
            QueryBGL,
            /// 上传文件
            SendFile,
            /// 查询文件信息
            RemoteFileInfo,
            /// 查询图片下载地址
            QueryImgInfo,
            /// 禁言
            MuteM,
            /// 查询权限
            QueryM,
            /// 踢出
            KickM,
            /// 取群主
            QueryOwner,
            /// 语音
            Voice,
            /// 查询群成员列表
            QueryML,
            /// 群设置
            GroupSetting,
            /// 构建转发信息
            Buildforward,
            /// 好友申请事件
            Nfroperation,
            /// 群聊邀请事件
            Gioperation,
            /// 回复(引用并发送)
            SendWithQuote,
            /// 群公告操作
            Announcement,
            /// 定时任务
            TimeOut,
            /// 发送戳一戳
            SendNudge,
            /// 下一条信息
            NextMsg,
            /// 更改权限
            ModifyAdmin,
            /// 群成员申请入群
            MemberJoinRequest,
            /// 图片是否已经上传
            ImageUploaded,
            /// 注册指令
            CommandReg,
            /// 改名称
            ChangeNameCard,
        };
        /**
         * @brief 调用mirai操作
         * @param type 操作id
         * @param data 传入数据
         * @return 返回数据
         */
        std::string koperation(operation_set type, const nlohmann::json &data, JNIEnv * = nullptr,
                               bool catchErr = true, const std::string &errorInfo = "");
        void construct(JNIEnv * = nullptr);
        void destruct();
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CONFIG_H
// #include "Exception.h"
#ifndef MIRAICP_PRO_EXCEPTION_H
#define MIRAICP_PRO_EXCEPTION_H
// #define MiraiCPThrow(x) throw x.append(__FILE__, __LINE__)
#define ErrorHandle(x, y) ErrorHandle0(__FILE__, __LINE__, (x), (y))
#define MIRAICP_EXCEPTION_WHERE __FILE__, __LINE__
#if defined(_MSC_VER)
#define ShouldNotUse(msg) _Pragma("warning(error:4996)") [[deprecated(msg)]] _Pragma("warning(warning:4996)")
#else
#if defined(__GNUC__)
#define ShouldNotUse(msg) [[deprecated(msg)]] __attribute__((error(msg)))
#else
#define ShouldNotUse(msg)
#endif
#endif
#include <exception>
#include <string>
namespace MiraiCP {
    /// @brief 总异常抽象类，用于一般捕获，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionBase
    class MiraiCPExceptionBase : public ::std::exception {
    protected:
        using string = std::string;
    protected:
        /// @brief 异常内容
        string re;
    public:
        /// @brief 发生异常的行号
        int lineNum = 0;
        /// @brief 发生异常的文件名
        string filename;
    protected:
        /// 受保护构造函数，供子类调用
        MiraiCPExceptionBase(string _filename, int _lineNum) : filename(std::move(_filename)), lineNum(_lineNum) {}
    public:
        ~MiraiCPExceptionBase() override = default;
    protected:
        /// @brief 异常事件广播
        void exception_broadcast();
    public:
        /// 异常信息
        const char *what() const noexcept override { return re.c_str(); }
        /// 实际抛出方法
        void raise() const;
    public: // 暴露的接口
        /// basicRaise 基本抛出方法，子类重写该方法
        virtual void basicRaise() const;
        // CRTP实现一次，调用静态的exceptionType
        /// 获取异常类型，通用接口
        virtual string getExceptionType() = 0;
        // 每个子类需要单独实现该静态方法
        /// 返回异常的类型，该静态方法无法正确实现多态，请使用 getExceptionType
        /// @see getExceptionType
        static string exceptionType() { return "MiraiCPException"; }
    };
    /// @brief 总异常CRTP抽象类，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionCRTP
    /// @note 请勿给该类增加新的属性。如果要增加属性应在 MiraiCPExceptionBase 中增加
    template<class T>
    class MiraiCPExceptionCRTP : public MiraiCPExceptionBase {
    protected:
        /// 委托构造函数
        MiraiCPExceptionCRTP(string _filename, int _lineNum) : MiraiCPExceptionBase(std::move(_filename), _lineNum) {
            exception_broadcast();
        }
    public:
        // 构造时传入类型字符串
        // 最好不要调用该构造函数
        explicit MiraiCPExceptionCRTP(const string &description, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            if (description.empty())
                this->re = T::exceptionType() + ":MiraiCP异常";
            else
                this->re = T::exceptionType() + ":" + description;
        }
    public:
        // CRTP类型获取实现
        string getExceptionType() override { return T::exceptionType(); }
    };
    /// @brief 通用MiraiCP异常
    /// @param const string &description, string _filename, int _lineNum
    /// @see MiraiCPExceptionBase
    typedef MiraiCPExceptionCRTP<MiraiCPExceptionBase> MiraiCPException;
    /// 文件读取异常.
    /// @see MiraiCPExceptionBase
    class UploadException : public MiraiCPExceptionCRTP<UploadException> {
    public:
        explicit UploadException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "上传(图片/文件)异常" + text;
        }
        static std::string exceptionType() { return "UploadException"; }
    };
    /// 通常为Mirai返回
    /// @see MiraiCPExceptionBase
    class IllegalStateException : public MiraiCPExceptionCRTP<IllegalStateException> {
    public:
        explicit IllegalStateException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "状态异常:" + text;
        }
        static std::string exceptionType() { return "IllegalStateException"; }
    };
    /// 内部异常, 通常为json读写问题
    /// @see MiraiCPExceptionBase
    class APIException : public MiraiCPExceptionCRTP<APIException> {
    public:
        explicit APIException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "MiraiCP内部无法预料的错误:" + text;
        }
        static string exceptionType() { return "APIException"; }
    };
    /// 机器人操作异常
    /// @see MiraiCPExceptionBase
    class BotException : public MiraiCPExceptionCRTP<BotException> {
    public:
        explicit BotException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            re = "没有权限执行该操作";
        }
        explicit BotException(string d, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            re = std::move(d);
        }
        static string exceptionType() { return "BotException"; }
    };
    /// 被禁言异常, 通常发生于发送信息
    class BotIsBeingMutedException : public MiraiCPExceptionCRTP<BotIsBeingMutedException> {
    public:
        /// 剩余禁言时间, 单位秒
        int timeRemain;
    public:
        explicit BotIsBeingMutedException(int t, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "发送信息失败, bot已被禁言, 剩余时间" + std::to_string(t);
            timeRemain = t;
        }
        static string exceptionType() { return "BotIsBeingMutedException"; }
    };
    /// 禁言异常
    /// @see MiraiCPExceptionBase
    class MuteException : public MiraiCPExceptionCRTP<MuteException> {
    public:
        /*
        *	 禁言时间超出0s~30d
        */
        MuteException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "禁言时长不在0s~30d中间";
        }
        static string exceptionType() { return "MuteException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class MemberException : public MiraiCPExceptionCRTP<MemberException> {
    public:
        enum MemberExceptionType : int {
            OtherType,
            NoSuchGroup,
            NoSuchMember
        };
        MemberExceptionType type = OtherType;
        /*
        *   "1" - 找不到群
        *	"2" - 找不到群成员
        */
        explicit MemberException(int _type, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            type = MemberExceptionType(_type);
            switch (type) {
                case NoSuchGroup:
                    this->re = "找不到群";
                    break;
                case NoSuchMember:
                    this->re = "找不到群成员";
                    break;
                default:
                    break;
            }
            this->re = "";
        }
        static string exceptionType() { return "MemberException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class FriendException : public MiraiCPExceptionCRTP<FriendException> {
    public:
        /*
        *   找不到好友
        */
        FriendException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "找不到好友";
        }
        static string exceptionType() { return "FriendException"; }
    };
    /// 获取群错误
    /// @see MiraiCPExceptionBase
    class GroupException : public MiraiCPExceptionCRTP<GroupException> {
    public:
        GroupException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "C++:找不到群";
        }
        static string exceptionType() { return "GroupException"; }
    };
    /// 撤回异常
    /// @see MiraiCPExceptionBase
    class RecallException : public MiraiCPExceptionCRTP<RecallException> {
    public:
        RecallException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "该消息已经被撤回";
        }
        static string exceptionType() { return "RecallException"; }
    };
    /// 远程资源出现问题
    /// @see MiraiCPExceptionBase
    class RemoteAssetException : public MiraiCPExceptionCRTP<RemoteAssetException> {
    public:
        explicit RemoteAssetException(string e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = std::move(e);
        }
        static string exceptionType() { return "RemoteAssetException"; }
    };
    /// 参数错误
    /// @see MiraiCPExceptionBase
    class IllegalArgumentException : public MiraiCPExceptionCRTP<IllegalArgumentException> {
    public:
        explicit IllegalArgumentException(string e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = std::move(e);
        }
        static string exceptionType() { return "IllegalArgumentException"; }
    };
    /// 超时
    /// @see MiraiCPExceptionBase
    class TimeOutException : public MiraiCPExceptionCRTP<TimeOutException> {
    public:
        explicit TimeOutException(std::string e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = std::move(e);
        }
        static string exceptionType() { return "TimeOutException"; }
    };
    /// 事件被取消, 一般出现在发送消息时在preSendMessageEvent取消的时候抛出
    /// @see MiraiCPExceptionBase
    class EventCancelledException : public MiraiCPExceptionCRTP<EventCancelledException> {
    public:
        explicit EventCancelledException(const string &msg, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            re = msg;
        }
        static string exceptionType() { return "EventCancelledException"; }
    };
    inline void ErrorHandle0(const std::string &name, int line, const std::string &re, const std::string &ErrorMsg = "") {
        if (re == "EF")
            throw FriendException(name, line);
        if (re == "EG")
            throw GroupException(name, line);
        if (re == "EM")
            throw MemberException(1, name, line);
        if (re == "EMM")
            throw MemberException(2, name, line);
        if (re == "EB")
            throw BotException("找不到bot:" + re, name, line);
        if (re == "EA")
            throw APIException(ErrorMsg, name, line);
        if (re == "EC")
            throw EventCancelledException("发送信息被取消", name, line);
        if (re == "ET")
            throw TimeOutException("发送信息超时", name, line);
        if (re == "EP")
            throw BotException(name, line);
        // equal to Tools::start_with
        if (re.rfind("EBM", 0) == 0)
            throw BotIsBeingMutedException(std::stoi(re.substr(3)), name, line);
    }
} // namespace MiraiCP
#endif //MIRAICP_PRO_EXCEPTION_H
// #include "Logger.h"
#include <optional>
namespace MiraiCP {
    class MessageChain;
    class Bot;
    class Contact;
    /*!
     * @brief 指令 Interface
     * @example 注册一条指令
     * @code
     * class a: public IRawCommand{
        public:
            IRawCommand::Config config() override{
                return IRawCommand::Config("test");
            }
            void onCommand(std::optional<Contact> c, const Bot& b, const MessageChain& a) override{
                Logger::logger.info(a.toMiraiCode());
            }
            a() = default;
        };
     * @endcode
     * 然后在`onEnable()`里
     * @code
     * CommandManager::commandManager.registerCommand(a());
     * @endcode
     * @attention loader端的命令只支持从console传入, plugin端是对接mirai的RawCommand
     */
    class IRawCommand {
        using string = std::string;
    public:
        struct Config {
        public:
            /// 指令名不能为空
            string primaryName;
            /// 可以为空
            std::vector<string> secondNames;
            /// 用法
            string usage;
            /// 描述
            string description;
            /// 覆盖已有命令
            bool override;
            /// 前缀`/`可省略
            bool preFixOption;
            explicit Config(string primaryName,
                            std::vector<string> secondNames = std::vector<std::string>(),
                            string usage = "null",
                            string description = "null",
                            bool override = false,
                            bool preFixOption = false)
                : primaryName(std::move(primaryName)),
                  secondNames(std::move(secondNames)),
                  usage(std::move(usage)),
                  description(std::move(description)),
                  override(override),
                  preFixOption(preFixOption) {}
        };
        virtual IRawCommand::Config config() = 0;
        virtual void onCommand(std::optional<Contact>, const Bot &, const MessageChain &) = 0;
        IRawCommand() = default;
        virtual ~IRawCommand() = default;
    };
    class CommandManager {
    private:
        CommandManager() = default;
        std::vector<std::shared_ptr<IRawCommand>> commandList;
    public:
        std::shared_ptr<IRawCommand> operator[](const int &index) { return commandList[index]; }
        /*!
         * @brief 注册一条指令
         * @param command 指令
         * @return 是否注册成功
         */
        template<class T>
        bool registerCommand(T command) {
            static_assert(std::is_base_of_v<IRawCommand, T>, "只支持IRawCommand的派生类");
            nlohmann::json j;
            j["pluginId"] = Config::pluginId;
            j["usage"] = command.config().usage;
            j["primaryName"] = command.config().primaryName;
            j["secondName"] = command.config().secondNames;
            j["description"] = command.config().description;
            j["override"] = command.config().override;
            j["preFixOption"] = command.config().preFixOption;
            size_t before = commandList.size();
            std::shared_ptr<IRawCommand> c;
            c.reset(new T(command));
            commandList.push_back(c);
            size_t now = commandList.size();
            if (now - before == 1)
                j["bindId"] = now - 1;
            else {
                auto i = std::find(commandList.begin(), commandList.end(), c);
                if (i != commandList.end())
                    j["bindId"] = i - commandList.begin();
                else
                    throw IllegalArgumentException("找不到合适的bindId", MIRAICP_EXCEPTION_WHERE);
            }
            nlohmann::json rej;
            rej["command"] = j.dump();
            std::string re = Config::koperation(Config::CommandReg, rej);
            return re == "true";
        }
        static CommandManager commandManager;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_COMMAND_H
#ifndef MIRAICP_PRO_CONFIG_H
#define MIRAICP_PRO_CONFIG_H
#include <json.hpp>
#include <jni.h>
namespace MiraiCP {
    /// @brief 配置类声明, 主要存放各种jmethodid, MiraiCP内部使用, 不需要更改或其他操作
    /// @internal 一般为MiraiCP内部调用jni接口使用
    /// @class Config
    namespace Config {
        /// kt中JNI接口类
        extern jclass CPPLib;
        /// 调用mirai方法
        extern jmethodID KOperation;
        /// 本插件id
        extern int pluginId;
        /// 操作id
        enum operation_set {
            /// 撤回信息
            Recall,
            /// 发送信息
            Send,
            /// 查询信息接口
            RefreshInfo,
            /// 上传图片
            UploadImg,
            /// 取好友列表
            QueryBFL,
            /// 取群组列表
            QueryBGL,
            /// 上传文件
            SendFile,
            /// 查询文件信息
            RemoteFileInfo,
            /// 查询图片下载地址
            QueryImgInfo,
            /// 禁言
            MuteM,
            /// 查询权限
            QueryM,
            /// 踢出
            KickM,
            /// 取群主
            QueryOwner,
            /// 语音
            Voice,
            /// 查询群成员列表
            QueryML,
            /// 群设置
            GroupSetting,
            /// 构建转发信息
            Buildforward,
            /// 好友申请事件
            Nfroperation,
            /// 群聊邀请事件
            Gioperation,
            /// 回复(引用并发送)
            SendWithQuote,
            /// 群公告操作
            Announcement,
            /// 定时任务
            TimeOut,
            /// 发送戳一戳
            SendNudge,
            /// 下一条信息
            NextMsg,
            /// 更改权限
            ModifyAdmin,
            /// 群成员申请入群
            MemberJoinRequest,
            /// 图片是否已经上传
            ImageUploaded,
            /// 注册指令
            CommandReg,
            /// 改名称
            ChangeNameCard,
        };
        /**
         * @brief 调用mirai操作
         * @param type 操作id
         * @param data 传入数据
         * @return 返回数据
         */
        std::string koperation(operation_set type, const nlohmann::json &data, JNIEnv * = nullptr,
                               bool catchErr = true, const std::string &errorInfo = "");
        void construct(JNIEnv * = nullptr);
        void destruct();
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CONFIG_H
#ifndef MIRAICP_PRO_CONTACT_H
#define MIRAICP_PRO_CONTACT_H
// #include "MessageChain.h"
#ifndef MIRAICP_PRO_MESSAGECHAIN_H
#define MIRAICP_PRO_MESSAGECHAIN_H
// #include "Exception.h"
// #include "SingleMessage.h"
#ifndef MIRAICP_PRO_SINGLEMESSAGE_H
#define MIRAICP_PRO_SINGLEMESSAGE_H
#include <array>
#include <json.hpp>
#include <optional>
#include <sstream>
// #include "MessageSource.h"
#ifndef MIRAICP_PRO_MESSAGESOURCE_H
#define MIRAICP_PRO_MESSAGESOURCE_H
#include <string>
#include <jni.h>
namespace MiraiCP {
    class MiraiCodeable; // forward declaration
    using QQID = unsigned long long;
    /*! 消息源声明
     * @example 撤回信息(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
        e.message.source.value().recall();
        e.group.sendMessage("hi").recall();
        });
     * @endcode
    */
    class MessageSource {
    public:
        /// 消息的ids
        std::string ids;
        /// 消息的internalids
        std::string internalids;
        /// 消息源序列化
        std::string source;
        MessageSource() = default;
        /// @deprecated 用Contact.quoteAndSendMessage, since v2.8.1
        [[deprecated("Use Contact.quoteAndSendMessage")]] MessageSource
        quoteAndSendMiraiCode(MiraiCodeable *msg, QQID groupid = 0,
                              JNIEnv *env = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        [[deprecated("Use Contact.quoteAndSendMessage")]] MessageSource
        quoteAndSendMsg(const std::string &c, QQID groupid = 0,
                        JNIEnv * = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        [[deprecated("Use Contact.quoteAndSendMessage")]] MessageSource
        quoteAndSendMiraiCode(const std::string &c, QQID groupid = 0,
                              JNIEnv * = nullptr) const = delete;
        /*!
         * @brief 构建消息源
         * @param ids
         * @param internalids
         * @param source
         */
        MessageSource(std::string ids, std::string internalids, std::string source);
        /*!
         * @brief 从json字符串反序列化到MessageSource对象
         * @note json应该为以下格式
         * @code
         * {"ids":"", "internalids":""}
         * @endcode
         */
        static MessageSource deserializeFromString(const std::string &source);
        std::string serializeToString() const;
        /// @brief 撤回该信息
        void recall(JNIEnv * = nullptr) const;
        bool operator==(const MessageSource &ms) const {
            return this->ids == ms.ids && this->internalids == ms.internalids;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGESOURCE_H
// #include "MiraiCode.h"
namespace MiraiCP {
    /// 用serviceMessage的分享信息
    struct URLSharer {
        /// 简介 没点进来看见的样子
        std::string brief = "简介 没点进来看见的样子";
        /// 目标url
        std::string url = "目标url";
        /// 图标地址
        std::string cover = "图标地址";
        /// 标题
        std::string title = "标题";
        /// 描述文字
        std::string summary = "描述文字";
    };
    /// MessageChain的组成部分
    class SingleMessage : public MiraiCodeable {
    public:
        virtual ~SingleMessage() = default;
        static std::unordered_map<int, std::string> messageType;
        virtual nlohmann::json toJson() const {
            nlohmann::json re;
            re["key"] = "miraicode";
            re["content"] = this->toMiraiCode();
            return re;
        }
        /// @brief 找对应类型的index key
        /// @param value 类型名
        /// @return 如果没找到返回-1
        static int getKey(const std::string &value);
        /// MiraiCode类别
        /// @see SingleMessage::messageType
        int type;
        std::string content;
        std::string prefix;
        std::string toMiraiCode() const override;
        bool operator==(const SingleMessage &m) const {
            return this->type == m.type && this->toMiraiCode() == m.toMiraiCode();
        }
        bool operator==(SingleMessage *m) const {
            return this->type == m->type && this->toMiraiCode() == m->toMiraiCode();
        }
        /// @brief 构建单条
        /// @param type 消息类型 @see messageType
        /// @param content 内容
        /// @param prefix 前缀, 默认为`:`, 第二个冒号部分的内容, 目前在serviceMesage有使用
        SingleMessage(int type, std::string content, std::string prefix = ":") : type(type),
                                                                                 content(std::move(content)),
                                                                                 prefix(std::move(prefix)) {}
    };
    /// 纯文本信息
    class PlainText : public SingleMessage {
    public:
        static int type() { return 0; }
        std::string toMiraiCode() const override {
            return content;
        }
        nlohmann::json toJson() const override;
        explicit PlainText(const SingleMessage &sg);
        template<typename T>
        explicit PlainText(const T &a) : SingleMessage(PlainText::type(), ([&a]() -> std::string {
                                                           std::stringstream sst;
                                                           sst << a;
                                                           return sst.str();
                                                       })()) {}
        bool operator==(const PlainText &p) const {
            return this->content == p.content;
        }
    };
    /// @
    class At : public SingleMessage {
    public:
        static int type() { return 1; }
        QQID target;
        nlohmann::json toJson() const override;
        explicit At(const SingleMessage &sg);
        explicit At(QQID a) : SingleMessage(At::type(), std::to_string(a)), target(a){};
        std::string toMiraiCode() const override {
            return "[mirai:at:" + std::to_string(this->target) + "] "; // 后面有个空格
        }
        bool operator==(const At &a) const {
            return this->target == a.target;
        }
    };
    /// @brief \@全体
    class AtAll : public SingleMessage {
    public:
        static int type() { return 2; }
        std::string toMiraiCode() const override {
            return "[mirai:atall] ";
        }
        nlohmann::json toJson() const override;
        AtAll() : SingleMessage(AtAll::type(), "", "") {}
    };
    /// 图像类声明
    class Image : public SingleMessage {
    public:
        static int type() { return 3; }
        //图片id，样式:` {xxx}.xx `
        std::string id;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> md5;
        /// 可为0, 来源:用`refreshInfo`可能可以获取或者自己填充, 是isUploaded的必须条件, 默认0
        size_t size;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> url;
        /// 宽度, 默认0, 单位px
        int width;
        /// 长度, 默认0, 单位px
        int height;
        /*!
         * @brief 图片类型
         *  - 0 png
         *  - 1 bmp
         *  - 2 jpg
         *  - 3 gif
         *  - 4 apng
         *  - 5 unknown
         *  默认 5
         */
        int imageType;
        /*!
         * @brief 图片是否已经上传(如果已经上传即表明可以直接用ImageId发送, 如果没有需要手动上传)
         * @param md5 在kotlin端会用.toByteArray()转换
         * @param size 图片大小, 不能为0
         * @param botid 所属Botid
         * @return 是否已上传
         */
        bool isUploaded(QQID botid, JNIEnv *env = nullptr);
        /*!
        * @brief 从图片builder构造，适用于服务器上已经有的图片，即接收到的
        * @param imageId 图片id, 必须
        * @param size isUploaded的必要条件, 单纯用ImageId可能取不到图片size, 需要自己上传
        * @param width 宽度
        * @param height 长度
        * @param type 图片类型
        * @detail 图片miraiCode格式例子, `[mirai:image:{图片id}.jpg]`
        * 可以用这个正则表达式找出id `\\[mirai:image:(.*?)\\]`
        */
        explicit Image(const std::string &imageId, size_t size = 0, int width = 0, int height = 0, int type = 5) : SingleMessage(Image::type(), imageId) {
            this->id = imageId;
            this->size = size;
            this->width = width;
            this->height = height;
            this->imageType = type;
        }
        explicit Image(const SingleMessage &sg);
        /// 刷新信息(获取图片下载Url,md5, size)
        void refreshInfo(JNIEnv *env = nullptr);
        /// 取图片Mirai码
        std::string toMiraiCode() const override {
            return "[mirai:image:" + this->id + "]";
        }
        nlohmann::json toJson() const override;
        static Image deserialize(const std::string &);
        bool operator==(const Image &i) const {
            return this->id == i.id;
        }
    };
    /// 闪照, 和Image属性类似
    class FlashImage : public Image {
    public:
        static int type() { return 8; }
        std::string toMiraiCode() const override {
            return "[mirai:flash:" + this->id + "]";
        }
        explicit FlashImage(const std::string &imageId, size_t size = 0, int width = 0, int height = 0, int type = 0) : Image(imageId, size, width, height, type) {
            this->SingleMessage::type = 8;
        }
        explicit FlashImage(const SingleMessage &sg) : Image(sg) {}
        explicit FlashImage(const Image &img) : Image(img) {}
        nlohmann::json toJson() const override;
        static FlashImage deserialize(const std::string &);
        bool operator==(const FlashImage &i) const {
            return this->id == i.id;
        }
        /// 转换到普通图片
        Image toImage() { return Image(id, size, width, height, imageType); }
    };
    /*!
    * @brief 小程序卡片
    * @see LightAppStyle1, LightAppStyle2, LightAppStyle3
    * @attention 自带的模板不稳定，可能发出现没有效果
    * @example 通过常量构建并发送小程序卡片
    * @code
 * Event::processor.registerEvent([](GroupMessageEvent e) {
		//修改里面的属性从而自定义
		LightAppStyle1 a = LightAppStyle1();
		LightAppStyle2 b = LightAppStyle2();
		LightAppStyle3 c = LightAppStyle3();
		e.group.SendMiraiCode(LightApp(a).toMiraiCode());
		e.group.SendMiraiCode(LightApp(b).toMiraiCode());
		e.group.SendMiraiCode(LightApp(c).toMiraiCode());
	});
    * @endcode
    * @example 通过文本构建并发送小程序卡片
    * @code
 * Event::processor.registerEvent([](GroupMessageEvent e) {
		//风格1，适合文字展示，不能交互,无大图
		//图标地址，应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string icon = "http://gchat.qpic.cn/gchatpic_new/1924306130/1044565129-2580521429-8ECE44863FC01DBD17FB8A177B355356/0";
		//小标题
		string titles = "{\"title\":\"hi\", \"value\":\"test3\"}";
		//下面的按钮，但是不能按
		string buttons = "{\"name\":\"Test4\",\"action\":\"plugin\",\"actionData\":\"https://baidu.com\"}";
		string x = "{\"app\":\"com.tencent.miniapp\",\"desc\":\"\",\"view\":\"notification\",\"ver\":\"0.0.0.1\",\"prompt\":\"[应用]\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"notification\":{\"appInfo\":"
			"{\"appName\":\"Test1\",\"appType\":4,\"appid\":1109659848,"
			"\"iconUrl\":\""+icon+"\"},"
			"\"data\":["+titles+"],"
			"\"title\":\"Test2\",\"button\":"
			"["+buttons+"],"
			"\"emphasis_keyword\":\"\"}},\"text\":\"\",\"sourceAd\":\"\"}";
		e.group.SendMiraiCode(LightApp(x).toString());
		//风格2，不能交互，有预览图
		//icon图标,应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string icon1 = "http://gchat.qpic.cn/gchatpic_new/1924306130/1044565129-2580521429-8ECE44863FC01DBD17FB8A177B355356/0";
		//预览图(大图),应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string preview1 = icon1;
		string a = "{\"config\":"
			"{\"height\":0,\"forward\":1,\"ctime\":0,\"width\":0,\"type\":\"normal\",\"token\":\"\",\"autoSize\":0},"
			"\"prompt\":\"[QQ小程序]\",\"app\":\"com.tencent.miniapp_01\",\"ver\":\"1.0.0.103\",\"view\":\"view_8C8E89B49BE609866298ADDFF2DBABA4\","
			"\"meta\":{\"detail_1\":{\"appid\":\"1110081493\",\"preview\":\""+preview1+"\",\"shareTemplateData\":{},"
			"\"gamePointsUrl\":\"\",\"gamePoints\":\"\",\"url\":\"m.q.qq.com\",\"scene\":0,\"desc\":\"Test5\",\"title\":\"Test6\","
			"\"host\":{\"uin\":1000000,\"nick\":\"应用消息\"},"
			"\"shareTemplateId\":\"8C8E89B49BE609866298ADDFF2DBABA4\",\"icon\":\""+icon1+"\",\"showLittleTail\":\"\"}},\"desc\":\"\"}";
		e.group.SendMiraiCode(LightApp(a).toString());
		//风格3，可以跳转到网址，有预览图
		//跳转链接
		string url = "https://www.baidu.com";
		//icon图标,应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string icon2 = "http://gchat.qpic.cn/gchatpic_new/1924306130/1044565129-2580521429-8ECE44863FC01DBD17FB8A177B355356/0";
		//预览图(大图),应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string preview = icon2;
		string b = "{\"config\":{\"height\":0,\"forward\":1,\"ctime\":0,\"width\":0,\"type\":\"normal\",\"token\":\"\",\"autoSize\":0},"
			"\"prompt\":\"[QQ小程序]\",\"app\":\"com.tencent.miniapp_01\",\"ver\":\"0.0.0.1\",\"view\":\"view_8C8E89B49BE609866298ADDFF2DBABA4\","
			"\"meta\":{\"detail_1\":{\"appid\":\"1109937557\",\"preview\":\""+preview+"\",\"shareTemplateData\":{},\"gamePointsUrl\":\"\",\"gamePoints\":\"\",\"url\":\"m.q.qq.com\",\"scene\":0,\"desc\":\"Test1\",\"title\":\"Test3\",\"host\":{\"uin\":0,\"nick\":\"\"},\"shareTemplateId\":\"8C8E89B49BE609866298ADDFF2DBABA4\",\"icon\":\""+icon+"\",\"qqdocurl\":\""+url+"\",\"showLittleTail\":\"\"}},\"desc\":\"\"}";
		e.group.SendMiraiCode(LightApp(b).toString());
		});
    * @endcode
    */
    class LightApp : public SingleMessage {
    public:
        static int type() { return 4; }
        /// @brief 使用纯文本构造，推荐使用其他结构体方法构造
        /// @param content 构造文本
        explicit LightApp(std::string content) : SingleMessage(LightApp::type(), std::move(content)) {}
        explicit LightApp(const SingleMessage &sg);
        nlohmann::json toJson() const override;
        /// 返回miraicode
        std::string toMiraiCode() const override;
        bool operator==(const LightApp &la) const {
            return this->content == la.content;
        }
    };
    /// xml格式的超文本信息
    /// @attention 自带的模板不稳定，可能发出现没有效果
    class ServiceMessage : public SingleMessage {
    public:
        static int type() { return 5; }
        nlohmann::json toJson() const override;
        std::string toMiraiCode() const override;
        int id;
        /// @brief ServiceMessage
        /// @param id 在xml内容前面的id (不包括逗号)
        /// @param a xml内容 (不需要事先转码到miraiCode)
        explicit ServiceMessage(int id, std::string a) : SingleMessage(ServiceMessage::type(), std::move(a),
                                                                       ":" + std::to_string(id) + ','),
                                                         id(id) {}
        explicit ServiceMessage(const SingleMessage &sg);
        explicit ServiceMessage(const URLSharer &a) : SingleMessage(5,
                                                                    "<?xml version=\"1.0\" encoding=\"utf-8\"?><msg templateID=\"12345\" action=\"web\" brief=\"" +
                                                                            a.brief + "\" serviceID=\"1\" url=\"" + a.url +
                                                                            "\"><item layout=\"2\"><picture cover=\"" +
                                                                            a.cover + "\"/><title>" + a.title +
                                                                            "</title><summary>" + a.summary +
                                                                            "</summary></item><source/></msg>",
                                                                    ":1,"),
                                                      id(1) {}
        bool operator==(const ServiceMessage &s) const {
            return this->content == s.content;
        }
    };
    /// 引用信息
    class QuoteReply : public SingleMessage {
    public:
        static int type() { return -2; }
        // 不可直接发送, 发送引用信息用MessageChain.quoteAndSendMessage
        ShouldNotUse("don't have MiraiCode, use MessageChain.quote instead") std::string toMiraiCode() const override {
            return "";
        }
        /// 引用信息的MessageSource
        MessageSource source;
        explicit QuoteReply(const SingleMessage &m);
        explicit QuoteReply(MessageSource source) : SingleMessage(QuoteReply::type(), source.serializeToString()), source(std::move(source)){};
        bool operator==(const QuoteReply &qr) const {
            return this->source == qr.source;
        }
    };
    /// 接收到的音频文件, 发送用`Contact.sendAudio`
    class OnlineAudio : public SingleMessage {
    public:
        static int type() { return -3; }
        /// 文件名
        std::string filename;
        /// 下载地址
        std::string url;
        /// 文件大小
        int size;
        /// 编码方式
        int codec;
        /// 时长(单位s)
        int length;
        /// 16位md5
        std::array<uint8_t, 16> md5;
        /// 不支持直接发送, 用Contact.sendAudio
        [[deprecated("cannot use, use Contact.sendAudio")]] std::string toMiraiCode() const override {
            return "";
        }
        explicit OnlineAudio(std::string f, std::array<uint8_t, 16> md5, int size, int codec, int length,
                             std::string url) : SingleMessage(OnlineAudio::type(), ""),
                                                filename(std::move(f)), md5(md5), size(size), codec(codec),
                                                length(length), url(std::move(url)){};
        bool operator==(const OnlineAudio &oa) const {
            return this->md5 == oa.md5;
        }
    };
    /// @brief 远程(群)文件类型
    class RemoteFile : public SingleMessage {
    public:
        static int type() { return 6; }
        /// @brief 下载信息
        /// @see RemoteFile
        struct Dinfo {
            /// 下载地址, 可能会是 `null` 当文件不存在
            std::string url;
            /// md5 可用于校验
            std::string md5;
            /// sha1 可用于校验
            std::string sha1;
        };
        /// @brief 文件信息
        /// @see RemoteFile
        struct Finfo {
            /// 文件大小
            QQID size;
            /// 上传者id
            QQID uploaderid;
            /// 过期时间
            long expirytime;
            /// 上传时间, 时间戳格式
            QQID uploadtime;
            /// 上次更改时间, 时间戳格式
            QQID lastmodifytime;
        };
        /// 文件唯一id, 用于识别
        std::string id;
        /// 文件内部id, 用于构造miraiCode发送
        unsigned int internalid;
        /// 文件名
        std::string name;
        /// 文件大小
        long long size;
        /// 文件在群文件的路径
        /// @attention 可能为空(通常出现于MessageChain从MiraiCode反序列化), 需要从Group重新获取文件
        /// @see Group::getFileByFile
        std::optional<std::string> path;
        /// 文件下载信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Dinfo, Group::getFileByFile
        std::optional<Dinfo> dinfo;
        /// 文件信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Finfo, Group::getFileByFile
        std::optional<Finfo> finfo;
        std::string serializeToString();
        RemoteFile plus(unsigned int ii);
        static RemoteFile deserializeFromString(const std::string &source);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalids
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p, struct Dinfo d, struct Finfo f);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalids
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s);
        /// 上传后会自动发送
        [[deprecated("Cannot send manually, use Group.sendFile")]] std::string toMiraiCode() const override {
            return "";
        }
        bool operator==(const RemoteFile &rf) const {
            return this->id == rf.id;
        }
    };
    /// 自带表情
    /// @attention 有些表情会变成PlainText类型和\\xxx 的格式
    class Face : public SingleMessage {
    public:
        static int type() { return 7; }
        int id;
        nlohmann::json toJson() const override;
        std::string toMiraiCode() const override {
            return "[mirai:face:" + std::to_string(id) + "]";
        }
        explicit Face(int id) : SingleMessage(Face::type(), std::to_string(id)), id(id) {}
        bool operator==(const Face &f) const {
            return this->id == f.id;
        }
    };
    /// 一些可以被mirai识别的音乐卡片, 如果不能被mirai识别, 那应该被表现成lightApp类型(可能收费/vip歌曲用lightApp, 免费用MusicShare)
    class MusicShare : public SingleMessage {
    public:
        static int type() { return 9; }
        /// 应用名称, 如NeteaseCloudMusic
        std::string appName;
        /// 歌名
        std::string title;
        /// 卡片第二行的文字内容
        std::string summary;
        /// 点击跳转到的链接
        std::string jumpUrl;
        /// 图片链接
        std::string picUrl;
        /// 音乐文件链接
        std::string musicUrl;
        /// 简介, 点进聊天节目前显示的小文字, 一般是`分享`
        std::string brief;
        std::string toMiraiCode() const override {
            return "[mirai:musicshare:" + appName + "," + title + "," + summary + "," + jumpUrl + "," + picUrl + "," + musicUrl + "," + brief + "]";
        }
        MusicShare(const std::string &appName, const std::string &title, const std::string &summary, const std::string &jumpUrl, const std::string &picUrl, const std::string &musicUrl, const std::string &brief) : SingleMessage(MusicShare::type(), ""), appName(appName), title(title), summary(summary), jumpUrl(jumpUrl), picUrl(picUrl), musicUrl(musicUrl), brief(brief) {}
    };
    class MarketFace : public SingleMessage {
    public:
        static int type() { return -5; }
        /// 目前无法直接发送MarketFace, 可以转发
        [[deprecated("暂不支持直接发送")]] std::string toMiraiCode() const override {
            return "";
        }
        std::array<uint8_t, 16> faceId;
        explicit MarketFace(std::array<uint8_t, 16> id) : SingleMessage(MarketFace::type(), ""), faceId(id) {}
        bool operator==(const MarketFace &mf) const {
            return this->faceId == mf.faceId;
        }
    };
    /// @brief 目前不支持的消息类型, 不支持发送
    class UnSupportMessage : public SingleMessage {
    public:
        static int type() { return -1; }
        nlohmann::json toJson() const override;
        /// 不支持发送
        [[deprecated("不支持直接发送UnSupportMessage")]] std::string toMiraiCode() const override {
            return "";
        }
        explicit UnSupportMessage(const SingleMessage &s) : SingleMessage(s){};
        explicit UnSupportMessage(const std::string &content) : SingleMessage(UnSupportMessage::type(), content) {}
        bool operator==(const UnSupportMessage &m) const {
            return this->content == m.content;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_SINGLEMESSAGE_H
namespace MiraiCP {
    class MessageSource; // forward declaration
    /// 消息链, 一般由SingleMessage组成
    class MessageChain : public MiraiCodeable {
    public:
        class Message {
        private:
            std::shared_ptr<SingleMessage> content;
        public:
            /// 代表的子类
            /// @see MessageChain::messageType
            int type() const {
                return this->content->type;
            };
            template<class T>
            explicit Message(T a) {
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
                T *b = new T(a);
                content.reset(b);
            }
            explicit Message(std::shared_ptr<SingleMessage> a) {
                content = std::move(a);
            }
            /// 取指定类型
            /// @throw IllegalArgumentException
            template<class T>
            T get() const {
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
                if (T::type() != this->type())
                    throw IllegalArgumentException("cannot convert from " + SingleMessage::messageType[this->type()] + " to " + SingleMessage::messageType[T::type()], MIRAICP_EXCEPTION_WHERE);
                T *re = static_cast<T *>(this->content.get());
                if (re == nullptr)
                    throw IllegalArgumentException("cannot convert from " + SingleMessage::messageType[this->type()] + " to " + SingleMessage::messageType[T::type()], MIRAICP_EXCEPTION_WHERE);
                return *re;
            }
            bool operator==(const Message &m) const {
                return this->content->type == m.content->type && this->content->toMiraiCode() == m.toMiraiCode();
            }
            bool operator!=(const Message &m) const {
                return this->content->type != m.content->type || this->content->toMiraiCode() != m.toMiraiCode();
            }
            std::string toMiraiCode() const {
                return this->content->toMiraiCode();
            }
        };
    private:
        void p(std::vector<Message> *) {}
        template<class T1, class... T2>
        void p(std::vector<Message> *v, T1 h, T2... args) {
            static_assert(std::is_base_of_v<SingleMessage, T1>, "只支持SingleMessage子类");
            v->push_back(Message(h));
            p(v, args...);
        }
        template<class... T2>
        void p(std::vector<Message> *v, std::string h, T2... args) {
            v->push_back(Message(PlainText(h)));
            p(v, args...);
        }
        template<class... T2>
        void p(std::vector<Message> *v, const char *h, T2... args) {
            v->push_back(Message(PlainText(h)));
            p(v, args...);
        }
        template<class... T>
        void p(std::vector<Message> *v, MessageChain mc, T... args) {
            v->insert(v->end(), mc.content.begin(), mc.content.end());
            p(v, args...);
        }
        std::vector<Message> content;
        MessageSource quoteAndSend0(const std::string &msg, QQID groupid = -1,
                                    JNIEnv *env = nullptr);
        template<class T>
        MessageSource quoteAndSend1(T s, QQID groupid = -1, JNIEnv *env = nullptr) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
            return this->quoteAndSend0(s.toMiraiCode(), groupid, env);
        }
        MessageSource quoteAndSend1(std::string s, QQID groupid, JNIEnv *env) {
            return this->quoteAndSend0(s, groupid, env);
        }
        MessageSource quoteAndSend1(MessageChain mc, QQID groupid, JNIEnv *env) {
            return this->quoteAndSend0(mc.toMiraiCode(), groupid, env);
        }
    public:
        size_t size() {
            return this->content.size();
        }
        const std::vector<Message> &vector() {
            return this->content;
        }
        /// 如果由MiraiCP构造(incoming)就会存在，否则则不存在
        std::optional<MessageSource> source = std::nullopt;
        /// @brief 找到miraiCode结尾的`]`
        /// @param s 文本
        /// @param start 开始位置
        /// @return 如果不存在返回-1, 存在则返回index
        static size_t findEnd(const std::string &s, size_t start) {
            size_t pos = start;
            while (pos < s.length()) {
                switch (s[pos]) {
                    case '\\':
                        pos += 2;
                        continue;
                    case ']':
                        return pos;
                }
                pos++;
            }
            return -1;
        }
        std::string toMiraiCode() const override;
        std::vector<std::string> toMiraiCodeVector() const {
            std::vector<std::string> tmp;
            for (const Message &a: this->content)
                tmp.emplace_back(a.toMiraiCode());
            return tmp;
        }
        /// @brief 添加元素
        /// @tparam T 任意的SingleMessage的子类
        /// @param a 添加的值
        template<class T>
        void add(const T &a) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只接受SingleMessage的子类");
            this->content.push_back(Message(a));
        }
        void add(const MessageSource &val) {
            this->source = val;
        }
        /// 筛选出某种特点type的信息
        template<class T>
        std::vector<T> filter(int type) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto a: this->content) {
                if (a.type() == type)
                    re.push_back(std::static_pointer_cast<T>(a));
            }
            return re;
        }
        /// 自定义筛选器
        template<class T>
        std::vector<T> filter(const std::function<bool(Message)> &func) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto a: this->content) {
                if (func(a))
                    re.push_back(std::static_pointer_cast<T>(a));
            }
            return re;
        }
        /// 找出第一个指定的type的信息
        template<class T>
        T first(int type) {
            for (auto a: this->content)
                if (a.type() == type)
                    return std::static_pointer_cast<T>(a);
        }
        /// incoming构造器
        template<class... T>
        explicit MessageChain(MessageSource ms, T... args) : source(std::move(ms)) {
            this->p(&this->content, args...);
        };
        /*!
         * @brief 从多个参数构建MessageChain
         * @tparam T 多个传入参数的类型
         * 支持以下类型:
         * - std::string / const char* 相当于传入PlainText
         * - SingleMessage的派生类
         * @param args 参数本身
         */
        template<class... T>
        explicit MessageChain(T... args) {
            p(&this->content, args...);
        };
        /// outcoming 构造器
        template<class T>
        explicit MessageChain(const T &msg) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage子类");
            this->content.push_back(Message(msg));
        };
        template<class T>
        [[nodiscard]] MessageChain plus(const T &a) const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            MessageChain tmp(*this);
            tmp.content.push_back(std::make_shared<SingleMessage>(a));
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageChain &mc) const {
            MessageChain tmp(*this);
            tmp.content.insert(tmp.content.end(), mc.content.begin(), mc.content.end());
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageSource &ms) const {
            MessageChain tmp(*this);
            tmp.source = ms;
            return tmp;
        }
        template<class T>
        MessageChain operator+(const T &msg) const {
            return this->plus(msg);
        }
        Message operator[](size_t i) const {
            return this->content[i];
        }
        bool operator==(const MessageChain &mc) const {
            if (this->content.size() != mc.content.size())
                return false;
            for (size_t i = 0; i < this->content.size(); i++) {
                if (this->content[i] != mc[i])
                    return false;
            }
            return true;
        }
        bool operator!=(const MessageChain &mc) const {
            return !(*this == mc);
        }
        bool empty() const {
            if (this->content.empty() || toMiraiCode().empty())
                return true;
            return false;
        }
        /// @brief 回复并发送
        /// @param s 内容
        /// @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
        /// @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
        /// @detail 支持以下类型传入
        /// - std::string / const char* 相当于传入PlainText(str)
        /// - SingleMessage的各种派生类
        /// - MessageChain
        /// @deprecated use Contact.quoteAndSend or `this->quoteAndSend1(s, groupid, env)`, since v2.8.1
        template<class T>
        [[deprecated("use Contact.quoteAndSend")]] MessageSource
        quoteAndSendMessage(T s, QQID groupid = -1, JNIEnv *env = nullptr) = delete;
        /// 从miraicode string构建MessageChain
        static MessageChain deserializationFromMiraiCode(const std::string &m);
        static MessageChain deserializationFromMessageSourceJson(const std::string &msg, bool origin = true) {
            return deserializationFromMessageSourceJson(nlohmann::json::parse(msg), origin);
        }
        /// 从MessageSource json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageSourceJson(const nlohmann::json &j, bool origin = true);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGECHAIN_H
#include <json.hpp>
#include <string>
namespace MiraiCP {
    using QQID = unsigned long long;
    /*!
    * @brief group, friend, member的父类
     * @example 发送信息
     * 以群聊信息为例(check in version 2.9.0)
     * @code
     * // update version 2.9.0
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e){
     * // 发送MessageChain
     * e.group.sendMessage(e.message);
     * // 发送SingleMessage
     * e.group.sendMessage(PlainText("a"));
     * e.group.sendMessage(e.sender.at(), PlainText(""), Face(5));
     * });
     * @endcode
     * @example 回复信息
     * 以群聊信息为例
     * 和发送信息很像, 除了要多传入一个MessageSource(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e){
     * e.group.quoteAndSendMessage(e.message.source.value(), PlainText("a"));
     * });
     * @endcode
    */
    class Contact {
    protected: // attrs
        int _type = 0;
        QQID _id;
        QQID _groupid;
        std::string _nickOrNameCard;
        std::string _avatarUrl;
        QQID _botid;
        bool _anonymous = false;
    protected:
        /// 发送语音
        MessageSource sendVoice0(const std::string &path, JNIEnv * = nullptr);
    public:
        // constructors
        /*!
         * @brief 无参初始化Contact类型
         * @internal 一般在MiraiCp内部构造
         */
        Contact() {
            this->_type = 0;
            this->_id = 0;
            this->_groupid = 0;
            this->_nickOrNameCard = "";
            this->_botid = 0;
        }
        /*!
         * @brief 构造contact类型
         * @param type 类型
         *  @see Contact::type()
         * @param id ID
         *  @see Contact::id()
         * @param gid 是member的时候是群id，否则为0
         *  @see Contact::groupid
         * @param name 群名片或昵称或群名
         *  @see Contact::name()
         * @param botid 对应的botid
         */
        explicit Contact(int type, QQID id, QQID gid, const std::string &name, QQID botid, bool anonymous = false) {
            this->_type = type;
            this->_id = id;
            this->_groupid = gid;
            this->_nickOrNameCard = name;
            this->_botid = botid;
            this->_anonymous = anonymous;
        };
        //        Contact(Contact &&c) : _type(c._type), _id(c._id), _groupid(c._groupid), _botid(c._botid), _anonymous(c._anonymous), _nickOrNameCard(std::move(c._nickOrNameCard)), _avatarUrl(std::move(c._avatarUrl)) {
        //        }
        // destructor
        virtual ~Contact() = default;
        bool operator==(const Contact &c) const {
            return this->id() == c.id();
        }
        /// @brief 当前对象类型
        ///     - 1 Friend 好友
        ///     - 2 Group 群聊
        ///     - 3 Member 群成员
        int type() const { return this->_type; }
        /// @brief id在全部情况存在
        ///     - 当当前type为1(Friend)时，为好友id
        ///     - 当当前type为2(Group)时，为群id
        ///     - 当当前type为3(Member)时，为群成员id
        QQID id() const { return this->_id; }
        /// @brief 当type为3的时候存在，否则为0，可以看作补充id
        ///     - 当当前type为1(Friend)时，为0
        ///     - 当当前type为2(Group)时，为0
        ///     - 当当前type为3(Member)时，为群号
        /// @attention 当当前type为2(Group)时，为0，不为群号，id才是群号
        QQID groupid() const { return this->_groupid; }
        /// 群名称，群成员群名片，或好友昵称
        std::string nickOrNameCard() const { return this->_nickOrNameCard; };
        /// 头像url地址
        std::string avatarUrl() const { return this->_avatarUrl; };
        /// 所属bot
        QQID botid() const { return this->_botid; };
    public: // serialization
        /// 序列化到json对象
        nlohmann::json toJson() const {
            nlohmann::json j;
            j["type"] = type();
            j["id"] = id();
            j["groupid"] = groupid();
            j["nickornamecard"] = nickOrNameCard();
            j["botid"] = botid();
            return j;
        }
        /// @deprecated since v2.8.1, use `this->toJson()`
        [[deprecated("use toJson")]] nlohmann::json serialization() const = delete;
        /// 序列化成文本，可以通过deserializationFromString反序列化，利于保存
        /// @see Contact::fromString()
        std::string toString() const {
            return this->toJson().dump();
        }
        /// @deprecated since v2.8.1, use `this->toString()`
        [[deprecated("use toString")]] std::string serializationToString() const = delete;
        /// 反序列化成bot，可以通过serializationToString序列化，利于保存
        /// @see Contact::serializationToString()
        /// @param source 序列化后的文本
        /// @throw APIException
        static Contact deserialize(const std::string &source);
        static Contact deserialize(nlohmann::json source);
    public:
        /// @deprecated since v2.8.1, use `Contact::deserialize(source)`
        [[deprecated("use deserialize")]] static Contact deserializationFromString(const std::string &source) = delete;
        /// @deprecated since v2.8.1, use `sendMessage(MiraiCode)` or `sendMsg0(msg.toMiraiCode(), retryTime, true, env)`
        [[deprecated("Use sendMessage")]] MessageSource sendMiraiCode(const MiraiCode &msg, int retryTime = 3,
                                                                      JNIEnv *env = nullptr) const = delete;
        /*!
         * @brief 回复并发送
         * @param s 内容
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         * @param ms 回复的信息的MessageSource
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         */
        template<class T>
        MessageSource quoteAndSendMessage(T s, MessageSource ms, JNIEnv *env = nullptr) {
            return this->quoteAndSend1(s, ms, env);
        }
        /*!
         * @brief 回复并发送
         * @param s 内容
         * @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         */
        template<class... T>
        MessageSource quoteAndSendMessage(MessageSource ms, T... val) {
            return this->quoteAndSendMessage(MessageChain(val...), std::move(ms));
        }
        /*!
         * @brief 发送信息
         * @tparam T 类型
         * 支持:
         * - SingleMessage的派生类
         * - MessageChain
         * - std::string / const char* 相当于发送PlainText()
         * @param msg 内容
         * @return MessageSource
         */
        template<class... T>
        MessageSource sendMessage(T... msg) {
            return this->sendMessage(MessageChain(msg...));
        }
        /// @brief 发送一条Message
        /// @detail 支持
        /// - std::string: 相当于发送PlainText(str)
        /// - MiraiCode 相当于发送反序列化MiraiCode后的
        /// - 各种SingleMessage的派生类
        /// - MessageChain
        /// @param msg Message
        /// @param retryTime 重试次数
        /// @return MessageSource
        template<class T>
        MessageSource sendMessage(T msg, int retryTime = 3, JNIEnv *env = nullptr) {
            return this->send1(msg, retryTime, env);
        }
        /// @deprecated since v2.8.1, use `sendMessage(msg)` or `sendMsg0(msg, retryTime, false, env)`
        [[deprecated("Use sendMessage")]] MessageSource sendMsg(const std::string &msg, int retryTime = 3, JNIEnv *env = nullptr) = delete;
        /// @deprecated since v2.8.1, use `sendMessage(MiraiCode)` or `sendMsg0(msg.toMiraiCode(), retryTime, false, env);`
        [[deprecated("Use sendMessage")]] MessageSource sendMsg(const MiraiCode &msg, int retryTime = 3, JNIEnv *env = nullptr) = delete;
        /// @deprecated since v2.8.1, use `sendMessage(Tools::VectorToString(std::move(msg)))` or `sendMsg0(Tools::VectorToString(std::move(msg)), retryTime, false, env);`
        [[deprecated("Use sendMessage")]] MessageSource sendMsg(std::vector<std::string> msg, int retryTime = 3, JNIEnv *env = nullptr) = delete;
        /*!
        * @brief 上传本地图片，务必要用绝对路径
        * 由于mirai要区分图片发送对象，所以使用本函数上传的图片只能发到群
        * @attention 最大支持图片大小为30MB
        * @throws
        * -可能抛出UploadException异常代表路径无效或大小大于30MB
        * -可能抛出MemberException找不到群或群成员
        */
        Image uploadImg(const std::string &path, JNIEnv * = nullptr) const;
        FlashImage uploadFlashImg(const std::string &path, JNIEnv * = nullptr) const;
        template<class T>
        T to() {
            static_assert(std::is_base_of_v<Contact, T>);
            return T(*this);
        }
    private: // private methods
        /// 发送纯文本信息
        /// @throw IllegalArgumentException, TimeOutException, BotIsBeingMutedException
        MessageSource sendMsg0(const std::string &msg, int retryTime, bool miraicode = false,
                               JNIEnv * = nullptr) const;
        template<class T>
        MessageSource send1(T msg, int retryTime, JNIEnv *env) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
            return sendMsg0(msg.toMiraiCode(), retryTime, true, env);
        }
        MessageSource send1(MessageChain msg, int retryTime, JNIEnv *env) {
            return sendMsg0(msg.toMiraiCode(), retryTime, true, env);
        }
        MessageSource send1(MiraiCode msg, int retryTime, JNIEnv *env) {
            return sendMsg0(msg.toMiraiCode(), retryTime, true, env);
        }
        MessageSource send1(std::string msg, int retryTime, JNIEnv *env) {
            return sendMsg0(msg, retryTime, false, env);
        }
        MessageSource send1(const char *msg, int retryTime, JNIEnv *env) {
            return sendMsg0(std::string(msg), retryTime, false, env);
        }
        MessageSource quoteAndSend0(const std::string &msg, MessageSource ms, JNIEnv *env = nullptr);
        template<class T>
        MessageSource quoteAndSend1(T s, MessageSource ms, JNIEnv *env = nullptr) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
            return this->quoteAndSend0(s.toMiraiCode(), ms, env);
        }
        MessageSource quoteAndSend1(std::string s, MessageSource ms, JNIEnv *env) {
            return this->quoteAndSend0(s, ms, env);
        }
        MessageSource quoteAndSend1(MessageChain mc, MessageSource ms, JNIEnv *env) {
            return this->quoteAndSend0(mc.toMiraiCode(), ms, env);
        }
    };
    class INudgeSupport{
    public:
        /*!
         * @brief 发送戳一戳
         * @warning 仅限Friend, Member类调用
         * @see MiraiCP::Friend::sendNudge, MiraiCP::Member::sendNudge
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        virtual void sendNudge() = 0;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CONTACT_H
#ifndef MIRAICP_PRO_EVENT_H
#define MIRAICP_PRO_EVENT_H
// #include "Bot.h"
// #include "Friend.h"
#ifndef MIRAICP_PRO_FRIEND_H
#define MIRAICP_PRO_FRIEND_H
// #include "Contact.h"
namespace MiraiCP {
    /// 好友类声明
    class Friend : public Contact, INudgeSupport {
    public:
        /// 删除好友(delete是C++关键字
        void deleteFriend(JNIEnv *env = nullptr);
        void refreshInfo(JNIEnv *env = nullptr);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
        /*!
         * @brief 构建好友对象
         * @param friendid q号
         * @param botid 对应机器人id
         */
        explicit Friend(QQID friendid, QQID botid, JNIEnv * = nullptr);
        explicit Friend(const Contact &c) : Contact(c) {
            if (c.type() != 1)
                throw IllegalArgumentException("无法从 type==" + std::to_string(c.type()) + " 转为 type == 1(friend)", MIRAICP_EXCEPTION_WHERE);
            refreshInfo();
        };
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_FRIEND_H
// #include "Group.h"
#ifndef MIRAICP_PRO_GROUP_H
#define MIRAICP_PRO_GROUP_H
// #include "Contact.h"
#include "json.hpp"
namespace MiraiCP {
    using QQID = unsigned long long;
    class Member; // forward declaration
    /*!
     * @detail 群聊类声明
     * @brief
     * @example 在事件中构建Group对象(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     *   Group a(e.group.id(), e.bot.id);
     *  });
     * @endcode
     * @example 上传并发送远程(群)文件(check in version 2.9.0)
     *  @code
     *   Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     *      // 发送D:\\ValveUnhandledExceptionFilter.txt本地文件到qq群的 /test.txt 路径
     *      RemoteFile tmp = e.group.sendFile("/test.txt", "D:\\ValveUnhandledExceptionFilter.txt");
     *   });
     *   @endcode
     *   @example 取群文件信息
     *   @code
     *   //根据qq群远程路径(不带文件名)和文件id, 文件id可以在上传返回的RemoteFile类型中获得, 会在子目录中查找如果当前目录未找到
     *   //根据qq群远程路径(带文件名)找, 不过由于qq群文件允许同名文件这一特性, 返回的文件为群文件中同名文件中随机一个(不可靠)
     *   Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     *      e.group.SendMsg(e.group.getFile("/", id).name());
     *      e.group.SendMsg(e.group.getFile("/test.txt").name());
     *      e.group.SendMsg(e.group.getFileListString("/"));
     *      });
     *   @endcode
     *   @example 取string格式群文件列表(check in version 2.9.0)
     *   @code
     *   e.group.getFileListString("/");
     *   @endcode
     */
    class Group : public Contact {
    public: // member classes and structs
        /// 群公告参数
        class AnnouncementParams {
        public:
            /// 发送给新成员
            bool send2new;
            /// 需要确认
            bool requireConfirm;
            /// 置顶
            bool pinned;
            /// 引导群成员修改群名片
            bool showEditCard;
            /// 显示弹窗
            bool showPopup;
            /// 序列化到文本
            nlohmann::json serializeToJson();
            explicit AnnouncementParams(bool send2New = false, bool requireConfirm = false, bool pinned = false,
                                        bool showEditCard = false, bool showPopup = false) : send2new(send2New),
                                                                                             requireConfirm(
                                                                                                     requireConfirm),
                                                                                             pinned(pinned),
                                                                                             showEditCard(showEditCard),
                                                                                             showPopup(showPopup) {}
        };
        /// 在线群公告
        class OnlineAnnouncement {
        public:
            /// 内容
            std::string content;
            /// 所属bot
            QQID botid;
            /// 公告属性
            AnnouncementParams params;
            /// 所在群id
            QQID groupid;
            /// 发送者id
            QQID senderid;
            /// 发送时间戳
            long long publicationTime;
            /// 唯一识别属性
            std::string fid;
            /// 如果需要确认，即为确认的人数
            int confirmNum;
            /// 图片id, 如果不存在即为空
            std::string imageid;
            /// 删除当前群公告
            /// @throw BotException
            void deleteThis();
            /// 反序列化
            static OnlineAnnouncement deserializeFromJson(const nlohmann::json &);
            OnlineAnnouncement(const std::string &content, AnnouncementParams &params,
                               QQID groupid, QQID senderid, QQID botid,
                               long long int publicationTime, const std::string &fid, int confirmNum,
                               const std::string &imageid) : content(content), params(params), groupid(groupid),
                                                             senderid(senderid), botid(botid),
                                                             publicationTime(publicationTime),
                                                             fid(fid), confirmNum(confirmNum), imageid(imageid) {}
        };
        /// 本地(未发送)群公告
        class OfflineAnnouncement {
        public:
            /// 内容
            std::string content;
            /// 公告属性
            AnnouncementParams params;
            /// 发布群公告
            Group::OnlineAnnouncement publishTo(const Group &);
            OfflineAnnouncement(const std::string &content, AnnouncementParams params) : content(content),
                                                                                         params(params) {}
        };
        /**
         * @brief 群设置
         * @details 使用uploadSetting上传设置，使用refreshInfo同步服务器设定，后面两项由于https://github.com/mamoe/mirai/issues/1307 还不能改
         */
        struct GroupSetting {
            /// 群名称
            std::string name;
            /// 禁言全部
            bool isMuteAll{};
            /// 允许群成员邀请
            bool isAllowMemberInvite{};
            /// 自动同意进群
            bool isAutoApproveEnabled{};
            /// 允许匿名聊天
            bool isAnonymousChatEnabled{};
        };
        /// 群文件的简短描述
        struct file_short_info {
            // 路径带文件名
            std::string path;
            // 唯一id
            std::string id;
        };
    public: // attrs
        /// 群设置
        GroupSetting setting;
    public: // constructors
        ///  @brief 构建以群号构建群对象
        /// @param groupid 群号
        /// @param botid 机器人id
        Group(QQID groupid, QQID botid, JNIEnv * = nullptr);
        explicit Group(const Contact &c) : Contact(c) {
            if (c.type() != 2)
                throw IllegalArgumentException("无法从 type==" + std::to_string(c.type()) + " 转为 type == 2(group)", MIRAICP_EXCEPTION_WHERE);
            refreshInfo();
        }
    public: // methods
        /**
         * @brief 更新群设置, 即覆盖服务器上的群设置
         * @details 从服务器拉去群设置用refreshInfo
         * @see Group::refreshInfo()
         */
        void updateSetting(JNIEnv * = nullptr);
        /// 取群成员列表
        /// @return vector<long>
        std::vector<unsigned long long> getMemberList(JNIEnv *env = nullptr);
        /*!
         * 以string格式取群成员列表
         * @note 格式:
         *  每个群成员id间用逗号分隔
        */
        std::string MemberListToString();
        /// 取群主
        Member getOwner(JNIEnv * = nullptr);
        /// 取群成员
        Member getMember(QQID memberid, JNIEnv *env = nullptr);
        Member operator[](QQID id);
        /// 取群公告列表
        std::vector<OnlineAnnouncement> getAnnouncementsList(JNIEnv *env);
        /// 刷新群聊信息
        void refreshInfo(JNIEnv *env = nullptr);
        void quit(JNIEnv *env = nullptr);
        /*!
        @brief 上传并发送远程(群)文件
        @param path-群文件路径(带文件名),根目录为/
        @param filepath-本地文件路径
        @attention 路径分隔符是 `/`
        */
        RemoteFile sendFile(const std::string &path, const std::string &filepath,
                            JNIEnv * = nullptr);
        /// 发送语音
        MessageSource sendVoice(const std::string &path, JNIEnv *env = nullptr) {
            return Contact::sendVoice0(path, env);
        }
        /*!
        取群文件信息,会自动搜索子目录
        @param path-群文件路径(不带文件名)
        @param id-文件id,可空，空则为用路径查找(此时路径要带文件名)
        @attention 因为群文件允许重名文件存在的特性，如果没有id该查找并不可靠，只能返回重名文件中的其中一个文件
        @see RemoteFile
        */
        RemoteFile getFile(const std::string &path, const std::string &id = "",
                           JNIEnv * = nullptr);
        /*!
         * @brief 取文件信息(根据id)
         * @param id 文件id
         * @return 文件
         * @detail 相当于从根目录开始遍历查找文件, 相当于getFile("/", id);
         */
        RemoteFile getFileById(const std::string &id, JNIEnv * = nullptr);
        RemoteFile getFileByFile(const RemoteFile &file, JNIEnv *env = nullptr) {
            return getFileById(file.id, env);
        }
        /*!
         * 获取path路径下全部文件信息
         * @param path - 远程路径
         * @return 返回值为一个vector容器, 每一项为short_info
        */
        std::vector<file_short_info>
        getFileList(const std::string &path, JNIEnv * = nullptr);
        /// 取文件列表以字符串形式返回
        /// @param path 文件夹路径
        std::string getFileListString(const std::string &path, JNIEnv * = nullptr);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_GROUP_H
// #include "Logger.h"
// #include "Member.h"
#ifndef MIRAICP_PRO_MEMBER_H
#define MIRAICP_PRO_MEMBER_H
// #include "Contact.h"
namespace MiraiCP {
    /*!
     * @brief 群成员类声明
     * @example 在事件中构建Member对象(check in version 2.9.0)
     * @code
     *  Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     * Member a(e.sender.id(), e.group.id(), e.bot.id);
     * });
     * @endcode
     * @example 踢出群成员(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
        try {
            Member m = Member(<MemberId>, e.group.id(), e.bot.id);
            m.kick("this_is_reason");
        }catch (BotException& err) {
            //权限不足
            Logger::logger.error(err.what());
        }catch (MemberException& err) {
            if (err.type == 1) {
                //找不到群
            }
            if (err.type == 2) {
                //找不到群成员
            }
        }
        });
     * @endcode
     */
    class Member : public Contact, INudgeSupport {
    public:
        /// @brief 权限等级
        ///     - OWNER群主 为 2
        ///     - ADMINISTRATOR管理员 为 1
        ///     - MEMBER群成员 为 0
        /// @note 上面那些变量在constants.h中有定义
        unsigned int permission = 0;
        /// @brief 更改群成员权限
        /// @param admin 如果为true为更改到管理员
        /// @param env
        void modifyAdmin(bool admin, JNIEnv *env = nullptr);
        /// @brief 构建群成员对象
        /// @param qqid 该成员q号
        /// @param groupid 所在群号
        /// @param botid 机器人id
        explicit Member(QQID qqid, QQID groupid, QQID botid,
                        JNIEnv * = nullptr);
        explicit Member(const Contact &c) : Contact(c) {
            if (c.type() != 3)
                throw IllegalArgumentException("无法从 type==" + std::to_string(c.type()) + " 转为 type == 3(member)", MIRAICP_EXCEPTION_WHERE);
            this->isAnonymous = this->_anonymous;
            refreshInfo();
        };
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        bool isAnonymous = false;
        /// 重新获取(刷新)群成员信息
        void refreshInfo(JNIEnv *env = nullptr);
        /// 发送语音
        MessageSource sendVoice(const std::string &path, JNIEnv *env = nullptr) {
            return Contact::sendVoice0(path, env);
        }
        /// 获取权限，会在构造时调用，请使用permission缓存变量
        /// @see Member::permission
        unsigned int getPermission(JNIEnv * = nullptr) const;
        /*!
         * 禁言当前对象，单位是秒，最少0秒最大30天，如果为0或者为负则unmute
         * @throws BotException, MuteException
        */
        void mute(int time, JNIEnv * = nullptr);
        /// 取消禁言
        /// @throws BotException, MuteException
        void unMute(JNIEnv *env = nullptr) {
            mute(0, env);
        }
        /*! 踢出这个群成员
        * @param reason - 原因
        */
        void kick(const std::string &reason, JNIEnv * = nullptr);
        /// At一个群成员
        At at() {
            /*返回at这个人的miraicode*/
            return At(this->id());
        }
        /// 更改群名片
        /// @throw MiraiCP::BotException 如果没权限时
        void changeNameCard(std::string_view newName, JNIEnv* = nullptr);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MEMBER_H
namespace MiraiCP {
    /// Event 工厂
    enum struct eventTypes {
        BaseEvent [[maybe_unused]], // 0
        GroupMessageEvent,          // 1
        PrivateMessageEvent,        // 2
        GroupInviteEvent,           // 3
        NewFriendRequestEvent,      // 4
        MemberJoinEvent,            // 5
        MemberLeaveEvent,           // 6
        RecallEvent,                // 7
        BotJoinGroupEvent,          // 8
        GroupTempMessageEvent,      // 9
        TimeOutEvent,               // 10
        BotOnlineEvent,             // 11
        NudgeEvent,                 // 12
        BotLeaveEvent,              // 13
        MemberJoinRequestEvent,     // 14
        MessagePreSendEvent,        // 15
        MiraiCPExceptionEvent,      // 16
        Command,                    // 17
        count,                      // 事件在此位置前定义，此时count为事件种类数
        error                       // 出现问题时使用此enum
    };
    /// Event抽象父类
    class MiraiCPEvent {
    public:
        MiraiCPEvent() = default;
        virtual ~MiraiCPEvent() = default;
    public:
        static eventTypes get_event_type() { return eventTypes::error; }
        virtual eventTypes getEventType() const = 0;
    };
    /// 所有事件处理timeoutevent都是机器人事件，指都有机器人实例
    template<class T>
    class BotEvent : public MiraiCPEvent {
    public:
        eventTypes getEventType() const override { return T::get_event_type(); }
        // TODO: 考虑设置一个Bot全局变量，此处存储一个Bot指针，减少无用构造.
        /// 该事件接受的机器人
        Bot bot;
        /// 以该机器人的名义发送日志
        /// @see BotLogger
        IdLogger botlogger;
        explicit BotEvent(QQID botid) : bot(botid), botlogger(botid, &Logger::logger) {}
    };
    /*!
     * @brief 群消息事件声明
     * @example 取群聊下一条消息(check in version 2.9.0)
     * @code
     * auto tmp = e.nextMessage();
     * e.group.sendMessage(tmp);
     * @endcode
     */
    class GroupMessageEvent : public BotEvent<GroupMessageEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::GroupMessageEvent;
        }
    public:
        ///来源群
        Group group;
        ///发送人
        Member sender;
        /// 信息
        MessageChain message;
        GroupMessageEvent(QQID botid, const Group &group, const Member &sender,
                          MessageChain mc) : BotEvent(botid), group(group),
                                             sender(sender), message(std::move(mc)){};
        /*!
         * @brief 取群聊下一个消息(群聊与本事件一样)
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不让这个消息被注册的其他监听器收到处理)
         * @return 消息链
         */
        MessageChain nextMessage(long time = -1, bool halt = true, JNIEnv *env = nullptr) const;
        /*!
         * @brief 取群聊中同群成员的下一个消息(发送人和群与本事件一样)
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不让消息被注册的其他监听器收到处理)
         * @return 消息链
         */
        MessageChain senderNextMessage(long time = -1, bool halt = true, JNIEnv *env = nullptr) const;
    };
    /*!
     * @detail 私聊消息事件类声明
     * @example 取好友下一条信息(check in version 2.9.0)
     * @code
     * auto tmp = e.nextMessage();
     * e.sender.sendMessage(tmp);
     * @endcode
     */
    class PrivateMessageEvent : public BotEvent<PrivateMessageEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::PrivateMessageEvent;
        }
    public:
        /// 发起人
        Friend sender;
        /// 信息
        MessageChain message{};
        /*!
         * @brief 构建私聊信息
         * @param botid 对应botid
         * @param sender 发送者
         * @param message 消息
         * @param messageSource 消息源
         */
        PrivateMessageEvent(QQID botid, Friend sender, MessageChain mc) : BotEvent(botid), sender(std::move(sender)),
                                                                          message(std::move(mc)){};
        /*!
         * @brief 取下一个消息(发送人和接收人和本事件一样)
         * @warning 如果两次发送信息间隔过短可能会漏过信息
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不被注册的监听器收到处理)
         * @return 消息链
         */
        MessageChain nextMessage(long time = -1, bool halt = true, JNIEnv *env = nullptr) const;
    };
    /// 群聊邀请事件类声明
    class GroupInviteEvent : public BotEvent<GroupInviteEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::GroupInviteEvent;
        }
    public:
        /// 事件序列化文本
        std::string source;
        /// 发起人昵称
        std::string inviterNick;
        /// 发起人id
        QQID inviterid = 0;
        /// 被邀请进的组
        std::string groupName;
        /// 群号
        QQID groupid = 0;
        static void operation0(const std::string &source, QQID botid, bool accept,
                               JNIEnv *env = nullptr);
        void reject(JNIEnv *env = nullptr) {
            GroupInviteEvent::operation0(this->source, this->bot.id, false, env);
        }
        void accept(JNIEnv *env = nullptr) {
            GroupInviteEvent::operation0(this->source, this->bot.id, true, env);
        }
        /*!
         * @brief 群邀请事件
         * @param botid 当前botid
         * @param source 序列化后字符串
         * @param inviterNick 邀请人昵称
         * @param inviterid 邀请人id
         * @param groupName 群聊名称
         * @param groupid 群号
         */
        GroupInviteEvent(QQID botid, const std::string &source, const std::string &inviterNick,
                         QQID inviterid, const std::string &groupName, QQID groupid)
            : BotEvent(botid), source(source), inviterNick(inviterNick), inviterid(inviterid), groupName(groupName),
              groupid(groupid) {}
    };
    /// 好友申请事件声明
    class NewFriendRequestEvent : public BotEvent<NewFriendRequestEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::NewFriendRequestEvent;
        }
    public:
        /// @brief 序列化的事件信息
        std::string source;
        /// @brief 对方id
        QQID fromid;
        QQID fromgroupid;
        /// @brief 对方昵称
        std::string nick;
        /// @brief 申请理由
        std::string message;
        /// @brief 接受好友申请
        /// @param source 事件序列化信息
        static void operation0(const std::string &source, QQID botid, bool accept,
                               JNIEnv *env = nullptr, bool ban = false);
        /// @brief 拒绝好友申请
        void reject(bool ban = false, JNIEnv *env = nullptr) {
            NewFriendRequestEvent::operation0(this->source, this->bot.id, false, env);
        }
        /// @brief 接受申请
        /// @param ban - 是否加入黑名单
        void accept(JNIEnv *env = nullptr) {
            NewFriendRequestEvent::operation0(this->source, this->bot.id, true, env);
        }
        /*!
         * @brief 好友申请事件
         * @param botid 对应botid
         * @param source 序列化后信息
         * @param fromid 对方id
         * @param fromgroupid 从哪个群申请的，否则为0
         * @param nick 对方昵称
         * @param message 申请理由
         */
        NewFriendRequestEvent(QQID botid, const std::string &source,
                              QQID fromid,
                              QQID fromgroupid, const std::string &nick,
                              const std::string &message)
            : BotEvent(botid), source(source), fromid(fromid), fromgroupid(fromgroupid), nick(nick),
              message(message) {}
    };
    /// 新群成员加入
    class MemberJoinEvent : public BotEvent<MemberJoinEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::MemberJoinEvent;
        }
    public:
        enum joinType {
            error = 0,
            invited = 1,
            applied = 2,
            rehab = 3
        };
        /*!
        * @brief 事件类型
        *   1 - 被邀请进来
        *   2 - 主动加入
        *   3 - 原群主通过 https://huifu.qq.com/ 恢复原来群主身份并入群
        */
        joinType type = joinType::error;
        ///新进入的成员
        Member member;
        ///目标群
        Group group;
        ///邀请人, 当type = 1时存在，否则则和member变量相同
        QQID inviterid;
        /*!
         * @brief 新群成员入群事件
         * @param botid botid
         * @param type 类别 @see MemberJoinEvent::type
         * @param member 入群群成员
         * @param group 群组
         * @param inviterid 邀请群成员id，如果不存在和member id参数一致
         */
        MemberJoinEvent(QQID botid, int type, const Member &member, const Group &group,
                        QQID inviterid) : BotEvent(botid), type(joinType(type)), member(member),
                                          group(group),
                                          inviterid(inviterid) {}
    };
    /// 群成员离开
    class MemberLeaveEvent : public BotEvent<MemberLeaveEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::MemberLeaveEvent;
        }
    public:
        /*!
        * @brief 事件类型
        *           1 - 被踢出
        *           2 - 主动退出
        */
        int type = 0;
        /// 退出的成员q号
        QQID memberid;
        /// 目标群
        Group group;
        /// 操作人, 主动退出时与member相同，该成员可能是当前bot，名称为operater以与系统operator区分
        QQID operaterid;
        /*!
         * @brief 群成员离开
         * @param botid
         * @param type
         * @param memberid 退出的群成员
         * @param group 群
         * @param operaterid 操作人id, 主动退出时与member相同，该成员可能是当前bot，名称为operater以与系统operator区分
         */
        MemberLeaveEvent(QQID botid, int type, QQID memberid,
                         Group group,
                         QQID operaterid) : BotEvent(botid), type(type), memberid(memberid),
                                            group(std::move(group)),
                                            operaterid(operaterid) {}
    };
    /// 撤回信息
    class RecallEvent : public BotEvent<RecallEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::RecallEvent;
        }
    public:
        /// 为1时是好友私聊中撤回，为2时为群聊内撤回
        int type = 0;
        /// 时间戳
        int time = 0;
        /// 原发送者
        QQID authorid = 0;
        /// 撤回者
        QQID operatorid = 0;
        /// 信息id
        std::string ids;
        //内部ids
        std::string internalids;
        //当type是2的时候存在，否则为0
        QQID groupid = 0;
        /*!
         * @brief 撤回事件
         * @param botid 对应bot
         * @param type 类型
         * @param time 时间
         * @param authorid 发送者id
         * @param operatorid 撤回者id
         * @param ids 消息源ids
         * @param internalids 消息源internalids
         * @param groupid
         */
        RecallEvent(QQID botid, int type, int time, QQID authorid,
                    QQID operatorid, std::string ids, std::string internalids,
                    QQID groupid) : BotEvent(botid), type(type), time(time), authorid(authorid),
                                    operatorid(operatorid), ids(std::move(ids)),
                                    internalids(std::move(internalids)),
                                    groupid(groupid) {}
    };
    /// 机器人进入某群
    class BotJoinGroupEvent : public BotEvent<BotJoinGroupEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::BotJoinGroupEvent;
        }
    public:
        /// 1-主动加入,2-被邀请加入,3-提供恢复群主身份加入
        int type;
        /// 进入的群
        Group group;
        /// 当type=2时存在，为邀请人，否则为空，调用可能会报错
        QQID inviterid;
        /*!
         * @brief bot加入群
         * @param botid 对应bot
         * @param type 类别
         * @param group 加入的群
         * @param inviter 邀请人
         */
        BotJoinGroupEvent(QQID botid, int type, Group group,
                          QQID inviter)
            : BotEvent(botid), type(type), group(std::move(group)), inviterid(inviter) {}
    };
    /// 群临时会话
    class GroupTempMessageEvent : public BotEvent<GroupTempMessageEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::GroupTempMessageEvent;
        }
    public:
        /// 来源群
        Group group;
        /// 发送人
        Member sender;
        /// 信息
        MessageChain message;
        /*!
         * @brief 群临时会话消息事件
         * @param botid 对应bot
         * @param group 发起的群
         * @param sender 发送消息对象
         * @param message 消息
         * @param messageSource 消息源
         */
        GroupTempMessageEvent(QQID botid, Group group, Member sender,
                              MessageChain message) : BotEvent(botid),
                                                      group(std::move(group)),
                                                      sender(std::move(sender)),
                                                      message(std::move(message)) {}
    };
    /// 定时任务结束
    class TimeOutEvent : public MiraiCPEvent {
    public:
        /// 事件所附信息
        std::string msg;
    public:
        explicit TimeOutEvent(std::string msg) : msg(std::move(msg)) {}
    public:
        static eventTypes get_event_type() {
            return eventTypes::TimeOutEvent;
        }
        eventTypes getEventType() const override { return this->get_event_type(); }
    };
    /// 机器人上线事件
    class BotOnlineEvent : public BotEvent<BotOnlineEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::BotOnlineEvent;
        }
    public:
        explicit BotOnlineEvent(QQID botid) : BotEvent(botid) {}
    };
    /*! 戳一戳事件
    /* @warning nudgeEvent事件也会被bot自己发的Nudge触发, 可能会造成无限循环
     */
    class NudgeEvent : public BotEvent<NudgeEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::NudgeEvent;
        }
    public:
        ///发送人
        Contact from;
        /// 目标
        Contact target;
        /// 发送的环境, 可能为Group / Friend
        Contact subject;
        NudgeEvent(const Contact &c, const Contact &target, const Contact &subject, QQID botid) : BotEvent(botid), from(c),
                                                                                                  target(target), subject(subject) {}
    };
    /// 机器人退群事件
    /// 可能有3种类型, 主动退/被踢/解散
    /// 目前mirai的botLeave事件还不稳定暂时不支持类型
    class BotLeaveEvent : public BotEvent<BotLeaveEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::BotLeaveEvent;
        }
    public:
        /// 退出的群
        /// @attension 收到这个事件时已经退出该群, 可能取不到相关信息
        QQID groupid;
        BotLeaveEvent(QQID g, QQID botid) : BotEvent(botid), groupid(g) {}
    };
    /// 申请加群事件, bot需为管理员或者群主
    class MemberJoinRequestEvent : public BotEvent<MemberJoinRequestEvent> {
    private:
        std::string source;
    private:
        void operate(const std::string &s,
                     QQID botid,
                     bool sign,
                     const std::string &msg = "",
                     JNIEnv *env = nullptr) const;
    public:
        static eventTypes get_event_type() {
            return eventTypes::MemberJoinRequestEvent;
        }
    public:
        /// 申请的群, 如果不存在就表明广播这个事件的时候机器人已经退出该群
        std::optional<Group> group;
        /// 邀请人, 如果不存在表明这个邀请人退出了群或没有邀请人为主动进群
        std::optional<Member> inviter;
    public:
        MemberJoinRequestEvent(std::optional<Group> g, std::optional<Member> i, QQID botid, std::string source)
            : BotEvent(botid), group(std::move(g)), inviter(std::move(i)), source(std::move(source)){};
        /// 通过
        void accept() {
            operate(this->source, this->bot.id, true);
        }
        /// 拒绝
        void reject(const std::string &msg) {
            operate(this->source, this->bot.id, false, msg);
        }
    };
    /*! 每条消息发送前的事件, 总是在消息实际上被发送和广播MessagePostSendEvent前广播
     * @see MessagePostSendEvent
     * @warning 在这个事件里小心使用sendMessage, 可能会触发无限递归 preSend -> sendMessage -> preSend -> ...
     * */
    class MessagePreSendEvent : public BotEvent<MessagePreSendEvent> {
    public:
        static eventTypes get_event_type() {
            return eventTypes::MessagePreSendEvent;
        }
    public:
        /// 发送目标
        Contact target;
        /// 消息
        MessageChain message;
        explicit MessagePreSendEvent(Contact c, MessageChain mc, QQID botid) : BotEvent(botid), target(std::move(c)), message(std::move(mc)) {}
    };
    class MiraiCPExceptionBase; // forward declaration
    /// @brief 异常抛出事件
    class MiraiCPExceptionEvent : public MiraiCPEvent {
    private:
        MiraiCPExceptionBase *exceptionPtr;
    public:
        explicit MiraiCPExceptionEvent(MiraiCPExceptionBase *err) {
            exceptionPtr = err;
        }
    public:
        static eventTypes get_event_type() {
            return eventTypes::MiraiCPExceptionEvent;
        }
        eventTypes getEventType() const override { return this->get_event_type(); }
        MiraiCPExceptionBase *getException() {
            return exceptionPtr;
        }
    };
    class Event {
    private:
        class eventNode {
        public:
            bool enable = true;
            std::function<void(MiraiCPEvent *)> func;
            explicit eventNode(std::function<void(MiraiCPEvent *)> f) : func(std::move(f)) {}
            void run(MiraiCPEvent *a) const {
                func(a);
            }
        };
        using eventNodeTable = std::vector<std::vector<eventNode>>;
        eventNodeTable vec;
    private:
        template<typename T>
        int id() const {
            static_assert(std::is_base_of_v<MiraiCPEvent, T>, "只支持广播继承MiraiCPEvent的事件");
            return int(T::get_event_type());
        }
        Event() : vec(int(eventTypes::count)){};
    public:
        /// 事件监听操控, 可用于stop停止监听和resume继续监听
        class NodeHandle {
        private:
            bool *enable;
        public:
            explicit NodeHandle(bool *a) { this->enable = a; }
            void stop() { *enable = false; }
            void resume() { *enable = true; }
        };
    public:
        // singleton mode
        static Event processor;
    public:
        bool noRegistered(int index) {
            return vec[index].empty();
        }
        /// 广播一个事件, 必须为MiraiCPEvent的派生类
        template<typename T>
        void broadcast(T &&val) {
            static_assert(std::is_base_of_v<MiraiCPEvent, T>, "只支持广播MiraiCPEvent的派生类");
            MiraiCPEvent *p = &val;
            for (auto &a: vec[id<T>()]) {
                a.run(p);
            }
        }
        /// 注册一个事件
        template<typename T>
        NodeHandle registerEvent(std::function<void(T)> a) {
            static_assert(std::is_base_of_v<MiraiCPEvent, T>, "只支持注册MiraiCPEvent的派生类事件");
            std::function<void(MiraiCPEvent *)> tmp = [=](MiraiCPEvent *p) {
                a(*dynamic_cast<T *>(p));
            };
            eventNode t(tmp);
            vec[id<T>()].emplace_back(t);
            return NodeHandle(&t.enable);
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_EVENT_H
#ifndef MIRAICP_PRO_EXCEPTION_H
#define MIRAICP_PRO_EXCEPTION_H
// #define MiraiCPThrow(x) throw x.append(__FILE__, __LINE__)
#define ErrorHandle(x, y) ErrorHandle0(__FILE__, __LINE__, (x), (y))
#define MIRAICP_EXCEPTION_WHERE __FILE__, __LINE__
#if defined(_MSC_VER)
#define ShouldNotUse(msg) _Pragma("warning(error:4996)") [[deprecated(msg)]] _Pragma("warning(warning:4996)")
#else
#if defined(__GNUC__)
#define ShouldNotUse(msg) [[deprecated(msg)]] __attribute__((error(msg)))
#else
#define ShouldNotUse(msg)
#endif
#endif
#include <exception>
#include <string>
namespace MiraiCP {
    /// @brief 总异常抽象类，用于一般捕获，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionBase
    class MiraiCPExceptionBase : public ::std::exception {
    protected:
        using string = std::string;
    protected:
        /// @brief 异常内容
        string re;
    public:
        /// @brief 发生异常的行号
        int lineNum = 0;
        /// @brief 发生异常的文件名
        string filename;
    protected:
        /// 受保护构造函数，供子类调用
        MiraiCPExceptionBase(string _filename, int _lineNum) : filename(std::move(_filename)), lineNum(_lineNum) {}
    public:
        ~MiraiCPExceptionBase() override = default;
    protected:
        /// @brief 异常事件广播
        void exception_broadcast();
    public:
        /// 异常信息
        const char *what() const noexcept override { return re.c_str(); }
        /// 实际抛出方法
        void raise() const;
    public: // 暴露的接口
        /// basicRaise 基本抛出方法，子类重写该方法
        virtual void basicRaise() const;
        // CRTP实现一次，调用静态的exceptionType
        /// 获取异常类型，通用接口
        virtual string getExceptionType() = 0;
        // 每个子类需要单独实现该静态方法
        /// 返回异常的类型，该静态方法无法正确实现多态，请使用 getExceptionType
        /// @see getExceptionType
        static string exceptionType() { return "MiraiCPException"; }
    };
    /// @brief 总异常CRTP抽象类，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionCRTP
    /// @note 请勿给该类增加新的属性。如果要增加属性应在 MiraiCPExceptionBase 中增加
    template<class T>
    class MiraiCPExceptionCRTP : public MiraiCPExceptionBase {
    protected:
        /// 委托构造函数
        MiraiCPExceptionCRTP(string _filename, int _lineNum) : MiraiCPExceptionBase(std::move(_filename), _lineNum) {
            exception_broadcast();
        }
    public:
        // 构造时传入类型字符串
        // 最好不要调用该构造函数
        explicit MiraiCPExceptionCRTP(const string &description, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            if (description.empty())
                this->re = T::exceptionType() + ":MiraiCP异常";
            else
                this->re = T::exceptionType() + ":" + description;
        }
    public:
        // CRTP类型获取实现
        string getExceptionType() override { return T::exceptionType(); }
    };
    /// @brief 通用MiraiCP异常
    /// @param const string &description, string _filename, int _lineNum
    /// @see MiraiCPExceptionBase
    typedef MiraiCPExceptionCRTP<MiraiCPExceptionBase> MiraiCPException;
    /// 文件读取异常.
    /// @see MiraiCPExceptionBase
    class UploadException : public MiraiCPExceptionCRTP<UploadException> {
    public:
        explicit UploadException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "上传(图片/文件)异常" + text;
        }
        static std::string exceptionType() { return "UploadException"; }
    };
    /// 通常为Mirai返回
    /// @see MiraiCPExceptionBase
    class IllegalStateException : public MiraiCPExceptionCRTP<IllegalStateException> {
    public:
        explicit IllegalStateException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "状态异常:" + text;
        }
        static std::string exceptionType() { return "IllegalStateException"; }
    };
    /// 内部异常, 通常为json读写问题
    /// @see MiraiCPExceptionBase
    class APIException : public MiraiCPExceptionCRTP<APIException> {
    public:
        explicit APIException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "MiraiCP内部无法预料的错误:" + text;
        }
        static string exceptionType() { return "APIException"; }
    };
    /// 机器人操作异常
    /// @see MiraiCPExceptionBase
    class BotException : public MiraiCPExceptionCRTP<BotException> {
    public:
        explicit BotException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            re = "没有权限执行该操作";
        }
        explicit BotException(string d, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            re = std::move(d);
        }
        static string exceptionType() { return "BotException"; }
    };
    /// 被禁言异常, 通常发生于发送信息
    class BotIsBeingMutedException : public MiraiCPExceptionCRTP<BotIsBeingMutedException> {
    public:
        /// 剩余禁言时间, 单位秒
        int timeRemain;
    public:
        explicit BotIsBeingMutedException(int t, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "发送信息失败, bot已被禁言, 剩余时间" + std::to_string(t);
            timeRemain = t;
        }
        static string exceptionType() { return "BotIsBeingMutedException"; }
    };
    /// 禁言异常
    /// @see MiraiCPExceptionBase
    class MuteException : public MiraiCPExceptionCRTP<MuteException> {
    public:
        /*
        *	 禁言时间超出0s~30d
        */
        MuteException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "禁言时长不在0s~30d中间";
        }
        static string exceptionType() { return "MuteException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class MemberException : public MiraiCPExceptionCRTP<MemberException> {
    public:
        enum MemberExceptionType : int {
            OtherType,
            NoSuchGroup,
            NoSuchMember
        };
        MemberExceptionType type = OtherType;
        /*
        *   "1" - 找不到群
        *	"2" - 找不到群成员
        */
        explicit MemberException(int _type, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            type = MemberExceptionType(_type);
            switch (type) {
                case NoSuchGroup:
                    this->re = "找不到群";
                    break;
                case NoSuchMember:
                    this->re = "找不到群成员";
                    break;
                default:
                    break;
            }
            this->re = "";
        }
        static string exceptionType() { return "MemberException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class FriendException : public MiraiCPExceptionCRTP<FriendException> {
    public:
        /*
        *   找不到好友
        */
        FriendException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "找不到好友";
        }
        static string exceptionType() { return "FriendException"; }
    };
    /// 获取群错误
    /// @see MiraiCPExceptionBase
    class GroupException : public MiraiCPExceptionCRTP<GroupException> {
    public:
        GroupException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "C++:找不到群";
        }
        static string exceptionType() { return "GroupException"; }
    };
    /// 撤回异常
    /// @see MiraiCPExceptionBase
    class RecallException : public MiraiCPExceptionCRTP<RecallException> {
    public:
        RecallException(string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = "该消息已经被撤回";
        }
        static string exceptionType() { return "RecallException"; }
    };
    /// 远程资源出现问题
    /// @see MiraiCPExceptionBase
    class RemoteAssetException : public MiraiCPExceptionCRTP<RemoteAssetException> {
    public:
        explicit RemoteAssetException(string e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = std::move(e);
        }
        static string exceptionType() { return "RemoteAssetException"; }
    };
    /// 参数错误
    /// @see MiraiCPExceptionBase
    class IllegalArgumentException : public MiraiCPExceptionCRTP<IllegalArgumentException> {
    public:
        explicit IllegalArgumentException(string e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = std::move(e);
        }
        static string exceptionType() { return "IllegalArgumentException"; }
    };
    /// 超时
    /// @see MiraiCPExceptionBase
    class TimeOutException : public MiraiCPExceptionCRTP<TimeOutException> {
    public:
        explicit TimeOutException(std::string e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            this->re = std::move(e);
        }
        static string exceptionType() { return "TimeOutException"; }
    };
    /// 事件被取消, 一般出现在发送消息时在preSendMessageEvent取消的时候抛出
    /// @see MiraiCPExceptionBase
    class EventCancelledException : public MiraiCPExceptionCRTP<EventCancelledException> {
    public:
        explicit EventCancelledException(const string &msg, string _filename, int _lineNum) : MiraiCPExceptionCRTP(std::move(_filename), _lineNum) {
            re = msg;
        }
        static string exceptionType() { return "EventCancelledException"; }
    };
    inline void ErrorHandle0(const std::string &name, int line, const std::string &re, const std::string &ErrorMsg = "") {
        if (re == "EF")
            throw FriendException(name, line);
        if (re == "EG")
            throw GroupException(name, line);
        if (re == "EM")
            throw MemberException(1, name, line);
        if (re == "EMM")
            throw MemberException(2, name, line);
        if (re == "EB")
            throw BotException("找不到bot:" + re, name, line);
        if (re == "EA")
            throw APIException(ErrorMsg, name, line);
        if (re == "EC")
            throw EventCancelledException("发送信息被取消", name, line);
        if (re == "ET")
            throw TimeOutException("发送信息超时", name, line);
        if (re == "EP")
            throw BotException(name, line);
        // equal to Tools::start_with
        if (re.rfind("EBM", 0) == 0)
            throw BotIsBeingMutedException(std::stoi(re.substr(3)), name, line);
    }
} // namespace MiraiCP
#endif //MIRAICP_PRO_EXCEPTION_H
#ifndef MIRAICP_PRO_FORWARDEDMESSAGE_H
#define MIRAICP_PRO_FORWARDEDMESSAGE_H
// #include "MessageChain.h"
#include <json.hpp>
#include <string>
namespace MiraiCP {
    class Contact;
    class ForwardedMessage;
    ///聊天记录里每个消息
    class ForwardedNode {
    public:
        ///发送者id
        QQID id = 0;
        ///发送者昵称
        std::string name;
        ///发送信息
        MessageChain message;
        std::shared_ptr<ForwardedMessage> forwardedMsg;
        ///发送时间(时间戳)
        int time = 0;
        /// @brief 聊天记录里的每条信息
        /// @param id - 发送者id
        /// @param name - 发送者昵称
        /// @param message - 发送的信息
        /// @param time - 发送时间，以时间戳记
        ForwardedNode(QQID id, const std::string &name, MessageChain message,
                      int time)
            : id(id), name(name), message(std::move(message)), time(time) {}
        /// @brief 构造聊天记录里每条信息
        /// @param c - 发送者的contact指针
        /// @param message - 发送的信息
        /// @param t - 发送时间，时间戳格式
        ForwardedNode(Contact *c, MessageChain message, int t);
        ForwardedNode(Contact *c, ForwardedMessage message, int t);
        ForwardedNode(QQID id, const std::string &name, ForwardedMessage message, int t);
    };
    /*!转发消息, 由ForwardNode组成
     * @see class ForwardedNode
     *@example 构建聊天记录(check in version 2.9.0)
     * @code
     * ForwardedMessage(&e.group,
     *                   {ForwardedNode(1930893235, "", MessageChain(PlainText("")), 1),
     *                    ForwardedNode(1930893235, "", MessageChain(e.sender.at(), "aaa"), 1)})
     *          .sendTo(&e.group);
     * @endcode
     */
    class ForwardedMessage {
    private:
        /// json except value
        nlohmann::json sendmsg;
    public:
        std::vector<ForwardedNode> nodes;
        /*!
        *@brief 构建一条聊天记录
        *@details 第一个参数是聊天记录发生的地方, 然后是每条信息
        */
        ForwardedMessage(Contact *c, std::initializer_list<ForwardedNode> nodes);
        ForwardedMessage(Contact *c, std::vector<ForwardedNode> nodes);
        ForwardedNode operator[](int index) { return nodes[index]; }
        ForwardedMessage plus(const ForwardedNode &a) {
            ForwardedMessage tmp(*this);
            tmp.nodes.push_back(a);
            return tmp;
        }
        ForwardedMessage operator+(const ForwardedNode &a) { return this->plus(a); }
        void add(const ForwardedNode &a) { this->nodes.push_back(a); }
        /// 发送给群或好友或群成员
        MessageSource sendTo(Contact *c, JNIEnv * = nullptr);
        nlohmann::json nodesToJson();
    };
    /// 接收到的转发消息, 发送用 MiraiCP::ForwardedMessage
    class OnlineForwardedMessage : public SingleMessage {
    public:
        static int type() { return -4; }
        /// 里面每条信息
        std::vector<ForwardedNode> nodelist;
        /// 用展示出来ServiceMessage
        ServiceMessage origin;
        std::string resourceId;
        ForwardedNode operator[](int i) const {
            return this->nodelist[i];
        }
        bool operator==(const OnlineForwardedMessage &m) const;
        /// 转ForwardedMessage
        /// @param c 发生的环境, 比如群聊或者好友
        ForwardedMessage toForwardedMessage(Contact *c);
        explicit OnlineForwardedMessage(nlohmann::json o, const std::string &rid, std::vector<ForwardedNode> nodes) : SingleMessage(OnlineForwardedMessage::type(), ""), nodelist(std::move(nodes)), resourceId(rid), origin(ServiceMessage(o["serviceId"], o["content"])) {}
        /// 不支持直接发送OnlineForwardMessage, ForwardedMessage发送
        [[deprecated("use MiraiCP::ForwardedMessage to send")]] std::string toMiraiCode() const override {
            return "";
        }
        static OnlineForwardedMessage deserializationFromMessageSourceJson(nlohmann::json j);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_FORWARDEDMESSAGE_H
#ifndef MIRAICP_PRO_FRIEND_H
#define MIRAICP_PRO_FRIEND_H
// #include "Contact.h"
namespace MiraiCP {
    /// 好友类声明
    class Friend : public Contact, INudgeSupport {
    public:
        /// 删除好友(delete是C++关键字
        void deleteFriend(JNIEnv *env = nullptr);
        void refreshInfo(JNIEnv *env = nullptr);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
        /*!
         * @brief 构建好友对象
         * @param friendid q号
         * @param botid 对应机器人id
         */
        explicit Friend(QQID friendid, QQID botid, JNIEnv * = nullptr);
        explicit Friend(const Contact &c) : Contact(c) {
            if (c.type() != 1)
                throw IllegalArgumentException("无法从 type==" + std::to_string(c.type()) + " 转为 type == 1(friend)", MIRAICP_EXCEPTION_WHERE);
            refreshInfo();
        };
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_FRIEND_H
#ifndef MIRAICP_PRO_GROUP_H
#define MIRAICP_PRO_GROUP_H
// #include "Contact.h"
#include "json.hpp"
namespace MiraiCP {
    using QQID = unsigned long long;
    class Member; // forward declaration
    /*!
     * @detail 群聊类声明
     * @brief
     * @example 在事件中构建Group对象(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     *   Group a(e.group.id(), e.bot.id);
     *  });
     * @endcode
     * @example 上传并发送远程(群)文件(check in version 2.9.0)
     *  @code
     *   Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     *      // 发送D:\\ValveUnhandledExceptionFilter.txt本地文件到qq群的 /test.txt 路径
     *      RemoteFile tmp = e.group.sendFile("/test.txt", "D:\\ValveUnhandledExceptionFilter.txt");
     *   });
     *   @endcode
     *   @example 取群文件信息
     *   @code
     *   //根据qq群远程路径(不带文件名)和文件id, 文件id可以在上传返回的RemoteFile类型中获得, 会在子目录中查找如果当前目录未找到
     *   //根据qq群远程路径(带文件名)找, 不过由于qq群文件允许同名文件这一特性, 返回的文件为群文件中同名文件中随机一个(不可靠)
     *   Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     *      e.group.SendMsg(e.group.getFile("/", id).name());
     *      e.group.SendMsg(e.group.getFile("/test.txt").name());
     *      e.group.SendMsg(e.group.getFileListString("/"));
     *      });
     *   @endcode
     *   @example 取string格式群文件列表(check in version 2.9.0)
     *   @code
     *   e.group.getFileListString("/");
     *   @endcode
     */
    class Group : public Contact {
    public: // member classes and structs
        /// 群公告参数
        class AnnouncementParams {
        public:
            /// 发送给新成员
            bool send2new;
            /// 需要确认
            bool requireConfirm;
            /// 置顶
            bool pinned;
            /// 引导群成员修改群名片
            bool showEditCard;
            /// 显示弹窗
            bool showPopup;
            /// 序列化到文本
            nlohmann::json serializeToJson();
            explicit AnnouncementParams(bool send2New = false, bool requireConfirm = false, bool pinned = false,
                                        bool showEditCard = false, bool showPopup = false) : send2new(send2New),
                                                                                             requireConfirm(
                                                                                                     requireConfirm),
                                                                                             pinned(pinned),
                                                                                             showEditCard(showEditCard),
                                                                                             showPopup(showPopup) {}
        };
        /// 在线群公告
        class OnlineAnnouncement {
        public:
            /// 内容
            std::string content;
            /// 所属bot
            QQID botid;
            /// 公告属性
            AnnouncementParams params;
            /// 所在群id
            QQID groupid;
            /// 发送者id
            QQID senderid;
            /// 发送时间戳
            long long publicationTime;
            /// 唯一识别属性
            std::string fid;
            /// 如果需要确认，即为确认的人数
            int confirmNum;
            /// 图片id, 如果不存在即为空
            std::string imageid;
            /// 删除当前群公告
            /// @throw BotException
            void deleteThis();
            /// 反序列化
            static OnlineAnnouncement deserializeFromJson(const nlohmann::json &);
            OnlineAnnouncement(const std::string &content, AnnouncementParams &params,
                               QQID groupid, QQID senderid, QQID botid,
                               long long int publicationTime, const std::string &fid, int confirmNum,
                               const std::string &imageid) : content(content), params(params), groupid(groupid),
                                                             senderid(senderid), botid(botid),
                                                             publicationTime(publicationTime),
                                                             fid(fid), confirmNum(confirmNum), imageid(imageid) {}
        };
        /// 本地(未发送)群公告
        class OfflineAnnouncement {
        public:
            /// 内容
            std::string content;
            /// 公告属性
            AnnouncementParams params;
            /// 发布群公告
            Group::OnlineAnnouncement publishTo(const Group &);
            OfflineAnnouncement(const std::string &content, AnnouncementParams params) : content(content),
                                                                                         params(params) {}
        };
        /**
         * @brief 群设置
         * @details 使用uploadSetting上传设置，使用refreshInfo同步服务器设定，后面两项由于https://github.com/mamoe/mirai/issues/1307 还不能改
         */
        struct GroupSetting {
            /// 群名称
            std::string name;
            /// 禁言全部
            bool isMuteAll{};
            /// 允许群成员邀请
            bool isAllowMemberInvite{};
            /// 自动同意进群
            bool isAutoApproveEnabled{};
            /// 允许匿名聊天
            bool isAnonymousChatEnabled{};
        };
        /// 群文件的简短描述
        struct file_short_info {
            // 路径带文件名
            std::string path;
            // 唯一id
            std::string id;
        };
    public: // attrs
        /// 群设置
        GroupSetting setting;
    public: // constructors
        ///  @brief 构建以群号构建群对象
        /// @param groupid 群号
        /// @param botid 机器人id
        Group(QQID groupid, QQID botid, JNIEnv * = nullptr);
        explicit Group(const Contact &c) : Contact(c) {
            if (c.type() != 2)
                throw IllegalArgumentException("无法从 type==" + std::to_string(c.type()) + " 转为 type == 2(group)", MIRAICP_EXCEPTION_WHERE);
            refreshInfo();
        }
    public: // methods
        /**
         * @brief 更新群设置, 即覆盖服务器上的群设置
         * @details 从服务器拉去群设置用refreshInfo
         * @see Group::refreshInfo()
         */
        void updateSetting(JNIEnv * = nullptr);
        /// 取群成员列表
        /// @return vector<long>
        std::vector<unsigned long long> getMemberList(JNIEnv *env = nullptr);
        /*!
         * 以string格式取群成员列表
         * @note 格式:
         *  每个群成员id间用逗号分隔
        */
        std::string MemberListToString();
        /// 取群主
        Member getOwner(JNIEnv * = nullptr);
        /// 取群成员
        Member getMember(QQID memberid, JNIEnv *env = nullptr);
        Member operator[](QQID id);
        /// 取群公告列表
        std::vector<OnlineAnnouncement> getAnnouncementsList(JNIEnv *env);
        /// 刷新群聊信息
        void refreshInfo(JNIEnv *env = nullptr);
        void quit(JNIEnv *env = nullptr);
        /*!
        @brief 上传并发送远程(群)文件
        @param path-群文件路径(带文件名),根目录为/
        @param filepath-本地文件路径
        @attention 路径分隔符是 `/`
        */
        RemoteFile sendFile(const std::string &path, const std::string &filepath,
                            JNIEnv * = nullptr);
        /// 发送语音
        MessageSource sendVoice(const std::string &path, JNIEnv *env = nullptr) {
            return Contact::sendVoice0(path, env);
        }
        /*!
        取群文件信息,会自动搜索子目录
        @param path-群文件路径(不带文件名)
        @param id-文件id,可空，空则为用路径查找(此时路径要带文件名)
        @attention 因为群文件允许重名文件存在的特性，如果没有id该查找并不可靠，只能返回重名文件中的其中一个文件
        @see RemoteFile
        */
        RemoteFile getFile(const std::string &path, const std::string &id = "",
                           JNIEnv * = nullptr);
        /*!
         * @brief 取文件信息(根据id)
         * @param id 文件id
         * @return 文件
         * @detail 相当于从根目录开始遍历查找文件, 相当于getFile("/", id);
         */
        RemoteFile getFileById(const std::string &id, JNIEnv * = nullptr);
        RemoteFile getFileByFile(const RemoteFile &file, JNIEnv *env = nullptr) {
            return getFileById(file.id, env);
        }
        /*!
         * 获取path路径下全部文件信息
         * @param path - 远程路径
         * @return 返回值为一个vector容器, 每一项为short_info
        */
        std::vector<file_short_info>
        getFileList(const std::string &path, JNIEnv * = nullptr);
        /// 取文件列表以字符串形式返回
        /// @param path 文件夹路径
        std::string getFileListString(const std::string &path, JNIEnv * = nullptr);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_GROUP_H
#ifndef MIRAICP_PRO_LOGGER_H
#define MIRAICP_PRO_LOGGER_H
#include <functional>
#include <sstream>
#include <jni.h>
#include <json.hpp>
// #include "MiraiCode.h"
namespace MiraiCP {
    using QQID = unsigned long long;
    class MiraiCodeable; // forward declaration
    /*!
    * @class Logger
    * @brief 以MiraiCP的名义发送日志, 日志表现格式是: 2021-06-28 09:37:22 [log level]/MiraiCP: [log content], 为最底层的logger
    * @example 发送日志
	* 发送消息级日志
	* @code Logger::logger.info(string) @endcode
	* 发送警告级日志
	* @code Logger::logger.warning(string) @endcode
	* 发送错误级日志
	* @code Logger::logger.error(string) @endcode
    * @example 设置loggerhandler的action(check in version 2.9.0)
    * @code
     * Logger::logger.registerHandle([](std::string content, int level){
    *     \\do some things
    * });
    * @endcode
    */
    class Logger_interface {
        using string = std::string;
    public:
        /// @brief 封装lambda类型
        /// @param string 日志内容
        /// @param 日志级别
        ///     - 0 info
        ///     - 1 warning
        ///     - 2 error
        typedef std::function<void(string, int)> Action;
        /// @brief loggerhandler会在每次log执行前执行一遍，可用于执行自定义的保存操作等
        struct Handler {
            /// @brief 是否启用
            bool enable = true;
            /// @brief 执行的操作，格式为lambda
            Action action = [](const string &content, int level) {};
        };
        Handler loggerhandler;
    protected:
        jmethodID log = nullptr;
    private:
        std::string p() {
            return "";
        }
        template<class T, class... T1>
        std::string p(T val, T1... val1) {
            std::stringstream sstream;
            sstream << val;
            return sstream.str() + p(val1...);
        }
        template<class... T>
        std::string p(std::string a, T... val1) {
            return a + p(val1...);
        }
        template<class... T>
        std::string p(MiraiCodeable &val, T... val1) {
            return val.toMiraiCode() + p(val1...);
        }
    protected:
        void log0(const string &log, int level, nlohmann::json j, JNIEnv *env = nullptr);
        /// @brief 日志底层实现封装
        /// @param log 日志内容
        /// @param level 日志等级
        /// @param env jnienv
        virtual void log1(const string &log, int level, JNIEnv *env = nullptr) = 0;
    public:
        jmethodID getjmethod() {
            return this->log;
        }
        // 初始化 获取methodid
        void init(JNIEnv * = nullptr);
        ///发送普通(info级日志)
        template<class... T>
        void info(T... val) {
            this->log1(p(val...), 0);
        }
        ///发送警告(warning级日志)
        template<class... T>
        void warning(T... val) {
            this->log1(p(val...), 1);
        }
        ///发送错误(error级日志)
        template<class... T>
        void error(T... val) {
            this->log1(p(val...), 2);
        }
        /// @brief 设置loggerhandler的action
        /// @param action 执行的操作
        /// @see Logger::handler
        void registerHandle(Action action) {
            this->loggerhandler.action = std::move(action);
        }
        /// @brief 设置handler的启用状态
        /// @param state 状态，启用或者关闭
        /// @example 设置handler的启用状态(check in version 2.9.0)
        /// @code Logger::logger.setHandleState(ture); @endcode
        void setHandleState(bool state) {
            this->loggerhandler.enable = state;
        }
    };
    class Logger : public Logger_interface {
    private:
        Logger() = default;
    protected:
        /// @brief 日志底层实现封装
        /// @param content 日志内容
        /// @param level 日志等级
        /// @param env jnienv
        void log1(const std::string &content, int level, JNIEnv *env) override;
    public:
        static Logger logger;
    };
    /// 带id(一般为bot账号)的logger
    class IdLogger : public Logger_interface {
    public:
        QQID id;
    protected:
        void log1(const std::string &content, int level, JNIEnv *env) override;
    public:
        IdLogger(QQID id, Logger *l) : id(id) {
            this->loggerhandler = l->loggerhandler;
            this->log = l->getjmethod();
        }
    };
    /// 插件logger
    class PluginLogger : public Logger_interface {
    protected:
        void log1(const std::string &content, int level, JNIEnv *env) override;
    public:
        explicit PluginLogger(Logger *l) {
            this->loggerhandler = l->loggerhandler;
            this->log = l->getjmethod();
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOGGER_H
#ifndef MIRAICP_PRO_LOWLEVELAPI_H
#define MIRAICP_PRO_LOWLEVELAPI_H
#include <json.hpp>
#include <jni.h>
namespace MiraiCP {
    /// 较底层api
    class LowLevelAPI {
    public:
        /// @brief 抽象封装底层发送信息接口
        /// @param content 信息字符串
        /// @param c 目标Contact->serialization()
        /// @param miraicode 是否为miraicode格式
        /// @param env JNIEnv
        /// @return
        static std::string send0(const std::string &content, nlohmann::json c, int retryTime, bool miraicode, JNIEnv *env,
                                 const std::string &errorInfo = "");
        /// @brief 取该联系人的一些信息
        /// @param c 该联系人Contact->serializationToString()
        /// @return json格式字符串，待解析
        static std::string getInfoSource(const std::string &, JNIEnv *);
        /*!
         * @brief 上传图片
         * @param path 本地地址
         * @param c 上传的对象, Contact->serializationToString()
         * @param env JNIEnv
         * @return string 待解析json
         */
        static std::string uploadImg0(const std::string &, const std::string &, JNIEnv *);
        /// 每个对象的必有信息
        struct info {
            std::string nickornamecard;
            std::string avatarUrl;
        };
        /// 获取每个对象必有信息
        /// @see LowLevelAPI::info
        static info info0(const std::string &source);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOWLEVELAPI_H
#ifndef MIRAICP_PRO_MEMBER_H
#define MIRAICP_PRO_MEMBER_H
// #include "Contact.h"
namespace MiraiCP {
    /*!
     * @brief 群成员类声明
     * @example 在事件中构建Member对象(check in version 2.9.0)
     * @code
     *  Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
     * Member a(e.sender.id(), e.group.id(), e.bot.id);
     * });
     * @endcode
     * @example 踢出群成员(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
        try {
            Member m = Member(<MemberId>, e.group.id(), e.bot.id);
            m.kick("this_is_reason");
        }catch (BotException& err) {
            //权限不足
            Logger::logger.error(err.what());
        }catch (MemberException& err) {
            if (err.type == 1) {
                //找不到群
            }
            if (err.type == 2) {
                //找不到群成员
            }
        }
        });
     * @endcode
     */
    class Member : public Contact, INudgeSupport {
    public:
        /// @brief 权限等级
        ///     - OWNER群主 为 2
        ///     - ADMINISTRATOR管理员 为 1
        ///     - MEMBER群成员 为 0
        /// @note 上面那些变量在constants.h中有定义
        unsigned int permission = 0;
        /// @brief 更改群成员权限
        /// @param admin 如果为true为更改到管理员
        /// @param env
        void modifyAdmin(bool admin, JNIEnv *env = nullptr);
        /// @brief 构建群成员对象
        /// @param qqid 该成员q号
        /// @param groupid 所在群号
        /// @param botid 机器人id
        explicit Member(QQID qqid, QQID groupid, QQID botid,
                        JNIEnv * = nullptr);
        explicit Member(const Contact &c) : Contact(c) {
            if (c.type() != 3)
                throw IllegalArgumentException("无法从 type==" + std::to_string(c.type()) + " 转为 type == 3(member)", MIRAICP_EXCEPTION_WHERE);
            this->isAnonymous = this->_anonymous;
            refreshInfo();
        };
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        bool isAnonymous = false;
        /// 重新获取(刷新)群成员信息
        void refreshInfo(JNIEnv *env = nullptr);
        /// 发送语音
        MessageSource sendVoice(const std::string &path, JNIEnv *env = nullptr) {
            return Contact::sendVoice0(path, env);
        }
        /// 获取权限，会在构造时调用，请使用permission缓存变量
        /// @see Member::permission
        unsigned int getPermission(JNIEnv * = nullptr) const;
        /*!
         * 禁言当前对象，单位是秒，最少0秒最大30天，如果为0或者为负则unmute
         * @throws BotException, MuteException
        */
        void mute(int time, JNIEnv * = nullptr);
        /// 取消禁言
        /// @throws BotException, MuteException
        void unMute(JNIEnv *env = nullptr) {
            mute(0, env);
        }
        /*! 踢出这个群成员
        * @param reason - 原因
        */
        void kick(const std::string &reason, JNIEnv * = nullptr);
        /// At一个群成员
        At at() {
            /*返回at这个人的miraicode*/
            return At(this->id());
        }
        /// 更改群名片
        /// @throw MiraiCP::BotException 如果没权限时
        void changeNameCard(std::string_view newName, JNIEnv* = nullptr);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MEMBER_H
#ifndef MIRAICP_PRO_MESSAGECHAIN_H
#define MIRAICP_PRO_MESSAGECHAIN_H
// #include "Exception.h"
// #include "SingleMessage.h"
namespace MiraiCP {
    class MessageSource; // forward declaration
    /// 消息链, 一般由SingleMessage组成
    class MessageChain : public MiraiCodeable {
    public:
        class Message {
        private:
            std::shared_ptr<SingleMessage> content;
        public:
            /// 代表的子类
            /// @see MessageChain::messageType
            int type() const {
                return this->content->type;
            };
            template<class T>
            explicit Message(T a) {
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
                T *b = new T(a);
                content.reset(b);
            }
            explicit Message(std::shared_ptr<SingleMessage> a) {
                content = std::move(a);
            }
            /// 取指定类型
            /// @throw IllegalArgumentException
            template<class T>
            T get() const {
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
                if (T::type() != this->type())
                    throw IllegalArgumentException("cannot convert from " + SingleMessage::messageType[this->type()] + " to " + SingleMessage::messageType[T::type()], MIRAICP_EXCEPTION_WHERE);
                T *re = static_cast<T *>(this->content.get());
                if (re == nullptr)
                    throw IllegalArgumentException("cannot convert from " + SingleMessage::messageType[this->type()] + " to " + SingleMessage::messageType[T::type()], MIRAICP_EXCEPTION_WHERE);
                return *re;
            }
            bool operator==(const Message &m) const {
                return this->content->type == m.content->type && this->content->toMiraiCode() == m.toMiraiCode();
            }
            bool operator!=(const Message &m) const {
                return this->content->type != m.content->type || this->content->toMiraiCode() != m.toMiraiCode();
            }
            std::string toMiraiCode() const {
                return this->content->toMiraiCode();
            }
        };
    private:
        void p(std::vector<Message> *) {}
        template<class T1, class... T2>
        void p(std::vector<Message> *v, T1 h, T2... args) {
            static_assert(std::is_base_of_v<SingleMessage, T1>, "只支持SingleMessage子类");
            v->push_back(Message(h));
            p(v, args...);
        }
        template<class... T2>
        void p(std::vector<Message> *v, std::string h, T2... args) {
            v->push_back(Message(PlainText(h)));
            p(v, args...);
        }
        template<class... T2>
        void p(std::vector<Message> *v, const char *h, T2... args) {
            v->push_back(Message(PlainText(h)));
            p(v, args...);
        }
        template<class... T>
        void p(std::vector<Message> *v, MessageChain mc, T... args) {
            v->insert(v->end(), mc.content.begin(), mc.content.end());
            p(v, args...);
        }
        std::vector<Message> content;
        MessageSource quoteAndSend0(const std::string &msg, QQID groupid = -1,
                                    JNIEnv *env = nullptr);
        template<class T>
        MessageSource quoteAndSend1(T s, QQID groupid = -1, JNIEnv *env = nullptr) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
            return this->quoteAndSend0(s.toMiraiCode(), groupid, env);
        }
        MessageSource quoteAndSend1(std::string s, QQID groupid, JNIEnv *env) {
            return this->quoteAndSend0(s, groupid, env);
        }
        MessageSource quoteAndSend1(MessageChain mc, QQID groupid, JNIEnv *env) {
            return this->quoteAndSend0(mc.toMiraiCode(), groupid, env);
        }
    public:
        size_t size() {
            return this->content.size();
        }
        const std::vector<Message> &vector() {
            return this->content;
        }
        /// 如果由MiraiCP构造(incoming)就会存在，否则则不存在
        std::optional<MessageSource> source = std::nullopt;
        /// @brief 找到miraiCode结尾的`]`
        /// @param s 文本
        /// @param start 开始位置
        /// @return 如果不存在返回-1, 存在则返回index
        static size_t findEnd(const std::string &s, size_t start) {
            size_t pos = start;
            while (pos < s.length()) {
                switch (s[pos]) {
                    case '\\':
                        pos += 2;
                        continue;
                    case ']':
                        return pos;
                }
                pos++;
            }
            return -1;
        }
        std::string toMiraiCode() const override;
        std::vector<std::string> toMiraiCodeVector() const {
            std::vector<std::string> tmp;
            for (const Message &a: this->content)
                tmp.emplace_back(a.toMiraiCode());
            return tmp;
        }
        /// @brief 添加元素
        /// @tparam T 任意的SingleMessage的子类
        /// @param a 添加的值
        template<class T>
        void add(const T &a) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只接受SingleMessage的子类");
            this->content.push_back(Message(a));
        }
        void add(const MessageSource &val) {
            this->source = val;
        }
        /// 筛选出某种特点type的信息
        template<class T>
        std::vector<T> filter(int type) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto a: this->content) {
                if (a.type() == type)
                    re.push_back(std::static_pointer_cast<T>(a));
            }
            return re;
        }
        /// 自定义筛选器
        template<class T>
        std::vector<T> filter(const std::function<bool(Message)> &func) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto a: this->content) {
                if (func(a))
                    re.push_back(std::static_pointer_cast<T>(a));
            }
            return re;
        }
        /// 找出第一个指定的type的信息
        template<class T>
        T first(int type) {
            for (auto a: this->content)
                if (a.type() == type)
                    return std::static_pointer_cast<T>(a);
        }
        /// incoming构造器
        template<class... T>
        explicit MessageChain(MessageSource ms, T... args) : source(std::move(ms)) {
            this->p(&this->content, args...);
        };
        /*!
         * @brief 从多个参数构建MessageChain
         * @tparam T 多个传入参数的类型
         * 支持以下类型:
         * - std::string / const char* 相当于传入PlainText
         * - SingleMessage的派生类
         * @param args 参数本身
         */
        template<class... T>
        explicit MessageChain(T... args) {
            p(&this->content, args...);
        };
        /// outcoming 构造器
        template<class T>
        explicit MessageChain(const T &msg) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage子类");
            this->content.push_back(Message(msg));
        };
        template<class T>
        [[nodiscard]] MessageChain plus(const T &a) const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            MessageChain tmp(*this);
            tmp.content.push_back(std::make_shared<SingleMessage>(a));
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageChain &mc) const {
            MessageChain tmp(*this);
            tmp.content.insert(tmp.content.end(), mc.content.begin(), mc.content.end());
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageSource &ms) const {
            MessageChain tmp(*this);
            tmp.source = ms;
            return tmp;
        }
        template<class T>
        MessageChain operator+(const T &msg) const {
            return this->plus(msg);
        }
        Message operator[](size_t i) const {
            return this->content[i];
        }
        bool operator==(const MessageChain &mc) const {
            if (this->content.size() != mc.content.size())
                return false;
            for (size_t i = 0; i < this->content.size(); i++) {
                if (this->content[i] != mc[i])
                    return false;
            }
            return true;
        }
        bool operator!=(const MessageChain &mc) const {
            return !(*this == mc);
        }
        bool empty() const {
            if (this->content.empty() || toMiraiCode().empty())
                return true;
            return false;
        }
        /// @brief 回复并发送
        /// @param s 内容
        /// @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
        /// @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
        /// @detail 支持以下类型传入
        /// - std::string / const char* 相当于传入PlainText(str)
        /// - SingleMessage的各种派生类
        /// - MessageChain
        /// @deprecated use Contact.quoteAndSend or `this->quoteAndSend1(s, groupid, env)`, since v2.8.1
        template<class T>
        [[deprecated("use Contact.quoteAndSend")]] MessageSource
        quoteAndSendMessage(T s, QQID groupid = -1, JNIEnv *env = nullptr) = delete;
        /// 从miraicode string构建MessageChain
        static MessageChain deserializationFromMiraiCode(const std::string &m);
        static MessageChain deserializationFromMessageSourceJson(const std::string &msg, bool origin = true) {
            return deserializationFromMessageSourceJson(nlohmann::json::parse(msg), origin);
        }
        /// 从MessageSource json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageSourceJson(const nlohmann::json &j, bool origin = true);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGECHAIN_H
#ifndef MIRAICP_PRO_MESSAGESOURCE_H
#define MIRAICP_PRO_MESSAGESOURCE_H
#include <string>
#include <jni.h>
namespace MiraiCP {
    class MiraiCodeable; // forward declaration
    using QQID = unsigned long long;
    /*! 消息源声明
     * @example 撤回信息(check in version 2.9.0)
     * @code
     * Event::processor.registerEvent<GroupMessageEvent>([](GroupMessageEvent e) {
        e.message.source.value().recall();
        e.group.sendMessage("hi").recall();
        });
     * @endcode
    */
    class MessageSource {
    public:
        /// 消息的ids
        std::string ids;
        /// 消息的internalids
        std::string internalids;
        /// 消息源序列化
        std::string source;
        MessageSource() = default;
        /// @deprecated 用Contact.quoteAndSendMessage, since v2.8.1
        [[deprecated("Use Contact.quoteAndSendMessage")]] MessageSource
        quoteAndSendMiraiCode(MiraiCodeable *msg, QQID groupid = 0,
                              JNIEnv *env = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        [[deprecated("Use Contact.quoteAndSendMessage")]] MessageSource
        quoteAndSendMsg(const std::string &c, QQID groupid = 0,
                        JNIEnv * = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        [[deprecated("Use Contact.quoteAndSendMessage")]] MessageSource
        quoteAndSendMiraiCode(const std::string &c, QQID groupid = 0,
                              JNIEnv * = nullptr) const = delete;
        /*!
         * @brief 构建消息源
         * @param ids
         * @param internalids
         * @param source
         */
        MessageSource(std::string ids, std::string internalids, std::string source);
        /*!
         * @brief 从json字符串反序列化到MessageSource对象
         * @note json应该为以下格式
         * @code
         * {"ids":"", "internalids":""}
         * @endcode
         */
        static MessageSource deserializeFromString(const std::string &source);
        std::string serializeToString() const;
        /// @brief 撤回该信息
        void recall(JNIEnv * = nullptr) const;
        bool operator==(const MessageSource &ms) const {
            return this->ids == ms.ids && this->internalids == ms.internalids;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGESOURCE_H
#ifndef MIRAICP_PRO_MIRAICODE_H
#define MIRAICP_PRO_MIRAICODE_H
#include <string>
namespace MiraiCP {
    /// MiraiCode父类, 指可以被转换成miraicode的类型
    class MiraiCodeable {
    public:
        /// 返回MiraiCode
        virtual std::string toMiraiCode() const = 0;
    };
    /// @brief miraicode字符串
    /// @attention MiraiCode会把非miraicode组成部分(非[mirai:])转码, 输出转码前的文本用toString, 参考: https://github.com/mamoe/mirai/blob/dev/docs/Messages.md#%E8%BD%AC%E4%B9%89%E8%A7%84%E5%88%99
    /// @detail 为了便捷使用，构造函数不以explicit注释
    class MiraiCode : public MiraiCodeable {
    private:
        std::string content;
    public:
        /// 输出当前内容, 会自动转码
        std::string toString();
        /// 和toString作用一样, 不过不会自动转码
        std::string toMiraiCode() const override {
            return content;
        }
        /// 从MiraiCodeable类型初始化一个miraicode字符串
        MiraiCode(MiraiCodeable *a) { // NOLINT(google-explicit-constructor)
            content = a->toMiraiCode();
        }
        /// 从文本初始化一个miraicode字符串, 根据第二个参数决定是否转码, 默认不转码
        /// @attention 如果是传入文本MiraiCode，请勿转码，转码只是为了[mirai:xxx:<应该转码的部分>], 如果<应该转码>的部分里面含有'[]:,'内容，请调用Tools::escapeToMiraiCode转码
        MiraiCode(const std::string &a, bool convert = false);
        MiraiCode operator+(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode operator+(const std::string &a) {
            return {content + a};
        }
        MiraiCode operator+(const MiraiCode &a) {
            return {content + a.content};
        }
        MiraiCode operator+(MiraiCode *a) {
            return {content + a->content};
        }
        MiraiCode &operator=(const std::string &a) {
            this->content = a;
            return *this;
        }
        MiraiCode plus(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode plus(const std::string &a) {
            return MiraiCode(a) + this;
        }
        /// 不执行转义，适用于已经被MiraiCode转义过的字符串
        static MiraiCode MiraiCodeWithoutEscape(const std::string &a) {
            return {a, false};
        }
        /// 不执行转义，因为MiraiCodeable的toMiraiCode已经转义过了
        static MiraiCode MiraiCodeWithoutEscape(MiraiCodeable *a) {
            return {a->toMiraiCode(), false};
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MIRAICODE_H
#ifndef MIRAICP_PRO_PLUGINCONFIG_H
#define MIRAICP_PRO_PLUGINCONFIG_H
#include <json.hpp>
namespace MiraiCP {
    class PluginConfig {
    public:
        /// @brief 插件id, 要与别人不一样否则报错无法加载(建议用类包格式，如: io.github.nambers)
        std::string id;
        /// @brief 插件名称
        std::string name;
        /// @brief 插件版本
        std::string version;
        /// @brief 插件作者(及联系方式)
        std::string author;
        /// @brief [optional]插件描述
        std::string description;
        /// @brief [optional]构建时间, 默认为__DATE__宏
        std::string time;
        PluginConfig(std::string id,
                     std::string name,
                     std::string version,
                     std::string author,
                     std::string description = "",
                     std::string time = __DATE__)
            : id(std::move(id)),
              name(std::move(name)),
              version(std::move(version)),
              author(std::move(author)),
              description(std::move(description)),
              time(std::move(time)) {}
        nlohmann::json serialize();
        std::string serialize2string() {
            return serialize().dump();
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_PLUGINCONFIG_H
#ifndef MIRAICP_PRO_SINGLEMESSAGE_H
#define MIRAICP_PRO_SINGLEMESSAGE_H
#include <array>
#include <json.hpp>
#include <optional>
#include <sstream>
// #include "MessageSource.h"
// #include "MiraiCode.h"
namespace MiraiCP {
    /// 用serviceMessage的分享信息
    struct URLSharer {
        /// 简介 没点进来看见的样子
        std::string brief = "简介 没点进来看见的样子";
        /// 目标url
        std::string url = "目标url";
        /// 图标地址
        std::string cover = "图标地址";
        /// 标题
        std::string title = "标题";
        /// 描述文字
        std::string summary = "描述文字";
    };
    /// MessageChain的组成部分
    class SingleMessage : public MiraiCodeable {
    public:
        virtual ~SingleMessage() = default;
        static std::unordered_map<int, std::string> messageType;
        virtual nlohmann::json toJson() const {
            nlohmann::json re;
            re["key"] = "miraicode";
            re["content"] = this->toMiraiCode();
            return re;
        }
        /// @brief 找对应类型的index key
        /// @param value 类型名
        /// @return 如果没找到返回-1
        static int getKey(const std::string &value);
        /// MiraiCode类别
        /// @see SingleMessage::messageType
        int type;
        std::string content;
        std::string prefix;
        std::string toMiraiCode() const override;
        bool operator==(const SingleMessage &m) const {
            return this->type == m.type && this->toMiraiCode() == m.toMiraiCode();
        }
        bool operator==(SingleMessage *m) const {
            return this->type == m->type && this->toMiraiCode() == m->toMiraiCode();
        }
        /// @brief 构建单条
        /// @param type 消息类型 @see messageType
        /// @param content 内容
        /// @param prefix 前缀, 默认为`:`, 第二个冒号部分的内容, 目前在serviceMesage有使用
        SingleMessage(int type, std::string content, std::string prefix = ":") : type(type),
                                                                                 content(std::move(content)),
                                                                                 prefix(std::move(prefix)) {}
    };
    /// 纯文本信息
    class PlainText : public SingleMessage {
    public:
        static int type() { return 0; }
        std::string toMiraiCode() const override {
            return content;
        }
        nlohmann::json toJson() const override;
        explicit PlainText(const SingleMessage &sg);
        template<typename T>
        explicit PlainText(const T &a) : SingleMessage(PlainText::type(), ([&a]() -> std::string {
                                                           std::stringstream sst;
                                                           sst << a;
                                                           return sst.str();
                                                       })()) {}
        bool operator==(const PlainText &p) const {
            return this->content == p.content;
        }
    };
    /// @
    class At : public SingleMessage {
    public:
        static int type() { return 1; }
        QQID target;
        nlohmann::json toJson() const override;
        explicit At(const SingleMessage &sg);
        explicit At(QQID a) : SingleMessage(At::type(), std::to_string(a)), target(a){};
        std::string toMiraiCode() const override {
            return "[mirai:at:" + std::to_string(this->target) + "] "; // 后面有个空格
        }
        bool operator==(const At &a) const {
            return this->target == a.target;
        }
    };
    /// @brief \@全体
    class AtAll : public SingleMessage {
    public:
        static int type() { return 2; }
        std::string toMiraiCode() const override {
            return "[mirai:atall] ";
        }
        nlohmann::json toJson() const override;
        AtAll() : SingleMessage(AtAll::type(), "", "") {}
    };
    /// 图像类声明
    class Image : public SingleMessage {
    public:
        static int type() { return 3; }
        //图片id，样式:` {xxx}.xx `
        std::string id;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> md5;
        /// 可为0, 来源:用`refreshInfo`可能可以获取或者自己填充, 是isUploaded的必须条件, 默认0
        size_t size;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> url;
        /// 宽度, 默认0, 单位px
        int width;
        /// 长度, 默认0, 单位px
        int height;
        /*!
         * @brief 图片类型
         *  - 0 png
         *  - 1 bmp
         *  - 2 jpg
         *  - 3 gif
         *  - 4 apng
         *  - 5 unknown
         *  默认 5
         */
        int imageType;
        /*!
         * @brief 图片是否已经上传(如果已经上传即表明可以直接用ImageId发送, 如果没有需要手动上传)
         * @param md5 在kotlin端会用.toByteArray()转换
         * @param size 图片大小, 不能为0
         * @param botid 所属Botid
         * @return 是否已上传
         */
        bool isUploaded(QQID botid, JNIEnv *env = nullptr);
        /*!
        * @brief 从图片builder构造，适用于服务器上已经有的图片，即接收到的
        * @param imageId 图片id, 必须
        * @param size isUploaded的必要条件, 单纯用ImageId可能取不到图片size, 需要自己上传
        * @param width 宽度
        * @param height 长度
        * @param type 图片类型
        * @detail 图片miraiCode格式例子, `[mirai:image:{图片id}.jpg]`
        * 可以用这个正则表达式找出id `\\[mirai:image:(.*?)\\]`
        */
        explicit Image(const std::string &imageId, size_t size = 0, int width = 0, int height = 0, int type = 5) : SingleMessage(Image::type(), imageId) {
            this->id = imageId;
            this->size = size;
            this->width = width;
            this->height = height;
            this->imageType = type;
        }
        explicit Image(const SingleMessage &sg);
        /// 刷新信息(获取图片下载Url,md5, size)
        void refreshInfo(JNIEnv *env = nullptr);
        /// 取图片Mirai码
        std::string toMiraiCode() const override {
            return "[mirai:image:" + this->id + "]";
        }
        nlohmann::json toJson() const override;
        static Image deserialize(const std::string &);
        bool operator==(const Image &i) const {
            return this->id == i.id;
        }
    };
    /// 闪照, 和Image属性类似
    class FlashImage : public Image {
    public:
        static int type() { return 8; }
        std::string toMiraiCode() const override {
            return "[mirai:flash:" + this->id + "]";
        }
        explicit FlashImage(const std::string &imageId, size_t size = 0, int width = 0, int height = 0, int type = 0) : Image(imageId, size, width, height, type) {
            this->SingleMessage::type = 8;
        }
        explicit FlashImage(const SingleMessage &sg) : Image(sg) {}
        explicit FlashImage(const Image &img) : Image(img) {}
        nlohmann::json toJson() const override;
        static FlashImage deserialize(const std::string &);
        bool operator==(const FlashImage &i) const {
            return this->id == i.id;
        }
        /// 转换到普通图片
        Image toImage() { return Image(id, size, width, height, imageType); }
    };
    /*!
    * @brief 小程序卡片
    * @see LightAppStyle1, LightAppStyle2, LightAppStyle3
    * @attention 自带的模板不稳定，可能发出现没有效果
    * @example 通过常量构建并发送小程序卡片
    * @code
 * Event::processor.registerEvent([](GroupMessageEvent e) {
		//修改里面的属性从而自定义
		LightAppStyle1 a = LightAppStyle1();
		LightAppStyle2 b = LightAppStyle2();
		LightAppStyle3 c = LightAppStyle3();
		e.group.SendMiraiCode(LightApp(a).toMiraiCode());
		e.group.SendMiraiCode(LightApp(b).toMiraiCode());
		e.group.SendMiraiCode(LightApp(c).toMiraiCode());
	});
    * @endcode
    * @example 通过文本构建并发送小程序卡片
    * @code
 * Event::processor.registerEvent([](GroupMessageEvent e) {
		//风格1，适合文字展示，不能交互,无大图
		//图标地址，应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string icon = "http://gchat.qpic.cn/gchatpic_new/1924306130/1044565129-2580521429-8ECE44863FC01DBD17FB8A177B355356/0";
		//小标题
		string titles = "{\"title\":\"hi\", \"value\":\"test3\"}";
		//下面的按钮，但是不能按
		string buttons = "{\"name\":\"Test4\",\"action\":\"plugin\",\"actionData\":\"https://baidu.com\"}";
		string x = "{\"app\":\"com.tencent.miniapp\",\"desc\":\"\",\"view\":\"notification\",\"ver\":\"0.0.0.1\",\"prompt\":\"[应用]\",\"appID\":\"\",\"sourceName\":\"\",\"actionData\":\"\",\"actionData_A\":\"\",\"sourceUrl\":\"\",\"meta\":{\"notification\":{\"appInfo\":"
			"{\"appName\":\"Test1\",\"appType\":4,\"appid\":1109659848,"
			"\"iconUrl\":\""+icon+"\"},"
			"\"data\":["+titles+"],"
			"\"title\":\"Test2\",\"button\":"
			"["+buttons+"],"
			"\"emphasis_keyword\":\"\"}},\"text\":\"\",\"sourceAd\":\"\"}";
		e.group.SendMiraiCode(LightApp(x).toString());
		//风格2，不能交互，有预览图
		//icon图标,应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string icon1 = "http://gchat.qpic.cn/gchatpic_new/1924306130/1044565129-2580521429-8ECE44863FC01DBD17FB8A177B355356/0";
		//预览图(大图),应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string preview1 = icon1;
		string a = "{\"config\":"
			"{\"height\":0,\"forward\":1,\"ctime\":0,\"width\":0,\"type\":\"normal\",\"token\":\"\",\"autoSize\":0},"
			"\"prompt\":\"[QQ小程序]\",\"app\":\"com.tencent.miniapp_01\",\"ver\":\"1.0.0.103\",\"view\":\"view_8C8E89B49BE609866298ADDFF2DBABA4\","
			"\"meta\":{\"detail_1\":{\"appid\":\"1110081493\",\"preview\":\""+preview1+"\",\"shareTemplateData\":{},"
			"\"gamePointsUrl\":\"\",\"gamePoints\":\"\",\"url\":\"m.q.qq.com\",\"scene\":0,\"desc\":\"Test5\",\"title\":\"Test6\","
			"\"host\":{\"uin\":1000000,\"nick\":\"应用消息\"},"
			"\"shareTemplateId\":\"8C8E89B49BE609866298ADDFF2DBABA4\",\"icon\":\""+icon1+"\",\"showLittleTail\":\"\"}},\"desc\":\"\"}";
		e.group.SendMiraiCode(LightApp(a).toString());
		//风格3，可以跳转到网址，有预览图
		//跳转链接
		string url = "https://www.baidu.com";
		//icon图标,应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string icon2 = "http://gchat.qpic.cn/gchatpic_new/1924306130/1044565129-2580521429-8ECE44863FC01DBD17FB8A177B355356/0";
		//预览图(大图),应该是要qq的服务器里有的图片，也就是说先上传(发送)图片然后取下载链接
		string preview = icon2;
		string b = "{\"config\":{\"height\":0,\"forward\":1,\"ctime\":0,\"width\":0,\"type\":\"normal\",\"token\":\"\",\"autoSize\":0},"
			"\"prompt\":\"[QQ小程序]\",\"app\":\"com.tencent.miniapp_01\",\"ver\":\"0.0.0.1\",\"view\":\"view_8C8E89B49BE609866298ADDFF2DBABA4\","
			"\"meta\":{\"detail_1\":{\"appid\":\"1109937557\",\"preview\":\""+preview+"\",\"shareTemplateData\":{},\"gamePointsUrl\":\"\",\"gamePoints\":\"\",\"url\":\"m.q.qq.com\",\"scene\":0,\"desc\":\"Test1\",\"title\":\"Test3\",\"host\":{\"uin\":0,\"nick\":\"\"},\"shareTemplateId\":\"8C8E89B49BE609866298ADDFF2DBABA4\",\"icon\":\""+icon+"\",\"qqdocurl\":\""+url+"\",\"showLittleTail\":\"\"}},\"desc\":\"\"}";
		e.group.SendMiraiCode(LightApp(b).toString());
		});
    * @endcode
    */
    class LightApp : public SingleMessage {
    public:
        static int type() { return 4; }
        /// @brief 使用纯文本构造，推荐使用其他结构体方法构造
        /// @param content 构造文本
        explicit LightApp(std::string content) : SingleMessage(LightApp::type(), std::move(content)) {}
        explicit LightApp(const SingleMessage &sg);
        nlohmann::json toJson() const override;
        /// 返回miraicode
        std::string toMiraiCode() const override;
        bool operator==(const LightApp &la) const {
            return this->content == la.content;
        }
    };
    /// xml格式的超文本信息
    /// @attention 自带的模板不稳定，可能发出现没有效果
    class ServiceMessage : public SingleMessage {
    public:
        static int type() { return 5; }
        nlohmann::json toJson() const override;
        std::string toMiraiCode() const override;
        int id;
        /// @brief ServiceMessage
        /// @param id 在xml内容前面的id (不包括逗号)
        /// @param a xml内容 (不需要事先转码到miraiCode)
        explicit ServiceMessage(int id, std::string a) : SingleMessage(ServiceMessage::type(), std::move(a),
                                                                       ":" + std::to_string(id) + ','),
                                                         id(id) {}
        explicit ServiceMessage(const SingleMessage &sg);
        explicit ServiceMessage(const URLSharer &a) : SingleMessage(5,
                                                                    "<?xml version=\"1.0\" encoding=\"utf-8\"?><msg templateID=\"12345\" action=\"web\" brief=\"" +
                                                                            a.brief + "\" serviceID=\"1\" url=\"" + a.url +
                                                                            "\"><item layout=\"2\"><picture cover=\"" +
                                                                            a.cover + "\"/><title>" + a.title +
                                                                            "</title><summary>" + a.summary +
                                                                            "</summary></item><source/></msg>",
                                                                    ":1,"),
                                                      id(1) {}
        bool operator==(const ServiceMessage &s) const {
            return this->content == s.content;
        }
    };
    /// 引用信息
    class QuoteReply : public SingleMessage {
    public:
        static int type() { return -2; }
        // 不可直接发送, 发送引用信息用MessageChain.quoteAndSendMessage
        ShouldNotUse("don't have MiraiCode, use MessageChain.quote instead") std::string toMiraiCode() const override {
            return "";
        }
        /// 引用信息的MessageSource
        MessageSource source;
        explicit QuoteReply(const SingleMessage &m);
        explicit QuoteReply(MessageSource source) : SingleMessage(QuoteReply::type(), source.serializeToString()), source(std::move(source)){};
        bool operator==(const QuoteReply &qr) const {
            return this->source == qr.source;
        }
    };
    /// 接收到的音频文件, 发送用`Contact.sendAudio`
    class OnlineAudio : public SingleMessage {
    public:
        static int type() { return -3; }
        /// 文件名
        std::string filename;
        /// 下载地址
        std::string url;
        /// 文件大小
        int size;
        /// 编码方式
        int codec;
        /// 时长(单位s)
        int length;
        /// 16位md5
        std::array<uint8_t, 16> md5;
        /// 不支持直接发送, 用Contact.sendAudio
        [[deprecated("cannot use, use Contact.sendAudio")]] std::string toMiraiCode() const override {
            return "";
        }
        explicit OnlineAudio(std::string f, std::array<uint8_t, 16> md5, int size, int codec, int length,
                             std::string url) : SingleMessage(OnlineAudio::type(), ""),
                                                filename(std::move(f)), md5(md5), size(size), codec(codec),
                                                length(length), url(std::move(url)){};
        bool operator==(const OnlineAudio &oa) const {
            return this->md5 == oa.md5;
        }
    };
    /// @brief 远程(群)文件类型
    class RemoteFile : public SingleMessage {
    public:
        static int type() { return 6; }
        /// @brief 下载信息
        /// @see RemoteFile
        struct Dinfo {
            /// 下载地址, 可能会是 `null` 当文件不存在
            std::string url;
            /// md5 可用于校验
            std::string md5;
            /// sha1 可用于校验
            std::string sha1;
        };
        /// @brief 文件信息
        /// @see RemoteFile
        struct Finfo {
            /// 文件大小
            QQID size;
            /// 上传者id
            QQID uploaderid;
            /// 过期时间
            long expirytime;
            /// 上传时间, 时间戳格式
            QQID uploadtime;
            /// 上次更改时间, 时间戳格式
            QQID lastmodifytime;
        };
        /// 文件唯一id, 用于识别
        std::string id;
        /// 文件内部id, 用于构造miraiCode发送
        unsigned int internalid;
        /// 文件名
        std::string name;
        /// 文件大小
        long long size;
        /// 文件在群文件的路径
        /// @attention 可能为空(通常出现于MessageChain从MiraiCode反序列化), 需要从Group重新获取文件
        /// @see Group::getFileByFile
        std::optional<std::string> path;
        /// 文件下载信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Dinfo, Group::getFileByFile
        std::optional<Dinfo> dinfo;
        /// 文件信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Finfo, Group::getFileByFile
        std::optional<Finfo> finfo;
        std::string serializeToString();
        RemoteFile plus(unsigned int ii);
        static RemoteFile deserializeFromString(const std::string &source);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalids
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p, struct Dinfo d, struct Finfo f);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalids
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s);
        /// 上传后会自动发送
        [[deprecated("Cannot send manually, use Group.sendFile")]] std::string toMiraiCode() const override {
            return "";
        }
        bool operator==(const RemoteFile &rf) const {
            return this->id == rf.id;
        }
    };
    /// 自带表情
    /// @attention 有些表情会变成PlainText类型和\\xxx 的格式
    class Face : public SingleMessage {
    public:
        static int type() { return 7; }
        int id;
        nlohmann::json toJson() const override;
        std::string toMiraiCode() const override {
            return "[mirai:face:" + std::to_string(id) + "]";
        }
        explicit Face(int id) : SingleMessage(Face::type(), std::to_string(id)), id(id) {}
        bool operator==(const Face &f) const {
            return this->id == f.id;
        }
    };
    /// 一些可以被mirai识别的音乐卡片, 如果不能被mirai识别, 那应该被表现成lightApp类型(可能收费/vip歌曲用lightApp, 免费用MusicShare)
    class MusicShare : public SingleMessage {
    public:
        static int type() { return 9; }
        /// 应用名称, 如NeteaseCloudMusic
        std::string appName;
        /// 歌名
        std::string title;
        /// 卡片第二行的文字内容
        std::string summary;
        /// 点击跳转到的链接
        std::string jumpUrl;
        /// 图片链接
        std::string picUrl;
        /// 音乐文件链接
        std::string musicUrl;
        /// 简介, 点进聊天节目前显示的小文字, 一般是`分享`
        std::string brief;
        std::string toMiraiCode() const override {
            return "[mirai:musicshare:" + appName + "," + title + "," + summary + "," + jumpUrl + "," + picUrl + "," + musicUrl + "," + brief + "]";
        }
        MusicShare(const std::string &appName, const std::string &title, const std::string &summary, const std::string &jumpUrl, const std::string &picUrl, const std::string &musicUrl, const std::string &brief) : SingleMessage(MusicShare::type(), ""), appName(appName), title(title), summary(summary), jumpUrl(jumpUrl), picUrl(picUrl), musicUrl(musicUrl), brief(brief) {}
    };
    class MarketFace : public SingleMessage {
    public:
        static int type() { return -5; }
        /// 目前无法直接发送MarketFace, 可以转发
        [[deprecated("暂不支持直接发送")]] std::string toMiraiCode() const override {
            return "";
        }
        std::array<uint8_t, 16> faceId;
        explicit MarketFace(std::array<uint8_t, 16> id) : SingleMessage(MarketFace::type(), ""), faceId(id) {}
        bool operator==(const MarketFace &mf) const {
            return this->faceId == mf.faceId;
        }
    };
    /// @brief 目前不支持的消息类型, 不支持发送
    class UnSupportMessage : public SingleMessage {
    public:
        static int type() { return -1; }
        nlohmann::json toJson() const override;
        /// 不支持发送
        [[deprecated("不支持直接发送UnSupportMessage")]] std::string toMiraiCode() const override {
            return "";
        }
        explicit UnSupportMessage(const SingleMessage &s) : SingleMessage(s){};
        explicit UnSupportMessage(const std::string &content) : SingleMessage(UnSupportMessage::type(), content) {}
        bool operator==(const UnSupportMessage &m) const {
            return this->content == m.content;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_SINGLEMESSAGE_H
#ifndef MIRAICP_PRO_THREADMANAGER_H
#define MIRAICP_PRO_THREADMANAGER_H
#include <jni.h>
#include <map>
#include <mutex>
#include <sstream>
#include <thread>
namespace MiraiCP {
    using QQID = unsigned long long;
    /*!
    * @class threadManager
    * @brief 多线程管理.
    * @example 多线程管理
     * @code
     * void func(){
     *      //do some things
     *      // 一个完整的线程应该在结束时调用detach来释放env的空间
     *      ThreadManager::detch();
     * }
     * @endcode
    */
    class ThreadManager {
    public:
        /// @brief 每个线程实例.
        struct ThreadInfo {
            JNIEnv *e{};
            bool attach{};
        };
    public:
        // 类静态成员
        static std::map<std::string, ThreadInfo> threads; /// < 线程池(线程id:env).
        static std::recursive_mutex mtx;                  ///< 线程池读写锁.
        /// @brief 全局JavaVM对象，用于多线程管理中新建线程的JNIEnv.
        static JavaVM *gvm;
        /// @brief JNI 版本.
        static long JNIVersion;
    private:
        ThreadManager() = default;
    private:
        // 私有静态方法
        static void newEnv(const char *threadName = nullptr); ///< 新建一个env，于getEnv中没取到env时调用.
        /// 判断该线程id是否包含在线程池里
        static bool included(const std::string &id);
    public:
        // 静态方法
        /// 获取线程
        static ThreadInfo *getThread() {
            return &threads[getThreadId()];
        }
        /// @brief 获取线程id.
        static std::string getThreadId() {
            auto myid = std::this_thread::get_id();
            std::stringstream ss;
            ss << myid;
            return ss.str();
        }
        /// @brief 设置env给当前线程.
        static void setEnv(JNIEnv *e);
        /*!
         * 	@brief 结束当前线程的env，也就是释放当前线程缓存的env.
         *  @note 不过继续调用getEnv()将再次获取，所以本方法调用后线程也可以通过getEnv重新获取一个env，本方法的作用就是在结束后释放空间
         */
        static void detach();
        /// @brief 取env,如果不存在重新获取
        /// @internal 一般为`miraicp`内部调用jni接口时调用
        /// @param file 为支持`StackTracer`而增加, 为`__FILE__`宏(文件名), 在调用处传入因为当__FILE__作为默认参数传入时不准确
        /// @param loc 为`__LINE__`宏(行号), 同上
        /// @param func 为`__FUNC__`宏(方法名)
        static JNIEnv *getEnv();
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_THREADMANAGER_H
#ifndef MIRAICP_PRO_TOOLS_H
#define MIRAICP_PRO_TOOLS_H
#include <functional>
#include <jni.h>
#include <sstream>
#include <string>
#include <vector>
#if defined(__clang__) || defined(__GNUC__)
#define MIRAICP_CPP_STANDARD __cplusplus
#elif defined(_MSC_VER)
#define MIRAICP_CPP_STANDARD _MSVC_LANG
#endif
#define MiraiCP_defer(code)                              \
    auto __defered_statement_wrapper__ = [&]() { code }; \
    Tools::MiraiCPDefer<void> __defered_object__(__defered_statement_wrapper__);
//#if MIRAICP_CPP_STANDARD >= 201703L
//#define get_return_type std::invoke_result_t
//#else
//#define get_return_type std::result_of_t
//#endif
namespace MiraiCP {
    /// @brief 工具类声明, 常用的一些转换工具, 如需转码使用std::filesystem
    /// @class Tools
    namespace Tools {
        /*!
         * @name jstring2str
         * @brief string类型转码转换到jstring类型, UTF16 -> UTF8
         * @note 来源https://blog.csdn.net/chunleixiahe/article/details/51394116
         * @param jstr 转换内容,jstring类型
         * @param env 可选，JNIEnv
         * @return 内容转换成jstring类型
         */
        std::string jstring2str(jstring jstr, JNIEnv * = nullptr);
        /*!
         * @name str2jstring
         * @brief string类型到jsting类型 UTF8 -> UTF16
         * @note 来源https://blog.csdn.net/chunleixiahe/article/details/51394116
         * @param stra const char*(string.c_str()转换的内容)
         * @param env 可选JNIEnv
         * @return 转换后jstring类型
         */
        jstring str2jstring(const char *stra, JNIEnv * = nullptr);
        /*!
         * @brief 替换全部在一个字符串中.
         * @param str 原字符串.
         * @param from 需要被替换的字符.
         * @param to 替换到的字符.
         * @return 返回替换后的字符串.
         * @note 来源:https://stackoverflow.com/a/24315631/14646226
         */
        std::string replace(std::string str, std::string_view from, std::string_view to);
        /// @brief long long 类型的vector格式化输出
        /// @param a vector
        /// @return string
        template<typename T>
        std::string VectorToString(std::vector<T> a, const std::string &separator = ",") {
            std::stringstream ss;
            for (size_t i = 0; i < a.size(); ++i) {
                if (i != 0)
                    ss << separator;
                ss << a[i];
            }
            std::string s = ss.str();
            return s;
        }
        /// @brief 从string格式化到vector
        /// @param temp string
        /// @return vector
        std::vector<unsigned long long> StringToVector(std::string temp);
        /// @brief 从miraicode转义到正常
        /// @param s 经过miraicode转义的字符串
        /// @return 原字符串
        std::string escapeFromMiraiCode(const std::string &s);
        /// @brief 转义miraicode格式
        std::string escapeToMiraiCode(const std::string &s);
        /// starts_with, from <https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a>
        bool starts_with(std::string_view f, std::string_view s);
        /// compare char with case-insensitive
        bool icompareChar(const char &c1, const char &c2);
        /// case insensitive string compare from https://thispointer.com/c-case-insensitive-string-comparison-using-stl-c11-boost-library/
        bool iequal(std::string_view str1, std::string_view str2);
        /// from https://www.zhihu.com/question/36642771, delim is regex(ignore last `+`)
        std::vector<std::string> split(const std::string &text, const std::string &delim);
        /// defer class
        /// @see MiraiCP_defer
        template<typename RT_TYPE>
        class MiraiCPDefer {
        public:
            std::function<RT_TYPE()> defer_func;
            template<class F>
            MiraiCPDefer(F &&func) : defer_func(func) {
            }
            virtual ~MiraiCPDefer() {
                defer_func();
            }
        };
    }; // namespace Tools
} // namespace MiraiCP
// #undef get_return_type
#endif //MIRAICP_PRO_TOOLS_H
#ifndef MIRAICP_PRO_UTILS_H
#define MIRAICP_PRO_UTILS_H
// #include "CPPPlugin.h"
// #include "Config.h"
namespace MiraiCP {
    const std::string MiraiCPVersion = "v2.11.0-M1";
    /*!
     * @brief 定时任务, 在一定时间后广播**一次**TimeOutEvent
     * @param time 在多少毫秒后执行
     * @param msg 附加的string类型信息
     * @example 100ms后发一条消息
     * @code
     *  nlohmann::json j;
        j["type"] = 1;
        j["id"] = 111;
        j["bid"] = 111;
        schedule(100, j.dump());
        Event::processor.registerEvent<TimeOutEvent>([](TimeOutEvent e){
            nlohmann::json j = nlohmann::json::parse(e.msg);
            if(j["type"] == 1)
                Group(j["id"], j["bid"]).sendMessage("");
        });
     * @code
     */
    inline void schedule(long time, const std::string &msg, JNIEnv *env = nullptr) {
        nlohmann::json j;
        j["time"] = time;
        j["msg"] = msg;
        Config::koperation(Config::TimeOut, j, env);
    }
    void enrollPlugin();
    inline void enrollPlugin0(CPPPlugin *p) {
        CPPPlugin::plugin = p;
    }
} // namespace MiraiCP
#endif //MIRAICP_PRO_UTILS_H
