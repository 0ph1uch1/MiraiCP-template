// This file is generated automatically by amalgamate;
// GitHub repo https://github.com/edlund/amalgamate
// When contributing to this repository, please DO NOT edit this file.
// Copyright (C) 2020-2021 Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#pragma clang diagnostic push
#pragma ide diagnostic ignored "bugprone-macro-parentheses"
#ifndef MIRAICP_PRO_MIRAICPMACROS_H
#define MIRAICP_PRO_MIRAICPMACROS_H
// This file contains static assertions and macros.
// If any macro is used, one should always include this file directly or indirectly.
// Dev: any new macro(s) should be added here since we have to ensure the "single" target
// behaves just the same as "multi". If any macro infected the pre-compilation in "single",
// we will know immediately in "multi".
static_assert(sizeof(void *) == 8, "Only 64-bit platforms are supported");
static_assert(sizeof(char) == 1, "Please make sure the size of char is 1");
// detect platform, pre-define default value
#define MIRAICP_WINDOWS 0
#define MIRAICP_LINUX 0
#define MIRAICP_UNIX 0
#define MIRAICP_IOS 0
#define MIRAICP_MACOS 0
#define MIRAICP_ANDROID 0
#define MIRAICP_TERMUX 0
// detect platform
// ref: https://stackoverflow.com/questions/5919996/how-to-detect-reliably-mac-os-x-ios-linux-windows-in-c-preprocessor
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#undef MIRAICP_WINDOWS
#define MIRAICP_WINDOWS 1
#elif __APPLE__
#include <TargetConditionals.h>
#if TARGET_IPHONE_SIMULATOR || TARGET_OS_MACCATALYST || TARGET_OS_IPHONE
#undef MIRAICP_IOS
#define MIRAICP_IOS 1
#elif TARGET_OS_MAC
#undef MIRAICP_MACOS
#define MIRAICP_MACOS 1
#else
static_assert(false, "Unknown apple platform");
#endif
#elif __ANDROID__
#ifdef __TERMUX__
#undef MIRAICP_TERMUX
#define MIRAICP_TERMUX 1
#else
#undef MIRAICP_ANDROID
#define MIRAICP_ANDROID 1
#endif
#elif __linux__
#undef MIRAICP_LINUX
#define MIRAICP_LINUX 1
#elif __unix__
#undef MIRAICP_UNIX
#define MIRAICP_UNIX 1
#else
static_assert(false, "Unsupported platform");
#endif
// compiler
#define MIRAICP_MSVC 0
#define MIRAICP_CLANG 0
#define MIRAICP_GCC 0
#define MIRAICP_COMPILER_OTHER 0
#if defined(_MSC_VER) // MSVC
#undef MIRAICP_MSVC
#define MIRAICP_MSVC 1
#elif defined(__clang__) // clang
#undef MIRAICP_CLANG
#define MIRAICP_CLANG 1
#elif defined(__GNUC__) // GNUC, MinGW
#undef MIRAICP_GCC
#define MIRAICP_GCC 1
#else
#undef MIRAICP_COMPILER_OTHER
#define MIRAICP_COMPILER_OTHER 1
#endif
// ShouldNotUse
#if MIRAICP_MSVC
#pragma warning(error : 4996)
#define ShouldNotUse(msg) [[deprecated(msg)]]
#elif MIRAICP_GCC
#define ShouldNotUse(msg) [[deprecated(msg)]] __attribute__((error(msg)))
#else
#define ShouldNotUse(msg)
#endif
// assert
#include <cassert>
#ifndef assert
#define assert(ignore) ((void) 0)
#endif
// exceptions
#define MIRAICP_EXCEPTION_WHERE __FILE__, __LINE__
#define MIRAICP_THROW(T, ...) throw T(__VA_ARGS__, MIRAICP_EXCEPTION_WHERE)
// status codes
#define PLUGIN_NORMAL 0
#define PLUGIN_ERROR 1
// noexcept statements block
#define MIRAICP_CRITICAL_NOEXCEPT_BLOCK(statements) \
    try {                                           \
        statements                                  \
    } catch (...) { return PLUGIN_ERROR; }
// token paste and stringify
#define TOKEN_PASTE_INNER(X, Y) X##Y
#define TOKEN_PASTE(X, Y) TOKEN_PASTE_INNER(X, Y)
#define STRINGIFY(A) __STRINGIFY(A)
#ifndef __STRINGIFY
#define __STRINGIFY(A) #A // NOLINT(bugprone-reserved-identifier)
#endif
// defer tool, works like the defer key word in Golang.
#define MIRAICP_DEFER(code)                                                   \
    auto TOKEN_PASTE(_defered_statement_wrapper_, __LINE__) = [&]() { code }; \
    CommonTools::MiraiCPDefer TOKEN_PASTE(_defered_object_, __LINE__)(std::move(TOKEN_PASTE(_defered_statement_wrapper_, __LINE__)))
#define MIRAICP_DEFER_LAMBDA(lambda)                                  \
    auto TOKEN_PASTE(_defered_statement_wrapper_, __LINE__) = lambda; \
    CommonTools::MiraiCPDefer TOKEN_PASTE(_defered_object_, __LINE__)(std::move(TOKEN_PASTE(_defered_statement_wrapper_, __LINE__)))
// names of plugin entry points
#define FUNC_ENTRANCE FUNC_ENTRANCE
#define FUNC_EVENT FUNC_EVENT
#define FUNC_EXIT FUNC_EXIT
#define PLUGIN_INFO PLUGIN_INFO
// error handling
#ifdef MIRAICP_LIB_SDK
#define MIRAICP_ERROR_HANDLE(x, y) ErrorHandle0(__FILE__, __LINE__, (x), (y))
#endif
// export
#define MIRAICP_EXPORT
#if MIRAICP_WINDOWS
#ifdef GOOGLE_TEST
#undef MIRAICP_EXPORT
#define MIRAICP_EXPORT __declspec(dllimport)
#else
#undef MIRAICP_EXPORT
#define MIRAICP_EXPORT __declspec(dllexport)
#endif
#else
#ifndef GOOGLE_TEST
#undef MIRAICP_EXPORT
#define MIRAICP_EXPORT __attribute__((visibility("default")))
#endif
#endif
// data locker
#define MIRAICP_DATALOCK std::shared_lock<std::shared_mutex> TOKEN_PASTE(local_lck_, __LINE__)(InternalData->getMutex())
// getter
// need to define macro LOC_CLASS_NAMESPACE to the class first!
#define DECL_GETTER(attr) decltype(DataType::_##attr) attr();
#define IMPL_GETTER(attr)                                                          \
    decltype(LOC_CLASS_NAMESPACE::DataType::_##attr) LOC_CLASS_NAMESPACE::attr() { \
        InternalData->requestRefresh();                                            \
        MIRAICP_DATALOCK;                                                          \
        return GetDataInternal()->_##attr;                                         \
    }
#define INLINE_GETTER(attr) \
    auto attr() { return GetDataInternal()->_##attr; }
// api declarer
#define DECL_API(x) decltype(&x) _##x
// operator++ of iterable enum
#define MIRAICP_ITERABLE_ENUM_OPERATOR_PLUSPLUS \
    inline Type &operator++(Type &value) {      \
        value = (Type) ((int) value + 1);       \
        return value;                           \
    }                                           \
    inline Type operator++(Type &value, int) {  \
        Type result = value;                    \
        value = (Type) ((int) value + 1);       \
        return result;                          \
    }
// iterable enum
#define MIRAICP_ITERABLE_ENUM(BeginAt, First, ...) \
    enum Type : int {                              \
        First = BeginAt,                           \
        ##__VA_ARGS__,                             \
        Count,                                     \
        Begin = BeginAt,                           \
        End = Count,                               \
    };                                             \
    MIRAICP_ITERABLE_ENUM_OPERATOR_PLUSPLUS
#endif //MIRAICP_PRO_MIRAICPMACROS_H
#pragma clang diagnostic pop
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MIRAICPSTRINGINTERNAL_H
#define MIRAICP_PRO_MIRAICPSTRINGINTERNAL_H
// #include "MiraiCPMacros.h"
// -----------------------
#include <cassert>
#include <string>
namespace MiraiCP {
    // this class is used to ensure data consistency between dynamic libs
    // note: DO NOT use this directly;
    // always convert to const char* or std::string before using.
    /// @brief MiraiCP内部传递string数据用
    /// @note 请勿使用！
    class MIRAICP_EXPORT MiraiCPString final {
        using string = std::string;
    private:
        static constexpr decltype(&::std::free) std_free_ptr = &::std::free;
    private:
        // to keep integration and safe for empty construction/deconstruction, always initialize here
        char *str = nullptr;
        size_t _size = 0;
        decltype(&::std::free) free_this = std_free_ptr; // specify which free() to use; ensure deconstruction is paired to construction
    public:
        [[nodiscard]] bool isEmpty() const {
            return _size == 0;
        }
        MiraiCPString() = default;
        // call if _size is set to non-zero
        // allocate memory for str
        void construction();
        ~MiraiCPString();
        MiraiCPString(const MiraiCPString &other);
        MiraiCPString(MiraiCPString &&temp) noexcept;
        MiraiCPString(const char *char_str); // NOLINT(google-explicit-constructor)
        MiraiCPString(const std::string &string_str); // NOLINT(google-explicit-constructor)
        [[nodiscard]] std::string toString() const {
            if (str == nullptr || _size == 0) return {};
            return {str};
        }
        operator std::string() const { // NOLINT(google-explicit-constructor)
            return toString();
        }
        // for safe destruction, DO NOT provide move conversion to char*
        // the return value of this method can always be deleted by delete[] and is never nullptr
        [[nodiscard]] const char *copyToCharPtr() const;
        bool operator==(const MiraiCPString &another) const;
        MiraiCPString &operator=(const MiraiCPString &another);
        MiraiCPString &operator=(MiraiCPString &&another) noexcept;
    private:
        void swap(MiraiCPString &other) noexcept;
    };
    static_assert(sizeof(char *) == 8, "Please make sure the size of pointers is 8 bytes");
    static_assert(sizeof(MiraiCPString) == 3 * 8, "Please make sure the size of size_t is 8 bytes");
} // namespace MiraiCP
#endif //MIRAICP_PRO_MIRAICPSTRINGINTERNAL_H
#ifndef MIRAICP_PRO_PLUGINCONFIG_H
#define MIRAICP_PRO_PLUGINCONFIG_H
// #include "MiraiCPStringInternal.h"
#include <json.hpp>
namespace MiraiCP {
    constexpr const char *m_MiraiCPVersion = "v2.13.2";
    inline const std::string MiraiCPVersion = m_MiraiCPVersion;
    struct PluginConfig {
        /// @brief 插件id, 要与别人不一样否则报错无法加载(建议用类包格式，如: io.github.nambers)
        const char *id = nullptr;
        /// @brief 插件名称
        const char *name = nullptr;
        /// @brief 插件版本
        const char *version = nullptr;
        /// @brief 插件作者(及联系方式)
        const char *author = nullptr;
        /// @brief [optional]插件描述
        const char *description = "";
        /// @brief [optional]构建时间, 默认为__DATE__宏
        const char *time = __DATE__;
        const char *mversion = m_MiraiCPVersion;
        std::string getId() const {
            return {id};
        }
        std::string getName() const {
            return {name};
        }
        std::string getVersion() const {
            return {version};
        }
        std::string getAuthor() const {
            return {author};
        }
        std::string getDescription() const {
            return {description};
        }
        std::string getTime() const {
            return {time};
        }
        std::string getMVersion() const {
            return {mversion};
        }
        [[nodiscard]] bool isValid() const {
            return id && name && version && author;
        }
        nlohmann::json serialize();
        std::string serialize2string();
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_PLUGINCONFIG_H
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_THREADIDENTIFY_H
#define MIRAICP_PRO_THREADIDENTIFY_H
#include <string>
namespace ThreadIdentify {
    void IAmPoolThread();
    bool isMePoolThread();
    void IAmLoaderThread();
    bool isMeLoaderThread();
    void setMyThreadName(const std::string &name);
    std::string identifyMe();
} // namespace ThreadIdentify
#endif //MIRAICP_PRO_THREADIDENTIFY_H
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_COMMONTOOLS_H
#define MIRAICP_PRO_COMMONTOOLS_H
// #include "MiraiCPMacros.h"
// -----------------------
#include <functional>
namespace CommonTools {
    /// defer class
    /// @see MIRAICP_DEFER
    class MiraiCPDefer {
    public:
        std::function<void()> defer_func;
        MiraiCPDefer(std::function<void()> func) : defer_func(std::move(func)) {
        }
        ~MiraiCPDefer() {
            defer_func();
        }
    };
} // namespace CommonTools
#endif //MIRAICP_PRO_COMMONTOOLS_H
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_COMMONTYPES_H
#define MIRAICP_PRO_COMMONTYPES_H
// don't create cpp for this header
// #include "MiraiCPMacros.h"
// -----------------------
// #include "PluginConfig.h"
// #include "loaderApiInternal.h"
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_LOADERAPIINTERNAL_H
#define MIRAICP_PRO_LOADERAPIINTERNAL_H
// #include "MiraiCPStringInternal.h"
#ifdef MIRAICP_LIB_LOADER
constexpr size_t LOADERAPI_H_COUNTER_BASE = __COUNTER__ + 1;
#define LOADERAPI_H_NOTHING(X)
#define LOADERAPI_H_LOADER_API_INNER(X) LOADERAPI_H_NOTHING(X)
#define LOADER_API_COUNT LOADERAPI_H_LOADER_API_INNER(__COUNTER__)
#define LOADERAPI_H_GET_COUNTER (__COUNTER__ - LOADERAPI_H_COUNTER_BASE)
#else
#define LOADER_API_COUNT
#endif
// the API defs to be exposed
namespace LibLoader::LoaderApi {
    typedef void (*task_func)();
    typedef void (*task_func_with_id)(size_t);
    using MiraiCP::MiraiCPString;
    LOADER_API_COUNT
    MiraiCPString pluginOperation(const MiraiCPString &);
    LOADER_API_COUNT
    void loggerInterface(const MiraiCPString &content, const MiraiCPString &name, long long id, int level);
    LOADER_API_COUNT
    MiraiCPString showAllPluginId();
    LOADER_API_COUNT
    void pushTask(task_func);
    LOADER_API_COUNT
    void pushTaskWithId(task_func_with_id, size_t);
    LOADER_API_COUNT
    void timer(const MiraiCPString &, const MiraiCPString &, size_t);
    // Admin api
    LOADER_API_COUNT
    void enablePluginById(const MiraiCPString &);
    LOADER_API_COUNT
    void disablePluginById(const MiraiCPString &);
    LOADER_API_COUNT
    void enableAllPlugins();
    LOADER_API_COUNT
    void disableAllPlugins();
    LOADER_API_COUNT
    void loadNewPlugin(const MiraiCPString &, bool);
    LOADER_API_COUNT
    void unloadPluginById(const MiraiCPString &);
    LOADER_API_COUNT
    void reloadPluginById(const MiraiCPString &);
    // internal usage. do not call this directly in plugins.
    struct interface_funcs {
        static constexpr size_t line0 = __LINE__;
        DECL_API(pluginOperation);
        DECL_API(loggerInterface);
        DECL_API(showAllPluginId);
        DECL_API(pushTask);
        DECL_API(pushTaskWithId);
        DECL_API(timer);
        static constexpr size_t line1 = __LINE__;
        static constexpr size_t normal_api_count = line1 - line0 - 1;
        // apis below can only be called by admin plugins
        static constexpr size_t adminline0 = __LINE__;
        DECL_API(enablePluginById) = nullptr;
        DECL_API(disablePluginById) = nullptr;
        DECL_API(enableAllPlugins) = nullptr;
        DECL_API(disableAllPlugins) = nullptr;
        DECL_API(loadNewPlugin) = nullptr;
        DECL_API(unloadPluginById) = nullptr;
        DECL_API(reloadPluginById) = nullptr;
        static constexpr size_t adminline1 = __LINE__;
        static constexpr size_t admin_api_count = adminline1 - adminline0 - 1;
        static constexpr size_t api_count = normal_api_count + admin_api_count;
    };
#ifdef MIRAICP_LIB_LOADER
    constexpr inline interface_funcs collect_interface_functions(bool admin) {
        constexpr size_t counter = LOADERAPI_H_GET_COUNTER;
        static_assert(interface_funcs::api_count == counter);
        static_assert(sizeof(interface_funcs) == sizeof(void *) * counter); // also check pointer size
        if (admin) {
            constexpr size_t line0 = __LINE__;
            interface_funcs t = {
                    pluginOperation,
                    loggerInterface,
                    showAllPluginId,
                    pushTask,
                    pushTaskWithId,
                    timer, /// end normal apis
                    enablePluginById,
                    disablePluginById,
                    enableAllPlugins,
                    disableAllPlugins,
                    loadNewPlugin,
                    unloadPluginById,
                    reloadPluginById,
            };
            constexpr size_t line1 = __LINE__;
            constexpr size_t allapi_construct_number = line1 - line0 - 3;
            static_assert(allapi_construct_number == counter);
            return t;
        } else {
            constexpr size_t line0 = __LINE__;
            interface_funcs t2 = {
                    pluginOperation,
                    loggerInterface,
                    showAllPluginId,
                    pushTask,
                    pushTaskWithId,
                    timer,
            }; // no admin functions
            constexpr size_t line1 = __LINE__;
            constexpr size_t adminapi_construct_number = line1 - line0 - 3;
            static_assert(adminapi_construct_number == interface_funcs::normal_api_count);
            return t2;
        }
    }
#endif
} // namespace LibLoader::LoaderApi
#endif //MIRAICP_PRO_LOADERAPIINTERNAL_H
namespace LibLoader {
    typedef void *plugin_handle;
    /// @see @macro FUNC_ENTRANCE
    typedef int (*plugin_entrance_func_ptr)(const LoaderApi::interface_funcs &);
    /// @see @macro FUNC_EVENT
    typedef int (*plugin_event_func_ptr)(const MiraiCP::MiraiCPString &);
    /// @see @macro FUNC_EXIT
    typedef int (*plugin_func_ptr)();
    /// @see @macro PLUGIN_INFO
    typedef const MiraiCP::PluginConfig *(*plugin_info_func_ptr)();
} // namespace LibLoader
namespace MiraiCP {
    using QQID = unsigned long long;
} // namespace MiraiCP
#endif //MIRAICP_PRO_COMMONTYPES_H
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_LOADERAPIINTERNAL_H
#define MIRAICP_PRO_LOADERAPIINTERNAL_H
// #include "MiraiCPStringInternal.h"
#ifdef MIRAICP_LIB_LOADER
constexpr size_t LOADERAPI_H_COUNTER_BASE = __COUNTER__ + 1;
#define LOADERAPI_H_NOTHING(X)
#define LOADERAPI_H_LOADER_API_INNER(X) LOADERAPI_H_NOTHING(X)
#define LOADER_API_COUNT LOADERAPI_H_LOADER_API_INNER(__COUNTER__)
#define LOADERAPI_H_GET_COUNTER (__COUNTER__ - LOADERAPI_H_COUNTER_BASE)
#else
#define LOADER_API_COUNT
#endif
// the API defs to be exposed
namespace LibLoader::LoaderApi {
    typedef void (*task_func)();
    typedef void (*task_func_with_id)(size_t);
    using MiraiCP::MiraiCPString;
    LOADER_API_COUNT
    MiraiCPString pluginOperation(const MiraiCPString &);
    LOADER_API_COUNT
    void loggerInterface(const MiraiCPString &content, const MiraiCPString &name, long long id, int level);
    LOADER_API_COUNT
    MiraiCPString showAllPluginId();
    LOADER_API_COUNT
    void pushTask(task_func);
    LOADER_API_COUNT
    void pushTaskWithId(task_func_with_id, size_t);
    LOADER_API_COUNT
    void timer(const MiraiCPString &, const MiraiCPString &, size_t);
    // Admin api
    LOADER_API_COUNT
    void enablePluginById(const MiraiCPString &);
    LOADER_API_COUNT
    void disablePluginById(const MiraiCPString &);
    LOADER_API_COUNT
    void enableAllPlugins();
    LOADER_API_COUNT
    void disableAllPlugins();
    LOADER_API_COUNT
    void loadNewPlugin(const MiraiCPString &, bool);
    LOADER_API_COUNT
    void unloadPluginById(const MiraiCPString &);
    LOADER_API_COUNT
    void reloadPluginById(const MiraiCPString &);
    // internal usage. do not call this directly in plugins.
    struct interface_funcs {
        static constexpr size_t line0 = __LINE__;
        DECL_API(pluginOperation);
        DECL_API(loggerInterface);
        DECL_API(showAllPluginId);
        DECL_API(pushTask);
        DECL_API(pushTaskWithId);
        DECL_API(timer);
        static constexpr size_t line1 = __LINE__;
        static constexpr size_t normal_api_count = line1 - line0 - 1;
        // apis below can only be called by admin plugins
        static constexpr size_t adminline0 = __LINE__;
        DECL_API(enablePluginById) = nullptr;
        DECL_API(disablePluginById) = nullptr;
        DECL_API(enableAllPlugins) = nullptr;
        DECL_API(disableAllPlugins) = nullptr;
        DECL_API(loadNewPlugin) = nullptr;
        DECL_API(unloadPluginById) = nullptr;
        DECL_API(reloadPluginById) = nullptr;
        static constexpr size_t adminline1 = __LINE__;
        static constexpr size_t admin_api_count = adminline1 - adminline0 - 1;
        static constexpr size_t api_count = normal_api_count + admin_api_count;
    };
#ifdef MIRAICP_LIB_LOADER
    constexpr inline interface_funcs collect_interface_functions(bool admin) {
        constexpr size_t counter = LOADERAPI_H_GET_COUNTER;
        static_assert(interface_funcs::api_count == counter);
        static_assert(sizeof(interface_funcs) == sizeof(void *) * counter); // also check pointer size
        if (admin) {
            constexpr size_t line0 = __LINE__;
            interface_funcs t = {
                    pluginOperation,
                    loggerInterface,
                    showAllPluginId,
                    pushTask,
                    pushTaskWithId,
                    timer, /// end normal apis
                    enablePluginById,
                    disablePluginById,
                    enableAllPlugins,
                    disableAllPlugins,
                    loadNewPlugin,
                    unloadPluginById,
                    reloadPluginById,
            };
            constexpr size_t line1 = __LINE__;
            constexpr size_t allapi_construct_number = line1 - line0 - 3;
            static_assert(allapi_construct_number == counter);
            return t;
        } else {
            constexpr size_t line0 = __LINE__;
            interface_funcs t2 = {
                    pluginOperation,
                    loggerInterface,
                    showAllPluginId,
                    pushTask,
                    pushTaskWithId,
                    timer,
            }; // no admin functions
            constexpr size_t line1 = __LINE__;
            constexpr size_t adminapi_construct_number = line1 - line0 - 3;
            static_assert(adminapi_construct_number == interface_funcs::normal_api_count);
            return t2;
        }
    }
#endif
} // namespace LibLoader::LoaderApi
#endif //MIRAICP_PRO_LOADERAPIINTERNAL_H
// Copyright (c) 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_REDIRECTCOUT_H
#define MIRAICP_PRO_REDIRECTCOUT_H
// #include "MiraiCPMacros.h"
#include <sstream>
namespace MiraiCP::Redirector {
    MIRAICP_EXPORT void setRedirectedObjs(std::ostream *, std::ostream *);
    /// start redirecting cout and cerr
    MIRAICP_EXPORT void start();
    /// reset all redirecting
    MIRAICP_EXPORT void reset();
} // namespace MiraiCP
#endif //MIRAICP_PRO_REDIRECTCOUT_H
#ifndef MIRAICP_PRO_BOT_H
#define MIRAICP_PRO_BOT_H
// #include "Contact.h"
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_CONTACT_H
#define MIRAICP_PRO_CONTACT_H
// #include "IMiraiData.h"
// Copyright (c) 2022 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_IMIRAIDATA_H
#define MIRAICP_PRO_IMIRAIDATA_H
#include "json_fwd.hpp"
#include <atomic>
#include <shared_mutex>
namespace MiraiCP {
    /// 声明 Contact 类数据安全锁接口以及部分实现的抽象类
    struct IMiraiData {
    private:
        /// 锁
        struct MiraiDataLocker final {
            /// 该数据是否上锁
            std::shared_mutex _mtx;
            /// 该数据是否已经初始化
            std::atomic<bool> _inited = false;
        };
    protected:
        /// 锁实例
        mutable MiraiDataLocker Locker;
    public:
        IMiraiData() = default;
        virtual ~IMiraiData() = default;
    public:
        /// 转为json, 由子类实现, 多线程安全(带锁)
        nlohmann::json toJson() const;
    protected:
        /// 读入json数据, 由子类实现, 无锁
        virtual void deserialize(nlohmann::json in_json) = 0;
        /// 转为json, 由子类实现, 无锁
        virtual nlohmann::json internalToJson() const = 0;
        /**
         * 转为json，internalToJson 的具体实现决定, 无锁
         * @see internalToJson
         */
        nlohmann::json internalToString() const;
    public:
        /// 请求一次刷新数据, 但不保证会进行
        void requestRefresh();
        /*!
         * @brief 确保下次调用 requestRefresh 时刷新数据
         * @note 调用该函数本身不会刷新数据
         * @see requestRefresh
         */
        void forceRefreshNextTime();
        /// 序列化为string, 带锁
        std::string toString() const;
        /// 获取锁
        std::shared_mutex &getMutex() {
            return Locker._mtx;
        }
    private:
        /// 刷新数据, 由子类实现
        virtual void refreshInfo() = 0;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_IMIRAIDATA_H
// #include "KtOperation.h"
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_KTOPERATION_H
#define MIRAICP_PRO_KTOPERATION_H
#include <json_fwd.hpp>
/// @brief 配置类声明,  MiraiCP内部使用, 不需要更改或其他操作
/// @internal 一般为MiraiCP内部调用jni接口使用
/// @namespace KtOperation
namespace MiraiCP::KtOperation {
    /// 操作id
    enum operation_set {
        /// 撤回信息
        Recall,
        /// 发送信息
        Send,
        /// 查询信息接口
        RefreshInfo,
        /// 上传图片
        UploadImg,
        /// 取bot相关列表
        QueryBotList,
        /// 上传文件
        SendFile,
        /// 查询文件信息
        RemoteFileInfo,
        /// 查询图片下载地址
        QueryImgInfo,
        /// 禁言
        MuteM,
        /// 查询权限
        QueryM,
        /// 踢出
        KickM,
        /// 取群主
        QueryOwner,
        /// 语音
        Voice,
        /// 群设置
        GroupSetting,
        /// 构建转发信息
        Buildforward,
        /// 好友申请事件
        Nfroperation,
        /// 群聊邀请事件
        Gioperation,
        /// 回复(引用并发送)
        SendWithQuote,
        /// 群公告操作
        Announcement,
        /// 发送戳一戳
        SendNudge,
        /// 下一条信息
        NextMsg,
        /// 更改权限
        ModifyAdmin,
        /// 群成员申请入群
        MemberJoinRequest,
        /// 图片是否已经上传
        ImageUploaded,
        /// 注册指令
        CommandReg,
        /// 改名称
        ChangeNameCard,
        /// 改群头衔
        ChangeSpecialTitle,
    };
    enum QueryBotListCode {
        /// 查询好友列表
        FriendList = 0, // 0
        /// 查询群列表
        GroupList,      // 1
        /// 查询群成员列表
        MemberList,     // 2
    };
    enum AnnouncementOperationCode {
        /// 发布公告
        Delete = 1,      // 1
        /// 删除公告
        Publish,         // 2
    };
    /**
     * @brief 调用 Mirai 操作
     * @param type 操作id
     * @param data 传入数据
     * @return 返回数据
     */
    std::string ktOperation(
            operation_set type,
            const nlohmann::json &data,
            bool catchErr = true,
            const std::string &errorInfo = "");
    /**
     * @brief 调用 Mirai 操作
     * @param type 操作id
     * @param data 传入数据
     * @return 返回数据
     */
    std::string ktOperationStr(
            operation_set type,
            const std::string &data,
            bool catchErr = true,
            const std::string &errorInfo = "");
} // namespace MiraiCP::KtOperation
#endif //MIRAICP_PRO_KTOPERATION_H
// #include "LowLevelAPI.h"
#ifndef MIRAICP_PRO_LOWLEVELAPI_H
#define MIRAICP_PRO_LOWLEVELAPI_H
#include <json_fwd.hpp>
namespace MiraiCP {
    /// 较底层api
    class LowLevelAPI {
    public:
        /// @brief 取该联系人的一些信息
        /// @param c 该联系人Contact->serializationToString()
        /// @return json格式字符串，待解析
        static std::string getInfoSource(nlohmann::json c);
        /*!
         * @brief 上传图片
         * @param path 本地地址
         * @param c 上传的对象, Contact->serializationToString()
         * @return string 待解析json
         */
        static std::string uploadImg0(std::string, nlohmann::json);
        /// 每个对象的必有信息
        struct info {
            std::string nickOrNameCard;
            std::string avatarUrl;
        };
        /// 获取每个对象必有信息
        /// @see LowLevelAPI::info
        static info info0(const std::string &source);
    };
    /// 判断目前是否可以安全地call LoaderApi
    bool checkSafeCall();
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOWLEVELAPI_H
// #include "MessageChain.h"
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MESSAGECHAIN_H
#define MIRAICP_PRO_MESSAGECHAIN_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "Exception.h"
#ifndef MIRAICP_PRO_EXCEPTION_H
#define MIRAICP_PRO_EXCEPTION_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "CPPPlugin.h"
#ifndef MIRAICP_PRO_CPPPLUGIN_H
#define MIRAICP_PRO_CPPPLUGIN_H
// #include "Logger.h"
#ifndef MIRAICP_PRO_LOGGER_H
#define MIRAICP_PRO_LOGGER_H
// #include "MiraiCode.h"
#ifndef MIRAICP_PRO_MIRAICODE_H
#define MIRAICP_PRO_MIRAICODE_H
#include <string>
namespace MiraiCP {
    /// MiraiCode父类, 指可以被转换成miraicode的类型
    class MiraiCodeable {
    public:
        /// 返回MiraiCode
        virtual std::string toMiraiCode() const = 0;
        virtual ~MiraiCodeable() = default;
    };
    /// @brief miraicode字符串
    /// @attention MiraiCode会把非miraicode组成部分(非[mirai:])转码, 输出转码前的文本用toString, 参考: https://github.com/mamoe/mirai/blob/dev/docs/Messages.md#%E8%BD%AC%E4%B9%89%E8%A7%84%E5%88%99
    /// @detail 为了便捷使用，构造函数不以explicit注释
    class MiraiCode : public MiraiCodeable {
    private:
        std::string content;
    public:
        ~MiraiCode() override = default;
        /// 输出当前内容, 会自动转码
        std::string toString();
        /// 和toString作用一样, 不过不会自动转码
        std::string toMiraiCode() const override {
            return content;
        }
        /// 从MiraiCodeable类型初始化一个miraicode字符串
        MiraiCode(MiraiCodeable *a) { // NOLINT(google-explicit-constructor)
            content = a->toMiraiCode();
        }
        /// 从文本初始化一个miraicode字符串, 根据第二个参数决定是否转码, 默认不转码
        /// @attention 如果是传入文本MiraiCode，请勿转码，转码只是为了[mirai:xxx:<应该转码的部分>], 如果<应该转码>的部分里面含有'[]:,'内容，请调用Tools::escapeToMiraiCode转码
        MiraiCode(const std::string &a, bool convert = false);
        MiraiCode operator+(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode operator+(const std::string &a) {
            return {content + a};
        }
        MiraiCode operator+(const MiraiCode &a) {
            return {content + a.content};
        }
        MiraiCode operator+(MiraiCode *a) {
            return {content + a->content};
        }
        MiraiCode &operator=(const std::string &a) {
            this->content = a;
            return *this;
        }
        MiraiCode plus(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode plus(const std::string &a) {
            return MiraiCode(a) + this;
        }
        /// 不执行转义，适用于已经被MiraiCode转义过的字符串
        static MiraiCode MiraiCodeWithoutEscape(const std::string &a) {
            return {a, false};
        }
        /// 不执行转义，因为MiraiCodeable的toMiraiCode已经转义过了
        static MiraiCode MiraiCodeWithoutEscape(MiraiCodeable *a) {
            return {a->toMiraiCode(), false};
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MIRAICODE_H
// #include "commonTypes.h"
#include <functional>
#include <sstream>
namespace MiraiCP {
    class MiraiCodeable; // forward declaration
    /*!
    * @class Logger
    * @brief 以MiraiCP的名义发送日志, 日志表现格式是: 2021-06-28 09:37:22 [log level]/MiraiCP: [log content], 为最底层的logger
	* 发送消息级日志
	* @code Logger::logger.info(string) @endcode
	* 发送警告级日志
	* @code Logger::logger.warning(string) @endcode
	* 发送错误级日志
	* @code Logger::logger.error(string) @endcode
    * @doxygenEg{1011, logger.cpp, 自定义日志handle}
    */
    class Logger_interface {
        using string = std::string;
    public:
        /// @brief 封装lambda类型
        /// @param string 日志内容
        /// @param 日志级别
        ///     - 0 info
        ///     - 1 warning
        ///     - 2 error
        typedef std::function<void(string, int)> Action;
        /// @brief loggerhandler会在每次log执行前执行一遍，可用于执行自定义的保存操作等
        struct Handler {
            /// @brief 是否启用
            bool enable = true;
            /// @brief 执行的操作，格式为lambda
            Action action;
        };
        std::shared_ptr<Handler> loggerhandler;
    private:
        static std::string constructString() {
            return "";
        }
        template<class T, class... T1>
        static std::string constructString(T &&val, T1 &&...val1) {
            // todo(Antares): 构造一个std::stringstream消耗很大，改为T类型实现序列化函数，
            //  调用 T::serialize
            std::stringstream sstream;
            sstream << val;
            return sstream.str() + constructString(std::forward<T1>(val1)...);
        }
        template<class... T>
        static std::string constructString(const std::string &a, T &&...val1) {
            return a + constructString(std::forward<T>(val1)...);
        }
        template<class... T>
        static std::string constructString(const MiraiCodeable &val, T &&...val1) {
            return val.toMiraiCode() + constructString(std::forward<T>(val1)...);
        }
        void create_loggerhandler() {
            loggerhandler.reset(new Handler);
        }
    protected:
        /// @brief 日志底层实现封装
        /// @param log 日志内容
        /// @param level 日志等级
        virtual void log_interface(const string &log, int level) = 0;
        void handler_trigger(string log, int level) {
            if (!loggerhandler) create_loggerhandler();
            if (loggerhandler->enable && loggerhandler->action) loggerhandler->action(std::move(log), level);
        }
    public:
        ///发送普通(info级日志)
        template<class... T>
        void info(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 0);
        }
        ///发送警告(warning级日志)
        template<class... T>
        void warning(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 1);
        }
        ///发送错误(error级日志)
        template<class... T>
        void error(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 2);
        }
        /// @brief 设置loggerhandler的action
        /// @param action 执行的操作
        /// @see Logger::handler
        void registerHandle(Action action) {
            if (!this->loggerhandler) create_loggerhandler();
            this->loggerhandler->action = std::move(action);
        }
        /// @brief 设置handler的启用状态
        /// @param state 状态，启用或者关闭
        /// @doxygenEg{1012, logger.cpp, 启用或关闭日志}
        void setHandleState(bool state) {
            if (!this->loggerhandler) create_loggerhandler();
            this->loggerhandler->enable = state;
        }
    };
    class MIRAICP_EXPORT Logger : public Logger_interface {
    private:
        Logger() = default;
    protected:
        /// @brief 日志底层实现封装
        /// @param content 日志内容
        /// @param level 日志等级
        void log_interface(const std::string &content, int level) override;
    public:
        static Logger logger;
    };
    /// 带id(一般为bot账号)的logger
    class IdLogger : public Logger_interface {
    public:
        QQID id;
    public:
        IdLogger(QQID id, Logger *l) : id(id) {
            this->loggerhandler = l->loggerhandler;
        }
    protected:
        void log_interface(const std::string &content, int level) override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOGGER_H
// #include "PluginConfig.h"
#include <utility>
namespace MiraiCP {
    /// 插件父类
    class CPPPlugin {
    public:
        // for api-compatible
        ShouldNotUse("请改为初始化静态常量 CPPPlugin::config") explicit CPPPlugin(const PluginConfig &) {
            // 不可覆盖原本的config，这里什么都不做
        }
        explicit CPPPlugin() = default;
        virtual ~CPPPlugin() = default;
    public:
        /// @brief 插件信息，一个插件中该内容不应变化
        MIRAICP_EXPORT const static PluginConfig config;
        /// @brief 插件级logger
        /// @deprecated use Logger::logger instead
        [[deprecated("Use Logger::logger instead")]] static Logger *pluginLogger;
        static std::unique_ptr<CPPPlugin> plugin;
    public:
        /// 插件启用时调用一次
        virtual void onEnable() {}
        virtual void onDisable() {}
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CPPPLUGIN_H
#include <exception>
#include <string>
#include <thread>
namespace MiraiCP {
    /// @brief 总异常抽象类，用于一般捕获，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionBase
    class MIRAICP_EXPORT MiraiCPExceptionBase : public ::std::exception {
    protected:
        using string = std::string;
    protected:
        /// @brief 异常内容
        string re;
    public:
        /// @brief 发生异常的文件名
        string filename;
        /// @brief 发生异常的行号
        int lineNum = 0;
    protected:
        /// 受保护构造函数，供子类调用
        MiraiCPExceptionBase(string info, string _filename, int _lineNum) : re(std::move(info)), filename(std::move(_filename)), lineNum(_lineNum) {}
    public:
        ~MiraiCPExceptionBase() override = default;
    public:
        /// 异常信息
        const char *what() const noexcept override { return re.c_str(); }
        /// 返回std::string的异常信息
        string getError() const { return re; }
        /// 实际抛出方法
        void raise() const;
    public: // 暴露的接口
        /// basicRaise 基本抛出方法，子类重写该方法
        virtual void basicRaise() const;
        // CRTP实现一次，调用静态的exceptionType
        /// 获取异常类型，通用接口
        virtual string getExceptionType() const = 0;
        // 每个子类需要单独实现该静态方法
        /// 返回异常的类型，该静态方法无法正确实现多态，请使用 getExceptionType
        /// @see getExceptionType
        static string exceptionType() { return "MiraiCPException"; }
    };
    /// @brief 总异常CRTP抽象类，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException。
    /// 该类是用于继承的基类，需要新的异常类型时，继承该类并以子类作为模板参数。
    /// 子类需要实现的方法：
    /// 1. 构造函数，要求必须委托MiraiCPExceptionCRTP构造。
    /// 2. `static std::string exceptionType()` 返回一个字符串表示异常类型。
    /// 继承该类后异常类能正确实现多态。
    /// @interface MiraiCPExceptionCRTP
    /// @note 请勿给该类增加新的属性。如果要增加属性应在 MiraiCPExceptionBase 中增加
    template<class T>
    class MIRAICP_EXPORT MiraiCPExceptionCRTP : public MiraiCPExceptionBase {
    public:
        /// 委托构造函数
        explicit MiraiCPExceptionCRTP(string _re, string _filename, int _lineNum) : MiraiCPExceptionBase(std::move(_re), std::move(_filename), _lineNum) {
        }
    public:
        // CRTP类型获取实现
        string getExceptionType() const override { return T::exceptionType(); }
    };
    /// @brief 通用MiraiCP异常
    /// @param const string &description, string _filename, int _lineNum
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MiraiCPException : public MiraiCPExceptionCRTP<MiraiCPExceptionBase> {};
    /// 文件读取异常.
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT UploadException : public MiraiCPExceptionCRTP<UploadException> {
    public:
        explicit UploadException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP("上传(图片/文件)异常" + text, std::move(_filename), _lineNum) {}
        static std::string exceptionType() { return "UploadException"; }
    };
    /// 通常为Mirai返回
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT IllegalStateException : public MiraiCPExceptionCRTP<IllegalStateException> {
    public:
        explicit IllegalStateException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP("状态异常:" + text, std::move(_filename), _lineNum) {}
        static std::string exceptionType() { return "IllegalStateException"; }
    };
    /// 内部异常, 通常为json读写问题
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT APIException : public MiraiCPExceptionCRTP<APIException> {
    public:
        explicit APIException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP("MiraiCP内部无法预料的错误:" + text, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "APIException"; }
    };
    /// 机器人操作异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT BotException : public MiraiCPExceptionCRTP<BotException> {
    public:
        explicit BotException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("没有权限执行该操作", std::move(_filename), _lineNum) {}
        explicit BotException(const string &d, string _filename, int _lineNum) : MiraiCPExceptionCRTP(d, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "BotException"; }
    };
    /// 被禁言异常, 通常发生于发送信息
    class MIRAICP_EXPORT BotIsBeingMutedException : public MiraiCPExceptionCRTP<BotIsBeingMutedException> {
    public:
        /// 剩余禁言时间, 单位秒
        int timeRemain;
    public:
        explicit BotIsBeingMutedException(int t, string _filename, int _lineNum) : MiraiCPExceptionCRTP(
                                                                                           "发送信息失败, bot已被禁言, 剩余时间" + std::to_string(t), std::move(_filename), _lineNum),
                                                                                   timeRemain(t) {}
        static string exceptionType() { return "BotIsBeingMutedException"; }
    };
    /// 禁言异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MuteException : public MiraiCPExceptionCRTP<MuteException> {
    public:
        /*
        *	 禁言时间超出0s~30d
        */
        MuteException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("禁言时长不在0s~30d中间", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "MuteException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MemberException : public MiraiCPExceptionCRTP<MemberException> {
    public:
        enum MemberExceptionType : int {
            OtherType,
            NoSuchGroup,
            NoSuchMember
        };
        MemberExceptionType type = OtherType;
        /*
        *   "1" - 找不到群
        *	"2" - 找不到群成员
        */
        explicit MemberException(int _type, string _filename, int _lineNum) : MiraiCPExceptionCRTP(
                                                                                      [&]() -> string {
                                                                                          type = MemberExceptionType(_type);
                                                                                          switch (type) {
                                                                                              case NoSuchGroup:
                                                                                                  return "找不到群";
                                                                                              case NoSuchMember:
                                                                                                  return "找不到群成员";
                                                                                              default:
                                                                                                  return "";
                                                                                          }
                                                                                      }(),
                                                                                      std::move(_filename), _lineNum) {}
        static string exceptionType() { return "MemberException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT FriendException : public MiraiCPExceptionCRTP<FriendException> {
    public:
        /*
        *   找不到好友
        */
        FriendException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("找不到好友", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "FriendException"; }
    };
    /// 获取群错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT GroupException : public MiraiCPExceptionCRTP<GroupException> {
    public:
        GroupException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("找不到群", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "GroupException"; }
    };
    /// 撤回异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT RecallException : public MiraiCPExceptionCRTP<RecallException> {
    public:
        RecallException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("该消息已经被撤回", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "RecallException"; }
    };
    /// 远程资源出现问题
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT RemoteAssetException : public MiraiCPExceptionCRTP<RemoteAssetException> {
    public:
        explicit RemoteAssetException(const string &e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(e, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "RemoteAssetException"; }
    };
    /// 参数错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT IllegalArgumentException : public MiraiCPExceptionCRTP<IllegalArgumentException> {
    public:
        explicit IllegalArgumentException(const string &e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(e, std::move(_filename), _lineNum) {
        }
        static string exceptionType() { return "IllegalArgumentException"; }
    };
    /// 超时
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT TimeOutException : public MiraiCPExceptionCRTP<TimeOutException> {
    public:
        explicit TimeOutException(const std::string &e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(e, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "TimeOutException"; }
    };
    /// 事件被取消, 一般出现在发送消息时在preSendMessageEvent取消的时候抛出
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT EventCancelledException : public MiraiCPExceptionCRTP<EventCancelledException> {
    public:
        explicit EventCancelledException(const string &msg, string _filename, int _lineNum) : MiraiCPExceptionCRTP(msg, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "EventCancelledException"; }
    };
    /// 插件没有权限时抛出该异常
    /// 该异常仅可能在插件尝试调用libLoader 高级权限的Api接口时抛出
    /// 如插件尝试重载、加载、卸载插件等操作，但配置文件中并没有赋予该插件权限时
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT PluginNotAuthorizedException : public MiraiCPExceptionCRTP<PluginNotAuthorizedException> {
    public:
        explicit PluginNotAuthorizedException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("插件" + CPPPlugin::config.getId() + "没有管理权限", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "PluginNotAuthorizedException"; }
    };
    /// 插件未加载抛出该异常
    /// 在插件能正常运行时不会抛出，出现该异常事件时请不要再次尝试收发消息等Mirai操作，
    /// 否则可能导致异常处理时再次抛出异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT PluginNotEnabledException : public MiraiCPExceptionCRTP<PluginNotEnabledException> {
    public:
        explicit PluginNotEnabledException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("插件" + CPPPlugin::config.getId() + "未加载", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "PluginNotEnabledException"; }
    };
    /// 如果在 MiraiCPNewThread 中捕获到了非 MiraiCP 之外的异常抛出
    /// @see MiraiCPNewThread
    class MiraiCPThreadException : public MiraiCPExceptionCRTP<MiraiCPThreadException> {
    public:
        /// 抛出异常的线程 ID
        std::thread::id threadId;
    public:
        explicit MiraiCPThreadException(const std::string &exception_content, std::thread::id threadId, string _filename, int _lineNum)
            : MiraiCPExceptionCRTP(exception_content + " at threadId: " + getThreadIdStr(threadId), std::move(_filename), _lineNum),
              threadId(threadId) {}
    public:
        std::string getThreadIdStr() const { return getThreadIdStr(threadId); }
    public:
        static string exceptionType() { return "MiraiCPThreadException"; }
    private:
        MIRAICP_EXPORT static std::string getThreadIdStr(const std::thread::id &id);
    };
    void ErrorHandle0(const std::string &name, int line, const std::string &re, const std::string &ErrorMsg = "");
} // namespace MiraiCP
#endif //MIRAICP_PRO_EXCEPTION_H
// #include "SingleMessage.h"
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_SINGLEMESSAGE_H
#define MIRAICP_PRO_SINGLEMESSAGE_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "MessageSource.h"
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MESSAGESOURCE_H
#define MIRAICP_PRO_MESSAGESOURCE_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "commonTypes.h"
#include <string>
namespace MiraiCP {
    class MiraiCodeable; // forward declaration
    /*! 消息源声明
     * @doxygenEg{1014, message.cpp, 回复信息}
    */
     class MIRAICP_EXPORT MessageSource {
     public:
         /// 消息的ids
         std::string ids;
         /// 消息的internalids
         std::string internalids;
         /// 消息源序列化
         std::string source;
         MessageSource() = default;
        /// @deprecated 用Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMiraiCode(MiraiCodeable *msg, QQID groupid = 0,
                                      void *env = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMsg(const std::string &c, QQID groupid = 0,
                                void * = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMiraiCode(const std::string &c, QQID groupid = 0,
                                      void * = nullptr) const = delete;
        /*!
         * @brief 构建消息源
         * @param ids
         * @param internalids
         * @param source
         */
        MessageSource(std::string ids, std::string internalids, std::string source);
        /*!
         * @brief 从json字符串反序列化到MessageSource对象
         * @note json应该为以下格式
         * @code
         * {"ids":"", "internalIds":""}
         * @endcode
         */
        static MessageSource deserializeFromString(const std::string &source);
        std::string serializeToString() const;
        /// @brief 撤回该信息
        void recall() const;
        bool operator==(const MessageSource &ms) const {
            return this->ids == ms.ids && this->internalids == ms.internalids;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGESOURCE_H
// #include "MiraiCode.h"
#include <array>
#include <json_fwd.hpp>
#include <optional>
#include <sstream>
#include <unordered_map>
#include <utility>
namespace MiraiCP {
    // todo(Antares): delete these after the whole refactor is finished
#define SINGLEMESSAGE_REFACTOR_ASSERTION(x, y) static_assert((x) == (y), "static assertion failed when refactoring code")
    namespace SingleMessageType {
        // id 小于 0 的是不能直接发送的消息(仅在接收的 MessageChain 里出现)
        MIRAICP_ITERABLE_ENUM(            // NOLINT(cert-dcl21-cpp)
                -6,                       // begin at
                MessageSource_t,          // -6
                MarketFace_t,             // -5
                OnlineForwardedMessage_t, // -4
                OnlineAudio_t,            // -3
                QuoteReply_t,             // -2
                UnsupportedMessage_t,     // -1
                PlainText_t,              // 0
                At_t,                     // 1
                AtAll_t,                  // 2
                Image_t,                  // 3
                LightApp_t,               // 4
                ServiceMessage_t,         // 5
                RemoteFile_t,             // 6
                Face_t,                   // 7
                FlashImage_t,             // 8
                MusicShare_t              // 9, End = 10
        )
        constexpr const char *miraiCodeNameInternal[] = {
                "NoExists",  // 0
                "NoExists",  // 1
                "NoExists",  // 2
                "NoExists",  // 3
                "NoExists",  // 4
                "NoExists",  // 5
                "NoExists",  // 6
                "at",        // 7
                "atall",     // 8
                "image",     // 9
                "app",       // 10
                "service",   // 11
                "file",      // 12
                "face",      // 13
                "flash",     // 14
                "musicshare" // 15
        };
        constexpr const char *messageTypeInternal[] = {
                "MessageSource",        // -6
                "MarketFace",           // -5
                "ForwardMessage",       // -4
                "OnlineAudio",          // -3
                "QuoteReply",           // -2
                "UnsupportedMessage",   // -1
                "PlainText",            // 0      <-- messageType is here
                "At",                   // 1
                "AtAll",                // 2
                "Image",                // 3
                "LightApp",             // 4
                "SimpleServiceMessage", // 5
                "FileMessage",          // 6
                "Face",                 // 7
                "FlashImage",           // 8
                "MusicShare",           // 9
        };
        static_assert(sizeof(messageTypeInternal) / sizeof(*messageTypeInternal) == SingleMessageType::End - SingleMessageType::Begin);
    } // namespace SingleMessageType
    /// 用serviceMessage的分享信息
    struct URLSharer {
        /// 简介 没点进来看见的样子
        std::string brief = "简介 没点进来看见的样子";
        /// 目标url
        std::string url = "目标url";
        /// 图标地址
        std::string cover = "图标地址";
        /// 标题
        std::string title = "标题";
        /// 描述文字
        std::string summary = "描述文字";
    };
    /// MessageChain的组成部分
    class MIRAICP_EXPORT SingleMessage : public MiraiCodeable {
    public:
    public:
        using Types = SingleMessageType::Type;
        std::string content;
        std::string prefix;
        /// MiraiCode类别
        /// @see SingleMessage::messageType
        int internalType = SingleMessageType::UnsupportedMessage_t;
    protected:
        /// @brief 仅限于让子类允许默认构造，以保证子类可以通过动态判断类型构造
        /// @note dev: 请勿删除
        SingleMessage() = default; // NOLINT(cppcoreguidelines-pro-type-member-init)
    public:
        static const char *const *const messageType;
        static const char *const *const miraiCodeName;
        static std::string getTypeString(int type) {
            return messageType[type];
        }
    public:
        /// @brief 构建单条
        /// @param type 消息类型 @see messageType
        /// @param content 内容
        /// @param prefix 前缀, 默认为`:`, 第二个冒号部分的内容, 目前在serviceMesage有使用
        SingleMessage(int inType, std::string content, std::string prefix = ":") noexcept
            : content(std::move(content)),
              prefix(std::move(prefix)),
              internalType(inType) {}
        virtual ~SingleMessage() noexcept = default;
    public:
        /// @brief 找对应类型的index key
        /// @param value 类型名
        /// @return 如果没找到返回-1
        static int getKey(const std::string &value);
        /**
         * 寻找对应的 MiraiCode 名称
         * @param value 名称
         * @return 如果没找到返回-1
         */
        static int getMiraiCodeKey(const std::string &value);
    public:
        [[nodiscard]] virtual nlohmann::json toJson() const;
        [[nodiscard]] std::string toMiraiCode() const override;
    public:
        bool operator==(const SingleMessage &m) const {
            return this->internalType == m.internalType && this->toMiraiCode() == m.toMiraiCode();
        }
        bool operator==(SingleMessage *m) const {
            return this->internalType == m->internalType && this->toMiraiCode() == m->toMiraiCode();
        }
    };
    /// 纯文本信息
    class MIRAICP_EXPORT PlainText : public SingleMessage {
    public:
        explicit PlainText(const SingleMessage &sg);
        PlainText(PlainText &&_o) noexcept = default;
        PlainText(const PlainText &_o) = default;
        explicit PlainText(std::string inStr) noexcept : SingleMessage(PlainText::type(), std::move(inStr)) {}
        template<typename Stringable, typename = decltype(std::to_string(std::declval<Stringable>()))>
        explicit PlainText(Stringable val) : SingleMessage(PlainText::type(), std::to_string(val)) {}
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(0, Types::PlainText_t);
            return Types::PlainText_t;
        }
    public:
        [[nodiscard]] std::string toMiraiCode() const override {
            return content;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        bool operator==(const PlainText &p) const {
            return this->content == p.content;
        }
    };
    // todo(Antares): 除特殊情况外（子类与基类没有差异）应禁止子类使用父类对象进行构造；或者构造函数直接调用downcast（不安全）
    //  例如 At(const SingleMessage &) 这样的构造函数不应该出现
    /// @
    class MIRAICP_EXPORT At : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(1, Types::At_t);
            return Types::At_t;
        }
        QQID target;
        [[nodiscard]] nlohmann::json toJson() const override;
        explicit At(const SingleMessage &sg);
        explicit At(QQID a) : SingleMessage(At::type(), std::to_string(a)), target(a){};
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:at:" + std::to_string(this->target) + "] "; // 后面有个空格
        }
        bool operator==(const At &a) const {
            return this->target == a.target;
        }
    };
    /// @brief \@全体
    class MIRAICP_EXPORT AtAll : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(2, Types::AtAll_t);
            return Types::AtAll_t;
        }
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:atall] ";
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        AtAll() : SingleMessage(AtAll::type(), "", "") {}
    };
    /// 图像类声明
    class MIRAICP_EXPORT Image : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(3, Types::Image_t);
            return Types::Image_t;
        }
        //图片id，样式:` {xxx}.xx `
        std::string id;
        /*!
         * @brief 图片类型
         *  - png
         *  - bmp
         *  - jpg
         *  - gif
         *  - apng
         *  - unknown
         *  默认 png
         */
        std::string imageType;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> md5;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> url;
        /// 可为0, 来源:用`refreshInfo`可能可以获取或者自己填充, 是isUploaded的必须条件, 默认0
        size_t size{};
        /// 宽度, 默认0, 单位px
        int width{};
        /// 长度, 默认0, 单位px
        int height{};
        /// 是否为 emoji
        bool isEmoji{};
        /*!
         * @brief 图片是否已经上传(如果已经上传即表明可以直接用ImageId发送, 如果没有需要手动上传)
         * @param md5 在kotlin端会用.toByteArray()转换
         * @param size 图片大小, 不能为0
         * @param botid 所属Botid
         * @return 是否已上传
         */
        bool isUploaded(QQID botid);
    protected:
        /// @brief 仅限于让子类允许默认构造，以保证子类可以通过动态判断类型构造
        /// @note dev: 请勿删除
        Image() = default; // NOLINT(cppcoreguidelines-pro-type-member-init)
    public:
        /*!
        * @brief 从图片builder构造，适用于服务器上已经有的图片，即接收到的
        * @param imageId 图片id, 必须
        * @param size isUploaded的必要条件, 单纯用ImageId可能取不到图片size, 需要自己上传
        * @param width 宽度
        * @param height 长度
        * @param type 图片类型
        * @detail 图片miraiCode格式例子, `[mirai:image:{图片id}.jpg]`
        * 可以用这个正则表达式找出id `\\[mirai:image:(.*?)\\]`
        */
        explicit Image(const std::string &imageId, size_t size = 0, int width = 0, int height = 0,
                       std::string type = "PNG",
                       bool isEmoji = false)
            : SingleMessage(Image::type(), imageId), id(imageId), imageType(std::move(type)), size(size),
              width(width), height(height), isEmoji(isEmoji) {
            // todo(Antares): 实际上重复的属性 id 和 content
        }
        /// 刷新信息(获取图片下载Url,md5, size)
        void refreshInfo();
        /// 取图片Mirai码
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:image:" + this->id + "]";
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        static Image deserialize(const std::string &);
        bool operator==(const Image &i) const {
            return this->id == i.id;
        }
    };
    /// 闪照, 和Image属性类似
    class MIRAICP_EXPORT FlashImage : public Image {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(8, Types::FlashImage_t);
            return Types::FlashImage_t;
        }
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:flash:" + this->id + "]";
        }
        explicit FlashImage(const std::string &imageId, size_t size = 0, int width = 0, int height = 0,
                            std::string type = "PNG") : Image(imageId, size, width, height, std::move(type)) {
            this->SingleMessage::internalType = Types::FlashImage_t;
        }
        explicit FlashImage(const Image &img);
        [[nodiscard]] nlohmann::json toJson() const override;
        static FlashImage deserialize(const std::string &);
        bool operator==(const FlashImage &i) const {
            return this->id == i.id;
        }
        /// 转换到普通图片
        Image toImage() { return Image(*this); }
    };
    /*!
    * @brief 小程序卡片
    * @attention 自带的模板不稳定，可能发出现没有效果
    * @doxygenEg{1015, lightApp.cpp, 从文本构建LightApp}
    */
    class MIRAICP_EXPORT LightApp : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(4, Types::LightApp_t);
            return Types::LightApp_t;
        }
        /// @brief 使用纯文本构造，推荐使用其他结构体方法构造
        /// @param content 构造文本
        explicit LightApp(std::string content) : SingleMessage(LightApp::type(), std::move(content)) {}
        explicit LightApp(const SingleMessage &sg);
        [[nodiscard]] nlohmann::json toJson() const override;
        /// 返回miraicode
        [[nodiscard]] std::string toMiraiCode() const override;
        bool operator==(const LightApp &la) const {
            return this->content == la.content;
        }
    };
    /// xml格式的超文本信息
    /// @attention 自带的模板不稳定，可能发出现没有效果
    class MIRAICP_EXPORT ServiceMessage : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(5, Types::ServiceMessage_t);
            return Types::ServiceMessage_t;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        [[nodiscard]] std::string toMiraiCode() const override;
        int id;
        /// @brief ServiceMessage
        /// @param id 在xml内容前面的id (不包括逗号)
        /// @param a xml内容 (不需要事先转码到miraiCode)
        explicit ServiceMessage(int id, std::string a) : SingleMessage(ServiceMessage::type(), std::move(a),
                                                                       ":" + std::to_string(id) + ','),
                                                         id(id) {}
        explicit ServiceMessage(const SingleMessage &sg);
        explicit ServiceMessage(const URLSharer &a) : SingleMessage(5,
                                                                    R"(<?xml version="1.0" encoding="utf-8"?><msg templateID="12345" action="web" brief=")" +
                                                                            a.brief + R"(" serviceID="1" url=")" + a.url +
                                                                            R"("><item layout="2"><picture cover=")" +
                                                                            a.cover + "\"/><title>" + a.title +
                                                                            "</title><summary>" + a.summary +
                                                                            "</summary></item><source/></msg>",
                                                                    ":1,"),
                                                      id(1) {}
        bool operator==(const ServiceMessage &s) const {
            return this->content == s.content;
        }
    };
    /// 引用信息
    class MIRAICP_EXPORT QuoteReply : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-2, Types::QuoteReply_t);
            return Types::QuoteReply_t;
        }
        // 不可直接发送, 发送引用信息用MessageChain.quoteAndSendMessage
        ShouldNotUse("don't have MiraiCode, use MessageChain.quote instead") std::string toMiraiCode() const override {
            return "";
        }
        /// 引用信息的MessageSource
        MessageSource source;
        explicit QuoteReply(const SingleMessage &m);
        explicit QuoteReply(MessageSource source) : SingleMessage(QuoteReply::type(), source.serializeToString()), source(std::move(source)){};
        bool operator==(const QuoteReply &qr) const {
            return this->source == qr.source;
        }
        nlohmann::json toJson() const override;
    };
    /// 接收到的音频文件, 发送用`Contact.sendAudio`
    class MIRAICP_EXPORT OnlineAudio : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-3, Types::OnlineAudio_t);
            return Types::OnlineAudio_t;
        }
        /// 文件名
        std::string filename;
        /// 下载地址
        std::string url;
        /// 文件大小
        int size;
        /// 编码方式
        int codec;
        /// 时长(单位s)
        int length;
        /// 16位md5
        std::array<uint8_t, 16> md5;
        /// 不支持直接发送, 用Contact.sendAudio
        ShouldNotUse("cannot use, use Contact.sendAudio") std::string toMiraiCode() const override {
            return "";
        }
        explicit OnlineAudio(std::string f, std::array<uint8_t, 16> md5, int size, int codec, int length,
                             std::string url) : SingleMessage(OnlineAudio::type(), ""),
                                                filename(std::move(f)), url(std::move(url)), size(size), codec(codec),
                                                length(length), md5(md5){};
        bool operator==(const OnlineAudio &oa) const {
            return this->md5 == oa.md5;
        }
    };
    /// @brief 远程(群)文件类型
    class MIRAICP_EXPORT RemoteFile : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(6, Types::RemoteFile_t);
            return Types::RemoteFile_t;
        }
        /// @brief 下载信息
        /// @see RemoteFile
        struct Dinfo {
            /// 下载地址, 可能会是 `null` 当文件不存在
            std::string url;
            /// md5 可用于校验
            std::string md5;
            /// sha1 可用于校验
            std::string sha1;
        };
        /// @brief 文件信息
        /// @see RemoteFile
        struct Finfo {
            /// 文件大小
            QQID size;
            /// 上传者id
            QQID uploaderid;
            /// 过期时间
            long expirytime;
            /// 上传时间, 时间戳格式
            QQID uploadtime;
            /// 上次更改时间, 时间戳格式
            QQID lastmodifytime;
        };
        /// 文件唯一id, 用于识别
        std::string id;
        /// 文件内部id, 用于构造miraiCode发送
        unsigned int internalid;
        /// 文件名
        std::string name;
        /// 文件大小
        long long size;
        /// 文件在群文件的路径
        /// @attention 可能为空(通常出现于MessageChain从MiraiCode反序列化), 需要从Group重新获取文件
        /// @see Group::getFileByFile
        std::optional<std::string> path;
        /// 文件下载信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Dinfo, Group::getFileByFile
        std::optional<Dinfo> dinfo;
        /// 文件信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Finfo, Group::getFileByFile
        std::optional<Finfo> finfo;
        std::string serializeToString();
        RemoteFile plus(unsigned int ii);
        static RemoteFile deserializeFromString(const std::string &source);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalIds
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p, struct Dinfo d, struct Finfo f);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalIds
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s);
        /// 上传后会自动发送
        ShouldNotUse("Cannot send manually, use Group.sendFile") std::string toMiraiCode() const override {
            return "";
        }
        bool operator==(const RemoteFile &rf) const {
            return this->id == rf.id;
        }
    };
    /// 自带表情
    /// @attention 有些表情会变成PlainText类型和\\xxx 的格式
    class MIRAICP_EXPORT Face : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(7, Types::Face_t);
            return Types::Face_t;
        }
        /**
         * @brief 表情 id
         */
        int id;
        [[nodiscard]] nlohmann::json toJson() const override;
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:face:" + std::to_string(id) + "]";
        }
        explicit Face(int id) : SingleMessage(Face::type(), std::to_string(id)), id(id) {}
        bool operator==(const Face &f) const {
            return this->id == f.id;
        }
    };
    /// 一些可以被mirai识别的音乐卡片, 如果不能被mirai识别, 那应该被表现成lightApp类型(可能收费/vip歌曲用lightApp, 免费用MusicShare)
    class MIRAICP_EXPORT MusicShare : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(9, Types::MusicShare_t);
            return Types::MusicShare_t;
        }
        /// 应用名称, 如NeteaseCloudMusic
        std::string appName;
        /// 歌名
        std::string title;
        /// 卡片第二行的文字内容
        std::string summary;
        /// 点击跳转到的链接
        std::string jumpUrl;
        /// 图片链接
        std::string picUrl;
        /// 音乐文件链接
        std::string musicUrl;
        /// 简介, 点进聊天节目前显示的小文字, 一般是`分享`
        std::string brief;
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:musicshare:" + appName + "," + title + "," + summary + "," + jumpUrl + "," + picUrl + "," + musicUrl + "," + brief + "]";
        }
        MusicShare(std::string appName,
                   std::string title,
                   std::string summary,
                   std::string jumpUrl,
                   std::string picUrl,
                   std::string musicUrl,
                   std::string brief)
            : SingleMessage(MusicShare::type(), ""),
              appName(std::move(appName)),
              title(std::move(title)),
              summary(std::move(summary)),
              jumpUrl(std::move(jumpUrl)),
              picUrl(std::move(picUrl)),
              musicUrl(std::move(musicUrl)),
              brief(std::move(brief)) {}
    };
    class MIRAICP_EXPORT MarketFace : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-5, Types::MarketFace_t);
            return Types::MarketFace_t;
        }
        /// 目前无法直接发送MarketFace, 可以转发
        ShouldNotUse("暂不支持直接发送") std::string toMiraiCode() const override {
            return "";
        }
        std::array<uint8_t, 16> faceId;
        explicit MarketFace(std::array<uint8_t, 16> id) : SingleMessage(MarketFace::type(), ""), faceId(id) {}
        bool operator==(const MarketFace &mf) const {
            return this->faceId == mf.faceId;
        }
    };
    /// @brief 目前不支持的消息类型, 不支持发送
    class MIRAICP_EXPORT UnSupportMessage : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-1, Types::UnsupportedMessage_t);
            return Types::UnsupportedMessage_t;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        /// 不支持发送
        ShouldNotUse("不支持直接发送UnSupportMessage") std::string toMiraiCode() const override {
            return "";
        }
        explicit UnSupportMessage(const SingleMessage &s) : SingleMessage(s){};
        explicit UnSupportMessage(const std::string &content) : SingleMessage(UnSupportMessage::type(), content) {}
        bool operator==(const UnSupportMessage &m) const {
            return this->content == m.content;
        }
    };
#undef SINGLEMESSAGE_REFACTOR_ASSERTION
} // namespace MiraiCP
#endif //MIRAICP_PRO_SINGLEMESSAGE_H
// #include "commonTools.h"
namespace MiraiCP {
    class MessageSource; // forward declaration
    namespace internal {
        /// @brief 为 std::shared_ptr<SingleMessage> 增加功能的封装类
        /// @note dev: 不可加入其他成员变量
        class Message : public std::shared_ptr<SingleMessage> {
            typedef std::shared_ptr<SingleMessage> Super;
        public:
#if MIRAICP_MSVC
            Message() {} // for MSVC compatible, Message should be default constructable. See MessageChain
#endif
            template<typename T, typename = std::enable_if<std::is_base_of_v<SingleMessage, T>>>
            explicit Message(T msg) {
                reset(new T(std::move(msg)));
            }
            explicit Message(Super msgptr) noexcept : Super(std::move(msgptr)) {}
            // dev: DON'T write copy and move constructors here, otherwise add operator= overloads. See MessageChain
        public:
            /// 代表的子类
            /// @see MessageChain::messageType
            [[nodiscard]] int getType() const {
                return (*this)->internalType;
            };
            /// 取指定类型
            /// @throw IllegalArgumentException
            template<class T>
            T getVal() const {
                // for dev: 不用 get 为了不和shared_ptr重叠
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
                if (T::type() != getType())
                    throw IllegalArgumentException(
                            "cannot convert from " + SingleMessage::getTypeString(getType()) + " to " +
                                    SingleMessage::getTypeString(T::type()),
                            MIRAICP_EXCEPTION_WHERE);
                T *re = static_cast<T *>(std::shared_ptr<SingleMessage>::get());
                if (re == nullptr)
                    throw IllegalArgumentException(
                            "cannot convert from " + SingleMessage::getTypeString(getType()) + " to " +
                                    SingleMessage::getTypeString(T::type()),
                            MIRAICP_EXCEPTION_WHERE);
                return *re;
            }
            [[nodiscard]] std::string toMiraiCode() const {
                return (*this)->toMiraiCode();
            }
            [[nodiscard]] std::string toJson() const {
                return (*this)->toJson();
            }
            bool operator==(const Message &m) const {
                return (*this)->internalType == m->internalType && (*this)->toMiraiCode() == m->toMiraiCode();
            }
            bool operator!=(const Message &m) const {
                return (*this)->internalType != m->internalType || (*this)->toMiraiCode() != m->toMiraiCode();
            }
        };
    } // namespace internal
    /// 消息链, 一般由SingleMessage组成
    class MIRAICP_EXPORT MessageChain : public std::vector<internal::Message>, public MiraiCodeable {
    public: // typedefs
        using Message = internal::Message;
    public:
        /// 如果由MiraiCP构造(incoming)就会存在，否则则不存在
        std::optional<MessageSource> source = std::nullopt;
    public:
        MessageChain(const MessageChain &_o) = default;
        MessageChain(MessageChain &&_o) = default;
        MessageChain() = default;
        ~MessageChain() override = default;
        /*!
         * @brief 从多个参数构建MessageChain
         * @tparam T 多个传入参数的类型
         * 支持以下类型:
         * - std::string / const char* 相当于传入PlainText
         * - SingleMessage的派生类
         * @param args 参数本身
         */
        template<typename... T, typename = std::enable_if_t<!std::is_same_v<std::decay_t<T>..., MessageChain>>>
        explicit MessageChain(T &&...args) {
            constructMessages(std::forward<T>(args)...);
        };
        /// incoming构造器，对第一个参数为MessageSource的特化
        template<class... T>
        explicit MessageChain(MessageSource ms, T &&...args) : source(std::move(ms)) {
            this->constructMessages(std::forward<T>(args)...);
        };
    public:
        [[deprecated("MessageChain继承自std::vector<Message>，无需获取内部vector")]] const std::vector<Message> &vector() const {
            return static_cast<const std::vector<Message> &>(*this);
        }
        std::string toMiraiCode() const override;
        std::vector<std::string> toMiraiCodeVector() const {
            std::vector<std::string> tmp;
            for (auto &&a: *this)
                tmp.emplace_back(a->toMiraiCode());
            return tmp;
        }
        nlohmann::json toJson() const;
        /**
         * @ensure toJson().dump()
         * @return MessageChain serialize to String
         */
        std::string toString() const;
        /// @brief 使用emplace_back构造Message添加元素
        /// @tparam T 任意的SingleMessage的子类对象，但不允许传入SingleMessage本身
        /// @param a 添加的值
        /// @note 如果你已经有一个Message对象，请直接调用emplace_back。
        ///  若你尝试传入一个基类SingleMessage对象，说明你的程序出现了一些问题
        template<typename T, typename = std::enable_if_t<std::is_base_of_v<SingleMessage, std::decay_t<T>> && !std::is_same_v<SingleMessage, std::decay_t<T>>>>
        void add(T &&a) {
            emplace_back(std::forward<T>(a));
        }
        void add(MessageSource val) {
            source = std::move(val);
        }
        /// 筛选出某种类型的消息
        template<class T>
        std::vector<T> filter() {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto &&a: *this) {
                if (a.getType() == T::type())
                    re.emplace_back(a.getVal<T>());
            }
            return re;
        }
        /// 自定义筛选器
        template<class T>
        std::vector<T> filter(const std::function<bool(const Message &)> &func) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto &&a: *this) {
                if (func(a))
                    re.push_back(a.getVal<T>());
            }
            return re;
        }
        /// 找出第一个指定的type的消息，消息可能不存在
        template<class T>
        std::optional<T> first() {
            for (auto &&a: *this)
                if (a.getType() == T::type())
                    return a.getVal<T>();
            return std::nullopt;
        }
        template<class T>
        [[nodiscard]] MessageChain plus(const T &a) const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            MessageChain tmp(*this);
            tmp.emplace_back(a);
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageChain &mc) const {
            MessageChain tmp(*this);
            tmp.insert(tmp.end(), mc.begin(), mc.end());
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageSource &ms) const {
            MessageChain tmp(*this);
            tmp.source = ms;
            return tmp;
        }
        template<class T>
        MessageChain operator+(const T &msg) const {
            return this->plus(msg);
        }
        bool operator==(const MessageChain &mc) const {
            if (size() != mc.size())
                return false;
            for (size_t i = 0; i < size(); i++) {
                if ((*this)[i] != mc[i])
                    return false;
            }
            return true;
        }
        bool operator!=(const MessageChain &mc) const {
            return !(*this == mc);
        }
        bool empty() const {
            return std::vector<Message>::empty() || toMiraiCode().empty();
        }
        /// @brief 回复并发送
        /// @param s 内容
        /// @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
        /// @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
        /// @detail 支持以下类型传入
        /// - std::string / const char* 相当于传入PlainText(str)
        /// - SingleMessage的各种派生类
        /// - MessageChain
        /// @deprecated use Contact.quoteAndSend or `this->quoteAndSend1(s, groupId, env)`, since v2.8.1
        template<class T>
        ShouldNotUse("use Contact.quoteAndSend") MessageSource
                quoteAndSendMessage(T s, QQID groupid = -1, void *env = nullptr) = delete;
    public: // static functions
        /// @brief 找到miraiCode结尾的`]`
        /// @param s 文本
        /// @param start 开始位置
        /// @return 如果不存在返回-1, 存在则返回index
        static size_t findEnd(const std::string &s, size_t start) {
            size_t pos = start;
            while (pos < s.length()) {
                switch (s[pos]) {
                    case '\\':
                        pos += 2;
                        continue;
                    case ']':
                        return pos;
                }
                pos++;
            }
            return -1;
        }
        /// 从miraicode string构建MessageChain
        static MessageChain deserializationFromMiraiCode(const std::string &m);
        static MessageChain deserializationFromMessageSourceJson(const std::string &msg, bool origin = true) {
            return deserializationFromMessageSourceJson(nlohmann::json::parse(msg), origin);
        }
        /// 从MessageSource json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageSourceJson(nlohmann::json j, bool origin = true);
        /// 从 Message json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageJson(const nlohmann::json &j);
    private: // private methods
        void constructMessages() {}
        template<typename T1, typename... T2, typename = std::enable_if_t<std::is_base_of_v<SingleMessage, std::decay_t<T1>>>>
        void constructMessages(T1 &&h, T2 &&...args) {
            emplace_back(std::forward<T1>(h));
            constructMessages(std::forward<T2>(args)...);
        }
        template<typename... T2>
        void constructMessages(const std::string &h, T2 &&...args) {
            emplace_back(PlainText(h));
            constructMessages(std::forward<T2>(args)...);
        }
        template<typename... T>
        void constructMessages(const MessageChain &mc, T &&...args) {
            insert(end(), mc.begin(), mc.end());
            constructMessages(std::forward<T>(args)...);
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGECHAIN_H
#include <json_fwd.hpp>
#include <string>
namespace MiraiCP {
    /// Contact 类型
    enum ContactType {
        MIRAI_CONTACT = 0,
        /// 好友
        MIRAI_FRIEND = 1,
        /// 群聊
        MIRAI_GROUP = 2,
        /// 群成员
        MIRAI_MEMBER = 3,
        /// bot
        MIRAI_BOT = 4,
        MIRAI_OTHERTYPE = 5,
    };
    /// Contact 内部储存数据抽象类
    struct IContactData : public IMiraiData {
        /// 昵称或者群名片
        std::string _nickOrNameCard;
        /// 头像 url
        std::string _avatarUrl;
        /// id
        QQID _id{};
        /// 所属的 bot 的 id
        QQID _botId{};
        /// Contact 类型
        ContactType _type = MIRAI_CONTACT;
        void deserialize(nlohmann::json inJson) override;
        nlohmann::json internalToJson() const override;
        /// 刷新数据
        void refreshInfo() override;
        /**
         * 更新传入 json 中的数据, 在调用后, 原 json 数据会被更新
         * @param jsonToUpdate 需更新的 json 数据
         * @see nlohmann::update
         */
        void updateJson(nlohmann::json &jsonToUpdate) const;
    };
    struct GroupRelatedData : public IContactData {
        typedef IContactData Super;
        /// group id
        QQID _groupId;
        nlohmann::json internalToJson() const override;
        explicit GroupRelatedData(QQID in_groupid) : _groupId(in_groupid) {}
    };
    /*!
    * @brief group, friend, member的父类
    * @doxygenEg{1002, message.cpp, 发送以及回复群消息}
    */
    class Contact {
        template<typename ClassType, typename InternalDataType>
        friend struct ContactDataHelper;
        // attrs
    protected:
        /// 内部数据
        std::shared_ptr<IContactData> InternalData;
    public:
        /*!
         * @brief 无参初始化Contact类型
         * @internal 禁止使用
         */
        Contact() = delete;
    protected:
        explicit Contact(std::shared_ptr<IContactData> Data) {
            SetInternalData(std::move(Data));
        }
    public:
        /// 虚类 destructor
        virtual ~Contact() = default;
        bool operator==(const Contact &c) const {
            return this->id() == c.id();
        }
        /**
         * @brief 设置内部数据指针
         * @note dev: 避免直接使用 InternalData, 请使用该接口操作 InternalData 指针
         */
        void SetInternalData(std::shared_ptr<IContactData> Data) { InternalData = std::move(Data); }
        /**
         * @brief 尝试一次数据刷新
         * @note 不保证进行刷新, 一般为内部调用. 强制刷新请使用 forceRefreshInfo()
         * @see forceRefreshInfo
         */
        void refreshInfo() {
            InternalData->requestRefresh();
        }
        /**
         * @brief 强制下次 refreshInfo() 调用时刷新数据
         * @note 尽可能调用该函数, 避免不必要的刷新
         * @see refreshInfo
         */
        void forceRefreshNextTime() {
            InternalData->forceRefreshNextTime();
        }
        /**
         * @brief 强制数据刷新
         * @note 频繁刷新可能会有性能损耗
         * @see refreshInfo, forceRefreshNextTime
         */
        void forceRefreshNow() {
            forceRefreshNextTime();
            refreshInfo();
        }
        /**
         * @brief 当前对象类型
         * @see ContactType
         * @note dev: 不会修改, 不需要锁
         *     - ContactType::MIRAI_FRIEND 好友
         *     - ContactType::MIRAI_GROUP 群聊
         *     - ContactType::MIRAI_MEMBER 群成员
         */
        ContactType type() const { return InternalData->_type; }
        /**
         * @brief id 在全部情况存在
         * @note dev: 不会修改，不需要锁
         *      - 当前type为Friend时，为好友id
         *      - 当前type为Group时，为群id
         *      - 当前type为Member时，为群成员id
         * @see MIRAI_CONTACT
         */
        QQID id() const { return InternalData->_id; }
        /**
         * 所属bot
         * @note dev: 不会修改，不需要锁
         */
        QQID botid() const { return InternalData->_botId; };
        /**
         * @brief 回复并发送
         * @param s 内容
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         * @param ms 回复的信息的MessageSource
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         */
        template<typename T>
        MessageSource quoteAndSendMessage(const T &s, MessageSource ms) {
            return this->quoteAndSend1(s, ms);
        }
        /**
         * @brief 回复并发送
         * @param s 内容
         * @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         */
        template<typename... T>
        MessageSource quoteAndSendMessage(const MessageSource &ms, T &&...val) {
            return this->quoteAndSend1(MessageChain(std::forward<T>(val)...), ms);
        }
        /**
         * @brief 发送信息
         * @tparam T 类型
         * 支持:
         * - SingleMessage的派生类
         * - MessageChain
         * - std::string / const char* 相当于发送PlainText()
         * @param msg 内容
         * @return MessageSource
         */
        template<typename... T>
        MessageSource sendMessage(T &&...msg) {
            return this->sendMessage(MessageChain(std::forward<T>(msg)...));
        }
        /**
         * @brief 发送一条Message
         * @detail 支持
         *  - std::string: 相当于发送PlainText(str)
         *  - MiraiCode 相当于发送反序列化MiraiCode后的
         *  - 各种SingleMessage的派生类
         *  - MessageChain
         *  @param msg Message
         *  @return MessageSource
         */
        template<typename T>
        MessageSource sendMessage(T &&msg) {
            return this->unpackMsg(MessageChain(std::forward<T>(msg)));
        }
    private: // private methods
        MessageSource quoteAndSend0(std::string msg, const MessageSource &ms) const;
        MessageSource quoteAndSend1(const SingleMessage &s, const MessageSource &ms) {
            return this->quoteAndSend0(MessageChain(s).toString(), ms);
        }
        MessageSource quoteAndSend1(const std::string &s, const MessageSource &ms) {
            return this->quoteAndSend0(s, ms);
        }
        MessageSource quoteAndSend1(const MessageChain &mc, const MessageSource &ms) {
            return this->quoteAndSend0(mc.toString(), ms);
        }
    public: // serialization
        /// 序列化到json对象
        nlohmann::json toJson() const { return InternalData->toJson(); }
        /// 将数据序列化进已有的json对象, 覆盖原有数据
        void updateJson(nlohmann::json &j) const { InternalData->updateJson(j); }
        /**
         * 序列化成文本, 可以通过deserializationFromString反序列化, 利于保存
         * @see Contact::fromString()
         */
        std::string toString() const {
            return toJson().dump();
        }
        /// 反序列化成Contact智能指针
        /// @param source 序列化后的文本
        static std::shared_ptr<Contact> deserializeToPointer(nlohmann::json source);
        // for derived class
        template<class T>
        static T deserialize(nlohmann::json source) {
            static_assert(std::is_base_of_v<Contact, T>, "Cannot deserialize class that isn't base on Contact");
            return T(std::move(source));
        }
        /**
        * @brief 上传本地图片，务必要用绝对路径
        * 由于mirai要区分图片发送对象，所以使用本函数上传的图片只能发到群
        * @attention 最大支持图片大小为30MB
        * @throws
        * -可能抛出UploadException异常代表路径无效或大小大于30MB
        * -可能抛出MemberException找不到群或群成员
        */
        Image uploadImg(const std::string &path) const;
        FlashImage uploadFlashImg(const std::string &path) const;
    protected:
        /// 发送语音
        MessageSource sendVoiceImpl(std::string path) const;
        /// 发送纯文本信息
        /// @throw IllegalArgumentException, TimeOutException, BotIsBeingMutedException
        MessageSource sendMsgImpl(std::string msg) const;
        MessageSource unpackMsg(const MessageChain &msg) const {
            return sendMsgImpl(msg.toString());
        }
        MessageSource unpackMsg(const MiraiCodeable &msg) const {
            return sendMsgImpl(MessageChain::deserializationFromMiraiCode(msg.toMiraiCode()).toString());
        }
        MessageSource unpackMsg(std::string msg) const {
            return sendMsgImpl(MessageChain(PlainText(std::move(msg))).toString());
        }
        MessageSource unpackMsg(const char *msg) const {
            return sendMsgImpl(MessageChain(PlainText(msg)).toString());
        }
    };
    /// @brief Contact类型的数据接口模板类
    /// @note dev: 任何操作内部数据的行为在此处定义。Contact只处理 InternalData 这个 shared_ptr 本身
    template<typename ClassType, typename InternalDataType>
    struct ContactDataHelper {
        typedef InternalDataType DataType;
    protected:
        using json = nlohmann::json;
        /**
         * @brief 获取指向的数据的裸指针，实际取内容时必须通过该函数，否则可能会取不到。
         * @note dev: 为了让getter正常地拥有const语义, 该函数不可以由外部调用.
         *  该函数使用const qualifier, 但返回非const的指针类型. 若允许外部调用可能造成数据问题。
         * @see IMPL_GETTER, INLINE_GETTER
         */
        DataType *GetDataInternal() const {
            auto clz_ptr = static_cast<const ClassType *>(this);
            assert(clz_ptr->InternalData != nullptr);
            return static_cast<DataType *>(clz_ptr->InternalData.get());
        }
    public:
        /// 群名称，群成员群名片，或好友昵称
        std::string nickOrNameCard() const {
            auto dataPtr = GetDataInternal();
            dataPtr->requestRefresh();
            std::shared_lock<std::shared_mutex> local_lck(dataPtr->getMutex());
            return dataPtr->_nickOrNameCard;
        };
        /// 头像url地址
        std::string avatarUrl() const {
            auto dataPtr = GetDataInternal();
            dataPtr->requestRefresh();
            std::shared_lock<std::shared_mutex> local_lck(dataPtr->getMutex());
            return dataPtr->_avatarUrl;
        };
    };
    class INudgeSupport {
    public:
        /*!
         * @brief 发送戳一戳
         * @warning 仅限Friend, Member类调用
         * @see MiraiCP::Friend::sendNudge, MiraiCP::Member::sendNudge
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        virtual void sendNudge() = 0;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CONTACT_H
// #include "commonTypes.h"
#include <string>
#include <vector>
namespace MiraiCP {
    class Friend;       // forward declaration
    class Group;        // forward declaration
    struct InternalBot; // forward declaration
    /// 当前bot账号信息
    class Bot: public Contact {
    public:
        /**
         * 用 id 构造 Bot 对象
         * @param in_id Bot 的 qq id
         */
        explicit Bot(QQID in_id);
    public:
        /**
         * 取 Bot 下对应 id 的好友
         * @param i 好友的 qq id
         * @return 好友对象
         */
        [[nodiscard]] Friend getFriend(QQID i) const;
        /**
         * 取群聊
         * @param groupid 群聊的 id
         * @return 群聊对象
         */
        [[nodiscard]] Group getGroup(QQID groupid) const;
        /// @brief 昵称
        std::string nick();
        /// @brief 头像下载链接
        std::string avatarUrl();
        /// @brief 取好友列表
        [[nodiscard]] std::vector<QQID> getFriendList() const;
        /// @brief 好友列表string形式返回，利于保存
        [[nodiscard]] std::string FriendListToString() const;
        /// @brief 取群列表
        [[nodiscard]] std::vector<QQID> getGroupList() const;
        /// @brief 群列表string形式返回，利于保存
        [[nodiscard]] std::string GroupListToString() const;
        bool operator==(const Bot &b) const {
            return id() == b.id();
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_BOT_H
#ifndef MIRAICP_PRO_CPPPLUGIN_H
#define MIRAICP_PRO_CPPPLUGIN_H
// #include "Logger.h"
// #include "PluginConfig.h"
#include <utility>
namespace MiraiCP {
    /// 插件父类
    class CPPPlugin {
    public:
        // for api-compatible
        ShouldNotUse("请改为初始化静态常量 CPPPlugin::config") explicit CPPPlugin(const PluginConfig &) {
            // 不可覆盖原本的config，这里什么都不做
        }
        explicit CPPPlugin() = default;
        virtual ~CPPPlugin() = default;
    public:
        /// @brief 插件信息，一个插件中该内容不应变化
        MIRAICP_EXPORT const static PluginConfig config;
        /// @brief 插件级logger
        /// @deprecated use Logger::logger instead
        [[deprecated("Use Logger::logger instead")]] static Logger *pluginLogger;
        static std::unique_ptr<CPPPlugin> plugin;
    public:
        /// 插件启用时调用一次
        virtual void onEnable() {}
        virtual void onDisable() {}
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CPPPLUGIN_H
#ifndef MIRAICP_PRO_COMMAND_H
#define MIRAICP_PRO_COMMAND_H
// #include "CPPPlugin.h"
// #include "Exception.h"
// #include "KtOperation.h"
// #include "Logger.h"
// #include "commonTools.h"
#include <optional>
namespace MiraiCP {
    class MessageChain;
    class Bot;
    class Contact;
    /*!
     * @brief 指令 Interface
     * @doxygenEg{1001, command.cpp, 新建自定义命令}
     * @attention loader端的命令只支持从console传入, plugin端是对接 mirai 的RawCommand
     */
    class IRawCommand {
        using string = std::string;
    public:
        struct Config {
        public:
            /// 指令名不能为空
            string primaryName;
            /// 可以为空
            std::vector<string> secondNames;
            /// 用法
            string usage = "null";
            /// 描述
            string description = "null";
            /// 覆盖已有命令
            bool overrideOrigin = false;
            /// 前缀`/`可省略
            bool preFixOption = false;
        };
        virtual IRawCommand::Config config() = 0;
        virtual void onCommand(std::shared_ptr<Contact>, const Bot &, const MessageChain &) = 0;
        IRawCommand() = default;
        virtual ~IRawCommand() = default;
    };
    class CommandManager {
    private:
        CommandManager() = default;
        std::vector<std::shared_ptr<IRawCommand>> commandList;
    public:
        std::shared_ptr<IRawCommand> &operator[](const int &index) { return commandList[index]; }
        /*!
         * @brief 注册一条指令
         * @param command 指令
         * @return 是否注册成功
         */
        template<class T>
        bool registerCommand(T command) {
            static_assert(std::is_base_of_v<IRawCommand, T>, "只支持IRawCommand的派生类");
            nlohmann::json j;
            j["pluginId"] = CPPPlugin::config.id;
            j["usage"] = command.config().usage;
            j["primaryName"] = command.config().primaryName;
            j["secondName"] = command.config().secondNames;
            j["description"] = command.config().description;
            j["override"] = command.config().overrideOrigin;
            j["preFixOption"] = command.config().preFixOption;
            size_t before = commandList.size();
            std::shared_ptr<IRawCommand> c;
            c.reset(new T(command));
            commandList.push_back(c);
            size_t now = commandList.size();
            if (now - before == 1)
                j["bindId"] = now - 1;
            else {
                auto i = std::find(commandList.begin(), commandList.end(), c);
                if (i != commandList.end())
                    j["bindId"] = i - commandList.begin();
                else
                    throw IllegalArgumentException("找不到合适的bindId", MIRAICP_EXCEPTION_WHERE);
            }
            std::string re = KtOperation::ktOperation(KtOperation::CommandReg, j);
            return re == "true";
        }
        static CommandManager commandManager;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_COMMAND_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_CONTACT_H
#define MIRAICP_PRO_CONTACT_H
// #include "IMiraiData.h"
// #include "KtOperation.h"
// #include "LowLevelAPI.h"
// #include "MessageChain.h"
#include <json_fwd.hpp>
#include <string>
namespace MiraiCP {
    /// Contact 类型
    enum ContactType {
        MIRAI_CONTACT = 0,
        /// 好友
        MIRAI_FRIEND = 1,
        /// 群聊
        MIRAI_GROUP = 2,
        /// 群成员
        MIRAI_MEMBER = 3,
        /// bot
        MIRAI_BOT = 4,
        MIRAI_OTHERTYPE = 5,
    };
    /// Contact 内部储存数据抽象类
    struct IContactData : public IMiraiData {
        /// 昵称或者群名片
        std::string _nickOrNameCard;
        /// 头像 url
        std::string _avatarUrl;
        /// id
        QQID _id{};
        /// 所属的 bot 的 id
        QQID _botId{};
        /// Contact 类型
        ContactType _type = MIRAI_CONTACT;
        void deserialize(nlohmann::json inJson) override;
        nlohmann::json internalToJson() const override;
        /// 刷新数据
        void refreshInfo() override;
        /**
         * 更新传入 json 中的数据, 在调用后, 原 json 数据会被更新
         * @param jsonToUpdate 需更新的 json 数据
         * @see nlohmann::update
         */
        void updateJson(nlohmann::json &jsonToUpdate) const;
    };
    struct GroupRelatedData : public IContactData {
        typedef IContactData Super;
        /// group id
        QQID _groupId;
        nlohmann::json internalToJson() const override;
        explicit GroupRelatedData(QQID in_groupid) : _groupId(in_groupid) {}
    };
    /*!
    * @brief group, friend, member的父类
    * @doxygenEg{1002, message.cpp, 发送以及回复群消息}
    */
    class Contact {
        template<typename ClassType, typename InternalDataType>
        friend struct ContactDataHelper;
        // attrs
    protected:
        /// 内部数据
        std::shared_ptr<IContactData> InternalData;
    public:
        /*!
         * @brief 无参初始化Contact类型
         * @internal 禁止使用
         */
        Contact() = delete;
    protected:
        explicit Contact(std::shared_ptr<IContactData> Data) {
            SetInternalData(std::move(Data));
        }
    public:
        /// 虚类 destructor
        virtual ~Contact() = default;
        bool operator==(const Contact &c) const {
            return this->id() == c.id();
        }
        /**
         * @brief 设置内部数据指针
         * @note dev: 避免直接使用 InternalData, 请使用该接口操作 InternalData 指针
         */
        void SetInternalData(std::shared_ptr<IContactData> Data) { InternalData = std::move(Data); }
        /**
         * @brief 尝试一次数据刷新
         * @note 不保证进行刷新, 一般为内部调用. 强制刷新请使用 forceRefreshInfo()
         * @see forceRefreshInfo
         */
        void refreshInfo() {
            InternalData->requestRefresh();
        }
        /**
         * @brief 强制下次 refreshInfo() 调用时刷新数据
         * @note 尽可能调用该函数, 避免不必要的刷新
         * @see refreshInfo
         */
        void forceRefreshNextTime() {
            InternalData->forceRefreshNextTime();
        }
        /**
         * @brief 强制数据刷新
         * @note 频繁刷新可能会有性能损耗
         * @see refreshInfo, forceRefreshNextTime
         */
        void forceRefreshNow() {
            forceRefreshNextTime();
            refreshInfo();
        }
        /**
         * @brief 当前对象类型
         * @see ContactType
         * @note dev: 不会修改, 不需要锁
         *     - ContactType::MIRAI_FRIEND 好友
         *     - ContactType::MIRAI_GROUP 群聊
         *     - ContactType::MIRAI_MEMBER 群成员
         */
        ContactType type() const { return InternalData->_type; }
        /**
         * @brief id 在全部情况存在
         * @note dev: 不会修改，不需要锁
         *      - 当前type为Friend时，为好友id
         *      - 当前type为Group时，为群id
         *      - 当前type为Member时，为群成员id
         * @see MIRAI_CONTACT
         */
        QQID id() const { return InternalData->_id; }
        /**
         * 所属bot
         * @note dev: 不会修改，不需要锁
         */
        QQID botid() const { return InternalData->_botId; };
        /**
         * @brief 回复并发送
         * @param s 内容
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         * @param ms 回复的信息的MessageSource
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         */
        template<typename T>
        MessageSource quoteAndSendMessage(const T &s, MessageSource ms) {
            return this->quoteAndSend1(s, ms);
        }
        /**
         * @brief 回复并发送
         * @param s 内容
         * @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         */
        template<typename... T>
        MessageSource quoteAndSendMessage(const MessageSource &ms, T &&...val) {
            return this->quoteAndSend1(MessageChain(std::forward<T>(val)...), ms);
        }
        /**
         * @brief 发送信息
         * @tparam T 类型
         * 支持:
         * - SingleMessage的派生类
         * - MessageChain
         * - std::string / const char* 相当于发送PlainText()
         * @param msg 内容
         * @return MessageSource
         */
        template<typename... T>
        MessageSource sendMessage(T &&...msg) {
            return this->sendMessage(MessageChain(std::forward<T>(msg)...));
        }
        /**
         * @brief 发送一条Message
         * @detail 支持
         *  - std::string: 相当于发送PlainText(str)
         *  - MiraiCode 相当于发送反序列化MiraiCode后的
         *  - 各种SingleMessage的派生类
         *  - MessageChain
         *  @param msg Message
         *  @return MessageSource
         */
        template<typename T>
        MessageSource sendMessage(T &&msg) {
            return this->unpackMsg(MessageChain(std::forward<T>(msg)));
        }
    private: // private methods
        MessageSource quoteAndSend0(std::string msg, const MessageSource &ms) const;
        MessageSource quoteAndSend1(const SingleMessage &s, const MessageSource &ms) {
            return this->quoteAndSend0(MessageChain(s).toString(), ms);
        }
        MessageSource quoteAndSend1(const std::string &s, const MessageSource &ms) {
            return this->quoteAndSend0(s, ms);
        }
        MessageSource quoteAndSend1(const MessageChain &mc, const MessageSource &ms) {
            return this->quoteAndSend0(mc.toString(), ms);
        }
    public: // serialization
        /// 序列化到json对象
        nlohmann::json toJson() const { return InternalData->toJson(); }
        /// 将数据序列化进已有的json对象, 覆盖原有数据
        void updateJson(nlohmann::json &j) const { InternalData->updateJson(j); }
        /**
         * 序列化成文本, 可以通过deserializationFromString反序列化, 利于保存
         * @see Contact::fromString()
         */
        std::string toString() const {
            return toJson().dump();
        }
        /// 反序列化成Contact智能指针
        /// @param source 序列化后的文本
        static std::shared_ptr<Contact> deserializeToPointer(nlohmann::json source);
        // for derived class
        template<class T>
        static T deserialize(nlohmann::json source) {
            static_assert(std::is_base_of_v<Contact, T>, "Cannot deserialize class that isn't base on Contact");
            return T(std::move(source));
        }
        /**
        * @brief 上传本地图片，务必要用绝对路径
        * 由于mirai要区分图片发送对象，所以使用本函数上传的图片只能发到群
        * @attention 最大支持图片大小为30MB
        * @throws
        * -可能抛出UploadException异常代表路径无效或大小大于30MB
        * -可能抛出MemberException找不到群或群成员
        */
        Image uploadImg(const std::string &path) const;
        FlashImage uploadFlashImg(const std::string &path) const;
    protected:
        /// 发送语音
        MessageSource sendVoiceImpl(std::string path) const;
        /// 发送纯文本信息
        /// @throw IllegalArgumentException, TimeOutException, BotIsBeingMutedException
        MessageSource sendMsgImpl(std::string msg) const;
        MessageSource unpackMsg(const MessageChain &msg) const {
            return sendMsgImpl(msg.toString());
        }
        MessageSource unpackMsg(const MiraiCodeable &msg) const {
            return sendMsgImpl(MessageChain::deserializationFromMiraiCode(msg.toMiraiCode()).toString());
        }
        MessageSource unpackMsg(std::string msg) const {
            return sendMsgImpl(MessageChain(PlainText(std::move(msg))).toString());
        }
        MessageSource unpackMsg(const char *msg) const {
            return sendMsgImpl(MessageChain(PlainText(msg)).toString());
        }
    };
    /// @brief Contact类型的数据接口模板类
    /// @note dev: 任何操作内部数据的行为在此处定义。Contact只处理 InternalData 这个 shared_ptr 本身
    template<typename ClassType, typename InternalDataType>
    struct ContactDataHelper {
        typedef InternalDataType DataType;
    protected:
        using json = nlohmann::json;
        /**
         * @brief 获取指向的数据的裸指针，实际取内容时必须通过该函数，否则可能会取不到。
         * @note dev: 为了让getter正常地拥有const语义, 该函数不可以由外部调用.
         *  该函数使用const qualifier, 但返回非const的指针类型. 若允许外部调用可能造成数据问题。
         * @see IMPL_GETTER, INLINE_GETTER
         */
        DataType *GetDataInternal() const {
            auto clz_ptr = static_cast<const ClassType *>(this);
            assert(clz_ptr->InternalData != nullptr);
            return static_cast<DataType *>(clz_ptr->InternalData.get());
        }
    public:
        /// 群名称，群成员群名片，或好友昵称
        std::string nickOrNameCard() const {
            auto dataPtr = GetDataInternal();
            dataPtr->requestRefresh();
            std::shared_lock<std::shared_mutex> local_lck(dataPtr->getMutex());
            return dataPtr->_nickOrNameCard;
        };
        /// 头像url地址
        std::string avatarUrl() const {
            auto dataPtr = GetDataInternal();
            dataPtr->requestRefresh();
            std::shared_lock<std::shared_mutex> local_lck(dataPtr->getMutex());
            return dataPtr->_avatarUrl;
        };
    };
    class INudgeSupport {
    public:
        /*!
         * @brief 发送戳一戳
         * @warning 仅限Friend, Member类调用
         * @see MiraiCP::Friend::sendNudge, MiraiCP::Member::sendNudge
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        virtual void sendNudge() = 0;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_CONTACT_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_EVENT_H
#define MIRAICP_PRO_EVENT_H
// #include "Bot.h"
// #include "Friend.h"
#ifndef MIRAICP_PRO_FRIEND_H
#define MIRAICP_PRO_FRIEND_H
// #include "Contact.h"
namespace MiraiCP {
    /// 好友类声明
    class Friend : public Contact, public INudgeSupport , public ContactDataHelper<Friend, IContactData>{
        friend class Contact;
    public:
        /*!
         * @brief 构建好友对象
         * @param friendid q号
         * @param botid 对应机器人id
         */
        Friend(QQID friendid, QQID botid);
        /// @brief 构建好友对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "botId":456}
        /// @throw IllegalArgumentException
        explicit Friend(nlohmann::json in_json);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Friend(bool) = delete;
    public:
        /// @brief 删除好友
        /// @note delete是C++关键字
        void deleteFriend();
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_FRIEND_H
// #include "Group.h"
#ifndef MIRAICP_PRO_GROUP_H
#define MIRAICP_PRO_GROUP_H
// #include "Contact.h"
#include <json_fwd.hpp>
#include <utility>
namespace MiraiCP {
    class Member; // forward declaration
    struct GroupData : public GroupRelatedData {
        struct GroupSetting {
            /// 群名称
            std::string name;
            /// 禁言全部
            bool isMuteAll{};
            /// 允许群成员邀请
            bool isAllowMemberInvite{};
            /// 自动同意进群
            bool isAutoApproveEnabled{};
            /// 允许匿名聊天
            bool isAnonymousChatEnabled{};
        };
        /**
         * @brief 群设置
         * @details 使用 Group::updateSetting 上传设置，后面两项由于 https://github.com/mamoe/mirai/issues/1307 还不能改
         */
        GroupSetting _setting;
        explicit GroupData(QQID in_groupid) : GroupRelatedData(in_groupid) {}
        void deserialize(nlohmann::json in_json) override;
        void refreshInfo() override;
    };
    /*!
     * @brief 群聊类
     */
    class Group : public Contact, public ContactDataHelper<Group, GroupData> {
    private:
        friend class Contact;
    public: // nested classes and structs
        /// 群公告参数
        struct AnnouncementParams {
            /// 发送给新成员
            bool send2new;
            /// 需要确认
            bool requireConfirm;
            /// 置顶
            bool pinned;
            /// 引导群成员修改群名片
            bool showEditCard;
            /// 显示弹窗
            bool showPopup;
            /// 序列化到文本
            nlohmann::json serializeToJson();
            //            explicit AnnouncementParams(bool send2New = false, bool requireConfirm = false, bool pinned = false,
            //                                        bool showEditCard = false, bool showPopup = false) : send2new(send2New),
            //                                                                                             requireConfirm(
            //                                                                                                     requireConfirm),
            //                                                                                             pinned(pinned),
            //                                                                                             showEditCard(showEditCard),
            //                                                                                             showPopup(showPopup) {}
        };
        /// 在线群公告
        struct OnlineAnnouncement {
            /// 内容
            std::string content;
            /// 所属bot
            QQID botId;
            /// 所在群id
            QQID groupId;
            /// 发送者id
            QQID senderId;
            /// 发送时间戳
            long long publicationTime;
            /// 唯一识别属性
            std::string fid;
            /// 图片id, 如果不存在即为空
            std::string imageId;
            /// 如果需要确认，即为确认的人数
            int confirmNum;
            /// 公告属性
            AnnouncementParams params;
            /// 删除当前群公告
            /// @throw BotException
            void deleteThis();
            /// 反序列化
            static OnlineAnnouncement deserializeFromJson(const nlohmann::json &);
            //            OnlineAnnouncement(std::string content, AnnouncementParams params,
            //                               QQID groupId, QQID senderId, QQID botId,
            //                               long long int publicationTime, std::string fid, int confirmNum,
            //                               std::string imageId) : content(std::move(content)), botId(botId), params(std::move(params)),
            //                                                             groupId(groupId), senderId(senderId),
            //                                                             publicationTime(publicationTime),
            //                                                             fid(std::move(fid)), confirmNum(confirmNum), imageId(std::move(imageId)) {}
        };
        /// 本地(未发送)群公告
        struct OfflineAnnouncement {
            /// 内容
            std::string content;
            /// 公告属性
            AnnouncementParams params;
            /// 发布群公告
            Group::OnlineAnnouncement publishTo(const Group &);
            //            OfflineAnnouncement(const std::string &content, AnnouncementParams params) : content(content),
            //                                                                                         params(params) {}
        };
        DECL_GETTER(setting)
        /// 群文件的简短描述
        struct file_short_info {
            // 路径带文件名
            std::string path;
            // 唯一id
            std::string id;
        };
    public: // constructors
        ///  @brief 构建以群号构建群对象
        /// @param groupId 群号
        /// @param botId 机器人id
        /// @doxygenEg{1007, group.cpp, 从群号构建群对象}
        Group(QQID groupId, QQID botId);
        /// @brief 构建群对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "botId":456}
        /// @throw IllegalArgumentException
        explicit Group(nlohmann::json in_json);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Group(bool) = delete;
    public: // methods
        /// @brief 获取groupId
        /// @note 同 id()
        INLINE_GETTER(groupId)
        /**
         * @brief 更新群设置, 即覆盖服务器上的群设置
         * @details 从服务器拉去群设置用refreshInfo
         * @param newSetting 新的设置
         * @see Group::refreshInfo()
         */
        void updateSetting(GroupData::GroupSetting newSetting);
        /// 取群成员列表
        /// @return vector<long>
        std::vector<unsigned long long> getMemberList();
        /*!
         * 以string格式取群成员列表
         * @note 格式:
         *  每个群成员id间用逗号分隔
        */
        std::string MemberListToString();
        /// 取群主
        Member getOwner();
        /// 取群成员
        Member getMember(QQID memberid);
        Member operator[](QQID id);
        /// 取群公告列表
        std::vector<OnlineAnnouncement> getAnnouncementsList();
        /// 刷新群聊信息
        //void refreshInfo();
        void quit();
        /*!
        @brief 上传并发送远程(群)文件
        @param path-群文件路径(带文件名),根目录为/
        @param filepath-本地文件路径
        @attention 路径分隔符是 `/`
        @doxygenEg{1008, group.cpp, 发送群文件}
        */
        RemoteFile sendFile(const std::string &path, const std::string &filepath);
        /// 发送语音
        MessageSource sendVoice( std::string path) {
            return sendVoiceImpl(std::move(path));
        }
        /*!
        取群文件信息,会自动搜索子目录
        @param path-群文件路径(不带文件名)
        @param id-文件id,可空，空则为用路径查找(此时路径要带文件名)
        @attention 因为群文件允许重名文件存在的特性，如果没有id该查找并不可靠，只能返回重名文件中的其中一个文件
        @see RemoteFile
        @doxygenEg{1009, group.cpp, 获取群文件}
        */
        RemoteFile getFile(const std::string &path, const std::string &id = "");
        /*!
         * @brief 取文件信息(根据id)
         * @param id 文件id
         * @return 文件
         * @detail 相当于从根目录开始遍历查找文件, 相当于getFile("/", id);
         */
        RemoteFile getFileById(const std::string &id);
        RemoteFile getFileByFile(const RemoteFile &file) {
            return getFileById(file.id);
        }
        /*!
         * 获取path路径下全部文件信息
         * @param path - 远程路径
         * @return 返回值为一个vector容器, 每一项为short_info
         * @doxygenEg{1010, group.cpp, 获取群文件列表}
        */
        std::vector<file_short_info> getFileList(const std::string &path);
        /// 取文件列表以字符串形式返回
        /// @param path 文件夹路径
        std::string getFileListString(const std::string &path);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_GROUP_H
// #include "Logger.h"
// #include "Member.h"
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MEMBER_H
#define MIRAICP_PRO_MEMBER_H
// #include "Contact.h"
namespace MiraiCP {
    /*!
     * @brief Member数据声明
     */
    struct MemberData : public GroupRelatedData {
        typedef IContactData Super;
        unsigned int _permission = 0;
        std::string _specialTitle;
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        bool _anonymous = false;
        explicit MemberData(QQID in_groupid) : GroupRelatedData(in_groupid) {}
        void deserialize(nlohmann::json in_json) override;
        void refreshInfo() override;
    };
    /*!
     * @brief 群成员类声明
     * @doxygenEg{1013, member.cpp, 群成员操作}
     */
    class Member : public Contact, public INudgeSupport, public ContactDataHelper<Member, MemberData> {
        friend class Contact;
    public:
        /// @brief 构建群成员对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "groupId":456, "botId":789}
        /// @throw IllegalArgumentException
        explicit Member(nlohmann::json in_json);
        /// @brief 构建群成员对象
        /// @param qqid 该成员q号
        /// @param groupid 所在群号
        /// @param botid 机器人id
        explicit Member(QQID qqid, QQID groupid, QQID botid);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Member(bool) = delete;
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        DECL_GETTER(anonymous)
        /// @brief 权限等级
        ///     - OWNER群主 为 2
        ///     - ADMINISTRATOR管理员 为 1
        ///     - MEMBER群成员 为 0
        DECL_GETTER(permission)
        /// 群头衔
        DECL_GETTER(specialTitle)
        INLINE_GETTER(groupId)
    public:
        /// @brief 更改群成员权限
        /// @param admin 如果为true为更改到管理员
        /// @param env
        void modifyAdmin(bool admin);
        /// @brief 更改群成员群头衔
        /// @throws BotException 如果没权限时
        void changeSpecialTitle(std::string_view);
        /// 发送语音
        MessageSource sendVoice(std::string path) {
            return sendVoiceImpl(std::move(path));
        }
        /*!
         * 禁言当前对象，单位是秒，最少0秒最大30天，如果为0或者为负则unmute
         * @throws BotException, MuteException
        */
        void mute(long long sec) const;
        /*!
         * 使用现代C++时间禁言对象，可以是任意时间，传参时会被自动转换为秒
         * @throws BotException, MuteException
        */
        void mute(std::chrono::seconds time) const {
            mute(time.count());
        }
        /// 取消禁言
        /// @throws BotException, MuteException
        void unMute() const {
            mute(0);
        }
        /*! 踢出这个群成员
        * @param reason - 原因
        */
        void kick(std::string reason);
        /// At一个群成员
        At at() { return At(this->id()); }
        /// 更改群名片
        /// @throw MiraiCP::BotException 如果没权限时
        void changeNameCard(std::string_view newName);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MEMBER_H
#include <utility>
namespace MiraiCP {
    /// Event 工厂
    namespace eventTypes {
        enum Types {
            BaseEvent [[maybe_unused]] = -1,
            BotOnlineEvent,                 // 0
            BotJoinGroupEvent,              // 1
            GroupInviteEvent,               // 2
            BotLeaveEvent,                  // 3
            FriendMessageEvent,             // 4
            GroupMessageEvent,              // 5
            GroupTempMessageEvent,          // 6
            FriendRecallEvent,              // 7
            MemberRecallEvent,              // 8
            MessagePreSendEvent,            // 9
            NudgeEvent,                     // 10
            NewFriendRequestEvent,          // 11
            MemberLeaveEvent,               // 12
            MemberJoinEvent,                // 13
            MemberJoinRequestEvent,         // 14
            TimeOutEvent,                   // 15
            MiraiCPExceptionEvent = 16,     // 16 todo 暂时保持
            Command = 17,                   // 17
            count,                          // 事件在此位置前定义，此时count为事件种类数
            error                           // 出现问题时使用此enum
        };
    }
    class BaseEventData {
    public:
        class BuiltInContact {
        public:
            enum ContactType{
                TypeFriend = 1, // 1
                TypeGroup,      // 2
                TypeMember,     // 3
                TypeBot,        // 4
                TypeStranger,   // 5
                TypeAnonymousMember     // 6
            };
            QQID id{};
            QQID botId{};
            QQID groupId{};
            ContactType type{};
            explicit BuiltInContact(nlohmann::json in_json);
            std::shared_ptr<Contact> toContactPointer();
        };
        std::optional<BuiltInContact> subject = std::nullopt;
        std::optional<BuiltInContact> object = std::nullopt;
        QQID botId;
        nlohmann::json eventData;
        explicit BaseEventData(nlohmann::json j);
    };
    /// Event抽象父类
    class MiraiCPEvent {
    public:
        MiraiCPEvent() = default;
        virtual ~MiraiCPEvent() = default;
    public:
        static eventTypes::Types get_event_type() { return eventTypes::Types::error; }
        virtual eventTypes::Types getEventType() const = 0;
    };
    /// 所有事件处理timeoutevent都是机器人事件，指都有机器人实例
    template<class T>
    class BotEvent : public MiraiCPEvent {
    public:
        eventTypes::Types getEventType() const override { return T::get_event_type(); }
        /// 该事件接受的机器人
        Bot bot;
        /// 以该机器人的名义发送日志
        /// @see BotLogger
        IdLogger botlogger;
        explicit BotEvent(QQID botid) : bot(botid), botlogger(botid, &Logger::logger) {}
        virtual ~BotEvent() = default;
    };
    /// MessageEvent类型的抽象接口，用于Message类型多态实现
    class IMessageEvent {
    public:
        /// 获取当前聊天，可能是群，私聊，或群临时会话
        virtual Contact *chat() = 0;
        /// 获取当前聊天的发送人，可能是群成员，私聊的好友，或群临时会话对应的群成员
        virtual Contact *from() = 0;
        virtual MessageChain *getMessageChain() = 0;
        virtual const Contact *chat() const = 0;
        virtual const Contact *from() const = 0;
        virtual const MessageChain *getMessageChain() const = 0;
    };
    /*!
     * @brief 群消息事件声明
     * @doxygenEg{1003, group.cpp, 取群聊下一条消息}
     */
    class GroupMessageEvent : public BotEvent<GroupMessageEvent>, public IMessageEvent {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::GroupMessageEvent;
        }
    public:
        ///来源群
        Group group;
        ///发送人
        Member sender;
        /// 信息
        MessageChain message;
        //        GroupMessageEvent(QQID botId, Group group, Member sender,
        //                          MessageChain mc) : BotEvent(botId), group(std::move(group)),
        //                                             sender(std::move(sender)), message(std::move(mc)){};
        explicit GroupMessageEvent(BaseEventData j);
        /*!
         * @brief 取群聊下一个消息(群聊与本事件一样)
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不让这个消息被注册的其他监听器收到处理)
         * @return 消息链
         */
        MessageChain nextMessage(long time = -1, bool halt = true) const;
        /*!
         * @brief 取群聊中同群成员的下一个消息(发送人和群与本事件一样)
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不让消息被注册的其他监听器收到处理)
         * @return 消息链
         */
        MessageChain senderNextMessage(long time = -1, bool halt = true) const;
    public:
        Contact *chat() override {
            return &group;
        }
        const Contact *chat() const override {
            return &group;
        }
        Contact *from() override {
            return &sender;
        }
        const Contact *from() const override {
            return &sender;
        }
        MessageChain *getMessageChain() override {
            return &message;
        }
        const MessageChain *getMessageChain() const override {
            return &message;
        }
    };
    /*!
     * @detail 私聊消息事件类声明
     * @doxygenEg{1004, group.cpp, 取好友下一条信息}
     */
    class PrivateMessageEvent : public BotEvent<PrivateMessageEvent>, public IMessageEvent {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::FriendMessageEvent;
        }
    public:
        /// 发起人
        Friend sender;
        /// 信息
        MessageChain message{};
        /*!
         * @brief 构建私聊信息
         * @param botid 对应botid
         * @param sender 发送者
         * @param message 消息
         * @param messageSource 消息源
         */
        explicit PrivateMessageEvent(BaseEventData j);
        /*!
         * @brief 取下一个消息(发送人和接收人和本事件一样)
         * @warning 如果两次发送信息间隔过短可能会漏过信息
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不被注册的监听器收到处理)
         * @return 消息链
         */
        MessageChain nextMessage(long time = -1, bool halt = true) const;
    public:
        Contact *chat() override {
            return &sender;
        }
        const Contact *chat() const override {
            return &sender;
        }
        Contact *from() override {
            return &sender;
        }
        const Contact *from() const override {
            return &sender;
        }
        MessageChain *getMessageChain() override {
            return &message;
        }
        const MessageChain *getMessageChain() const override {
            return &message;
        }
    };
    /// 群聊邀请事件类声明
    class GroupInviteEvent : public BotEvent<GroupInviteEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::GroupInviteEvent;
        }
    public:
        /// 事件序列化文本
        std::string source;
        /// 发起人昵称
        std::string inviterNick;
        /// 被邀请进的组
        std::string groupName;
        /// 群号
        Group group;
        /// 邀请的好友, 如果在邀请后删除好友则为空
        Friend inviter;
        /// 本次申请 id
        size_t requestEventId = 0;
        static void operation0(const std::string &source, QQID botid, bool accept);
        void reject() {
            GroupInviteEvent::operation0(this->source, this->bot.id(), false);
        }
        void accept() {
            GroupInviteEvent::operation0(this->source, this->bot.id(), true);
        }
        explicit GroupInviteEvent(BaseEventData j);
    };
    /// 好友申请事件声明
    class NewFriendRequestEvent : public BotEvent<NewFriendRequestEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::NewFriendRequestEvent;
        }
    public:
        /// @brief 序列化的事件信息
        std::string source;
        /// @brief 对方id
        Friend from;
        /// 如果是从群聊申请的则为来源群, 否则为空
        std::optional<Group> fromGroup;
        /// @brief 对方昵称
        std::string nick;
        /// @brief 申请理由
        std::string message;
        /// @brief 事件识别 id
        size_t requestEventId;
        /// @brief 接受好友申请
        /// @param source 事件序列化信息
        static void operation0(const std::string &source, QQID botId, bool accept, bool ban = false);
        /// @brief 拒绝好友申请
        /// @param ban - 是否加入黑名单
        void reject(bool ban = false) {
            NewFriendRequestEvent::operation0(this->source, this->bot.id(), false, ban);
        }
        /// @brief 接受申请
        void accept() {
            NewFriendRequestEvent::operation0(this->source, this->bot.id(), true);
        }
        explicit NewFriendRequestEvent(BaseEventData j);
    };
    /// 新群成员加入
    class MemberJoinEvent : public BotEvent<MemberJoinEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberJoinEvent;
        }
    public:
        enum joinType {
            error = 0,
            invited = 1,
            applied = 2,
            rehab = 3
        };
        /*!
        * @brief 事件类型
        *   1 - 被邀请进来
        *   2 - 主动加入
        *   3 - 原群主通过 https://huifu.qq.com/ 恢复原来群主身份并入群
        */
        joinType type = joinType::error;
        ///新进入的成员
        Member member;
        ///目标群
        Group group;
        ///邀请人, 当type = 1时存在，否则则和member变量相同
        std::optional<Member> inviter;
        /*!
         * @brief 新群成员入群事件
         * @param botid botId
         * @param type 类别 @see MemberJoinEvent::type
         * @param member 入群群成员
         * @param group 群组
         * @param inviterid 邀请群成员id，如果不存在和member id参数一致
         */
        //        MemberJoinEvent(QQID botId, int type, const Member &member, const Group &group,
        //                        QQID inviterid) : BotEvent(botId), type(joinType(type)), member(member),
        //                                          group(group),
        //                                          inviterid(inviterid) {}
        explicit MemberJoinEvent(BaseEventData j);
    };
    /// 群成员离开
    class MemberLeaveEvent : public BotEvent<MemberLeaveEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberLeaveEvent;
        }
    public:
        /// 退出的成员q号
        Member member;
        /// 目标群
        Group group;
        /// 操作人, 主动退出时与member相同，该成员可能是当前bot，名称为operater以与系统operator区分
        std::optional<Member> operater;
        /*!
        * @brief 事件类型
        *           1 - 被踢出
        *           2 - 主动退出
        */
        int type = 0;
        explicit MemberLeaveEvent(BaseEventData j);
    };
    class FriendRecallEvent: public BotEvent<FriendRecallEvent>{
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::FriendRecallEvent;
        }
    public:
        /// 时间戳
        int time = 0;
        /// 信息发生着
        Friend author;
        /// 信息撤回者
        Friend operater;
        /// 信息id
        std::string ids;
        /// 信息内部ids
        std::string internalIds;
        explicit FriendRecallEvent(BaseEventData j);
    };
    class MemberRecallEvent: public BotEvent<MemberRecallEvent>{
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberRecallEvent;
        }
    public:
        /// 时间戳
        int time = 0;
        /// 信息发生着
        Member author;
        /// 信息撤回者
        Member operater;
        /// 信息id
        std::string ids;
        /// 信息内部ids
        std::string internalIds;
        explicit MemberRecallEvent(BaseEventData j);
    };
    /// 撤回信息
    namespace RecallEvent {
        // deprecated
        using FriendRecallEvent = FriendRecallEvent;
        // deprecated
        using MemberRecallEvent = MemberRecallEvent;
    };
    /// 机器人进入某群
    class BotJoinGroupEvent : public BotEvent<BotJoinGroupEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::BotJoinGroupEvent;
        }
    public:
        /// 进入的群
        Group group;
        /// 当type=2时存在，为邀请人，否则为空，调用可能会报错
        std::optional<Member> inviter;
        /// 1-主动加入,2-被邀请加入,3-提供恢复群主身份加入
        int type;
        explicit BotJoinGroupEvent(BaseEventData j);
    };
    /// 群临时会话
    class GroupTempMessageEvent : public BotEvent<GroupTempMessageEvent>, public IMessageEvent {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::GroupTempMessageEvent;
        }
    public:
        /// 来源群
        Group group;
        /// 发送人
        Member sender;
        /// 信息
        MessageChain message;
        explicit GroupTempMessageEvent(BaseEventData j);
    public:
        Contact *chat() override {
            return &sender;
        }
        const Contact *chat() const override {
            return &sender;
        }
        Contact *from() override {
            return &sender;
        }
        const Contact *from() const override {
            return &sender;
        }
        MessageChain *getMessageChain() override {
            return &message;
        }
        const MessageChain *getMessageChain() const override {
            return &message;
        }
    };
    /// 定时任务结束
    class TimeOutEvent : public MiraiCPEvent {
    public:
        /// 事件所附信息
        std::string msg;
    public:
        explicit TimeOutEvent(std::string msg) : msg(std::move(msg)) {}
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::TimeOutEvent;
        }
        eventTypes::Types getEventType() const override { return this->get_event_type(); }
    };
    /// 机器人上线事件
    class BotOnlineEvent : public BotEvent<BotOnlineEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::BotOnlineEvent;
        }
    public:
        explicit BotOnlineEvent(QQID botid) : BotEvent(botid) {}
    };
    /*! 戳一戳事件
     * @warning nudgeEvent事件也会被bot自己发的Nudge触发, 可能会造成无限循环
     */
    class NudgeEvent : public BotEvent<NudgeEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::NudgeEvent;
        }
    public:
        ///发送人
        std::shared_ptr<Contact> from;
        /// 目标
        std::shared_ptr<Contact> target;
        /// 发送的环境, 可能为Group / Friend
        std::shared_ptr<Contact> subject;
        explicit NudgeEvent(BaseEventData j);
    };
    /// 机器人退群事件
    /// 可能有3种类型, 主动退/被踢/解散
    /// 目前mirai的botLeave事件还不稳定暂时不支持类型
    class BotLeaveEvent : public BotEvent<BotLeaveEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::BotLeaveEvent;
        }
        /// 事件类型
        enum class EventType {
            /// 主动退出
            Active = 0,
            /// 被踢出
            Kick,
            /// 群被解散
            Disband
        };
    public:
        /// 退出的群
        /// @attension 收到这个事件时已经退出该群, 可能取不到相关信息
        Group group;
        EventType type;
        Member operater;
        //        BotLeaveEvent(QQID ingroupid, QQID botId, int type, QQID operatorId)
        //            : BotEvent(botId),
        //              groupId(ingroupid), type(static_cast<EventType>(type)) {
        //            if (operatorId != -1) {
        //                this->operatorId = operatorId;
        //            }
        //        }
        explicit BotLeaveEvent(BaseEventData j);
    };
    /// 申请加群事件, bot需为管理员或者群主
    class MemberJoinRequestEvent : public BotEvent<MemberJoinRequestEvent> {
    private:
        std::string source;
    public:
        /**
         * @brief 底层通过MemberJoinRequest
         * @param s 序列化后的文本
         */
        static void operate(std::string_view s,
                            QQID botid,
                            bool sign,
                            const std::string &msg = "");
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberJoinRequestEvent;
        }
    public:
        /// 申请的群, 如果不存在就表明广播这个事件的时候机器人已经退出该群
        Group group;
        /// 邀请人, 如果不存在表明这个邀请人退出了群或没有邀请人为主动进群
        std::optional<Member> inviter;
        /// 申请人
        Member from;
        /// 申请人昵称
        std::string fromNick;
        /// 申请信息
        std::string message;
    public:
        explicit MemberJoinRequestEvent(BaseEventData j);
        /// 通过
        void accept() {
            operate(this->source, this->bot.id(), true);
        }
        /// 拒绝
        void reject(const std::string &msg) {
            operate(this->source, this->bot.id(), false, msg);
        }
    };
    /*! 每条消息发送前的事件, 总是在消息实际上被发送和广播MessagePostSendEvent前广播
     * @see MessagePostSendEvent
     * @warning 在这个事件里小心使用sendMessage, 可能会触发无限递归 preSend -> sendMessage -> preSend -> ...
     * */
    class MessagePreSendEvent : public BotEvent<MessagePreSendEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MessagePreSendEvent;
        }
    public:
        /// 发送目标
        std::shared_ptr<Contact> target;
        /// 消息
        MessageChain message;
        //MessagePreSendEvent(std::shared_ptr<Contact> c, MessageChain mc, QQID botId) : BotEvent(botId), target(std::move(c)), message(std::move(mc)) {}
        explicit MessagePreSendEvent(BaseEventData j);
    };
    class MiraiCPExceptionBase; // forward declaration
    /// @brief 异常抛出事件
    class MiraiCPExceptionEvent : public MiraiCPEvent {
    private:
        MiraiCPExceptionBase *exceptionPtr;
    public:
        explicit MiraiCPExceptionEvent(MiraiCPExceptionBase *err) {
            exceptionPtr = err;
        }
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MiraiCPExceptionEvent;
        }
        eventTypes::Types getEventType() const override { return this->get_event_type(); }
        const MiraiCPExceptionBase *getException() const {
            return exceptionPtr;
        }
    };
    /// 事件监听操控, 可用于stop停止监听和resume继续监听
    class NodeHandle {
    private:
        bool _enable;
    public:
        explicit NodeHandle(bool a) : _enable(a) {}
        bool isEnable() const { return _enable; }
        void stop() { _enable = false; }
        void resume() { _enable = true; }
    };
    class MIRAICP_EXPORT Event {
    private: // typedefs
        class eventNode {
        private:
            /// 回调的handle，用于管理
            std::shared_ptr<NodeHandle> _handle;
        public:
            std::function<bool(MiraiCPEvent *)> func;
        public:
            eventNode() : _handle(), func(nullptr) {}
            explicit eventNode(std::function<bool(MiraiCPEvent *)> f) : _handle(new NodeHandle(true)), func(std::move(f)) {}
            eventNode(const eventNode &_o) = default; // for MSVC compatible, or you will get an error
            eventNode(eventNode &&_o) noexcept : _handle(std::move(_o._handle)), func(std::move(_o.func)) {}
        public:
            /// 返回true代表block之后的回调
            bool run(MiraiCPEvent *a) const {
                return _handle->isEnable() && func(a);
            }
            std::shared_ptr<NodeHandle> getHandle() {
                return _handle;
            }
        };
        using priority_level = unsigned char;
        using event_vector = std::vector<eventNode>;
        using eventNodeTable = std::vector<std::map<priority_level, event_vector>>;
    private: // member
        eventNodeTable _all_events_;
    private:
        Event() : _all_events_(int(eventTypes::Types::count)){};
    public: // singleton mode
        static Event processor;
    private:
        template<typename EventClass>
        constexpr static int id() {
            static_assert(std::is_base_of_v<MiraiCPEvent, EventClass>, "只支持广播继承MiraiCPEvent的事件");
            return static_cast<int>(EventClass::get_event_type());
        }
    public:
        static bool noRegistered(int index) {
            return processor._all_events_[index].empty();
        }
        /// 清空全部配置
        static void clear() noexcept {
            for (auto &a: processor._all_events_) a.clear();
        }
        static void incomingEvent(BaseEventData j, int type);
        /// 广播一个事件, 必须为MiraiCPEvent的派生类
        template<typename EventClass>
        static void broadcast(EventClass &&val) {
            static_assert(std::is_base_of_v<MiraiCPEvent, EventClass>, "只支持广播MiraiCPEvent的派生类");
            MiraiCPEvent *p = &val;
            for (auto &&[k, v]: processor._all_events_[id<EventClass>()]) {
                for (auto &&a: v) {
                    if (a.run(p)) return;
                }
            }
        }
        /**
         * @brief 注册一个事件的回调
         * @param T 事件类型
         * @param callback 要注册的回调函数，忽略返回值
         * @param priority_level 优先级，范围：0-255，越低的优先级越先执行，默认100
         * @doxygenEg{1018, callbackHandle.cpp, NodeHandle使用}
         */
        template<typename EventClass>
        static std::shared_ptr<NodeHandle> registerEvent(std::function<void(EventClass)> callback, priority_level level = 100) {
            static_assert(std::is_base_of_v<MiraiCPEvent, EventClass>, "只支持注册MiraiCPEvent的派生类事件");
            std::function<bool(MiraiCPEvent *)> tmp = [=](MiraiCPEvent *p) {
                callback(*static_cast<EventClass *>(p));
                return false;
            };
            auto t = eventNode(tmp);
            auto ans = t.getHandle();
            // 先获得shared_ptr才可以emplace_back
            processor._all_events_[id<EventClass>()][level].emplace_back(std::move(t));
            return ans;
        }
        /**
         * @brief 注册一个可以阻塞后续回调函数的回调。
         * 回调返回true时，将会忽略所有优先级低于当前回调，以及注册顺序晚于当前回调且优先级等于当前回调的所有其他回调函数
         * @param T 事件类型
         * @param callback 要注册的回调函数，必须返回bool值
         * @param priority_level 优先级，范围：0-255，越低的优先级越先执行，默认100
         * @doxygenEg{1019, callbackHandle.cpp, NodeHandle使用}
         */
        template<typename EventClass>
        static std::shared_ptr<NodeHandle> registerBlockingEvent(std::function<bool(EventClass)> callback, priority_level level = 100) {
            static_assert(std::is_base_of_v<MiraiCPEvent, EventClass>, "只支持注册MiraiCPEvent的派生类事件");
            std::function<bool(MiraiCPEvent *)> tmp = [=](MiraiCPEvent *p) {
                return callback(*static_cast<EventClass *>(p));
            };
            auto t = eventNode(tmp);
            auto ans = t.getHandle();
            // 先获得shared_ptr才可以emplace_back
            processor._all_events_[id<EventClass>()][level].emplace_back(std::move(t));
            return ans;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_EVENT_H
#ifndef MIRAICP_PRO_EXCEPTION_H
#define MIRAICP_PRO_EXCEPTION_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "CPPPlugin.h"
#include <exception>
#include <string>
#include <thread>
namespace MiraiCP {
    /// @brief 总异常抽象类，用于一般捕获，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionBase
    class MIRAICP_EXPORT MiraiCPExceptionBase : public ::std::exception {
    protected:
        using string = std::string;
    protected:
        /// @brief 异常内容
        string re;
    public:
        /// @brief 发生异常的文件名
        string filename;
        /// @brief 发生异常的行号
        int lineNum = 0;
    protected:
        /// 受保护构造函数，供子类调用
        MiraiCPExceptionBase(string info, string _filename, int _lineNum) : re(std::move(info)), filename(std::move(_filename)), lineNum(_lineNum) {}
    public:
        ~MiraiCPExceptionBase() override = default;
    public:
        /// 异常信息
        const char *what() const noexcept override { return re.c_str(); }
        /// 返回std::string的异常信息
        string getError() const { return re; }
        /// 实际抛出方法
        void raise() const;
    public: // 暴露的接口
        /// basicRaise 基本抛出方法，子类重写该方法
        virtual void basicRaise() const;
        // CRTP实现一次，调用静态的exceptionType
        /// 获取异常类型，通用接口
        virtual string getExceptionType() const = 0;
        // 每个子类需要单独实现该静态方法
        /// 返回异常的类型，该静态方法无法正确实现多态，请使用 getExceptionType
        /// @see getExceptionType
        static string exceptionType() { return "MiraiCPException"; }
    };
    /// @brief 总异常CRTP抽象类，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException。
    /// 该类是用于继承的基类，需要新的异常类型时，继承该类并以子类作为模板参数。
    /// 子类需要实现的方法：
    /// 1. 构造函数，要求必须委托MiraiCPExceptionCRTP构造。
    /// 2. `static std::string exceptionType()` 返回一个字符串表示异常类型。
    /// 继承该类后异常类能正确实现多态。
    /// @interface MiraiCPExceptionCRTP
    /// @note 请勿给该类增加新的属性。如果要增加属性应在 MiraiCPExceptionBase 中增加
    template<class T>
    class MIRAICP_EXPORT MiraiCPExceptionCRTP : public MiraiCPExceptionBase {
    public:
        /// 委托构造函数
        explicit MiraiCPExceptionCRTP(string _re, string _filename, int _lineNum) : MiraiCPExceptionBase(std::move(_re), std::move(_filename), _lineNum) {
        }
    public:
        // CRTP类型获取实现
        string getExceptionType() const override { return T::exceptionType(); }
    };
    /// @brief 通用MiraiCP异常
    /// @param const string &description, string _filename, int _lineNum
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MiraiCPException : public MiraiCPExceptionCRTP<MiraiCPExceptionBase> {};
    /// 文件读取异常.
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT UploadException : public MiraiCPExceptionCRTP<UploadException> {
    public:
        explicit UploadException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP("上传(图片/文件)异常" + text, std::move(_filename), _lineNum) {}
        static std::string exceptionType() { return "UploadException"; }
    };
    /// 通常为Mirai返回
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT IllegalStateException : public MiraiCPExceptionCRTP<IllegalStateException> {
    public:
        explicit IllegalStateException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP("状态异常:" + text, std::move(_filename), _lineNum) {}
        static std::string exceptionType() { return "IllegalStateException"; }
    };
    /// 内部异常, 通常为json读写问题
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT APIException : public MiraiCPExceptionCRTP<APIException> {
    public:
        explicit APIException(const std::string &text, string _filename, int _lineNum) : MiraiCPExceptionCRTP("MiraiCP内部无法预料的错误:" + text, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "APIException"; }
    };
    /// 机器人操作异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT BotException : public MiraiCPExceptionCRTP<BotException> {
    public:
        explicit BotException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("没有权限执行该操作", std::move(_filename), _lineNum) {}
        explicit BotException(const string &d, string _filename, int _lineNum) : MiraiCPExceptionCRTP(d, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "BotException"; }
    };
    /// 被禁言异常, 通常发生于发送信息
    class MIRAICP_EXPORT BotIsBeingMutedException : public MiraiCPExceptionCRTP<BotIsBeingMutedException> {
    public:
        /// 剩余禁言时间, 单位秒
        int timeRemain;
    public:
        explicit BotIsBeingMutedException(int t, string _filename, int _lineNum) : MiraiCPExceptionCRTP(
                                                                                           "发送信息失败, bot已被禁言, 剩余时间" + std::to_string(t), std::move(_filename), _lineNum),
                                                                                   timeRemain(t) {}
        static string exceptionType() { return "BotIsBeingMutedException"; }
    };
    /// 禁言异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MuteException : public MiraiCPExceptionCRTP<MuteException> {
    public:
        /*
        *	 禁言时间超出0s~30d
        */
        MuteException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("禁言时长不在0s~30d中间", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "MuteException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MemberException : public MiraiCPExceptionCRTP<MemberException> {
    public:
        enum MemberExceptionType : int {
            OtherType,
            NoSuchGroup,
            NoSuchMember
        };
        MemberExceptionType type = OtherType;
        /*
        *   "1" - 找不到群
        *	"2" - 找不到群成员
        */
        explicit MemberException(int _type, string _filename, int _lineNum) : MiraiCPExceptionCRTP(
                                                                                      [&]() -> string {
                                                                                          type = MemberExceptionType(_type);
                                                                                          switch (type) {
                                                                                              case NoSuchGroup:
                                                                                                  return "找不到群";
                                                                                              case NoSuchMember:
                                                                                                  return "找不到群成员";
                                                                                              default:
                                                                                                  return "";
                                                                                          }
                                                                                      }(),
                                                                                      std::move(_filename), _lineNum) {}
        static string exceptionType() { return "MemberException"; }
    };
    /// 获取群成员错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT FriendException : public MiraiCPExceptionCRTP<FriendException> {
    public:
        /*
        *   找不到好友
        */
        FriendException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("找不到好友", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "FriendException"; }
    };
    /// 获取群错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT GroupException : public MiraiCPExceptionCRTP<GroupException> {
    public:
        GroupException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("找不到群", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "GroupException"; }
    };
    /// 撤回异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT RecallException : public MiraiCPExceptionCRTP<RecallException> {
    public:
        RecallException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("该消息已经被撤回", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "RecallException"; }
    };
    /// 远程资源出现问题
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT RemoteAssetException : public MiraiCPExceptionCRTP<RemoteAssetException> {
    public:
        explicit RemoteAssetException(const string &e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(e, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "RemoteAssetException"; }
    };
    /// 参数错误
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT IllegalArgumentException : public MiraiCPExceptionCRTP<IllegalArgumentException> {
    public:
        explicit IllegalArgumentException(const string &e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(e, std::move(_filename), _lineNum) {
        }
        static string exceptionType() { return "IllegalArgumentException"; }
    };
    /// 超时
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT TimeOutException : public MiraiCPExceptionCRTP<TimeOutException> {
    public:
        explicit TimeOutException(const std::string &e, string _filename, int _lineNum) : MiraiCPExceptionCRTP(e, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "TimeOutException"; }
    };
    /// 事件被取消, 一般出现在发送消息时在preSendMessageEvent取消的时候抛出
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT EventCancelledException : public MiraiCPExceptionCRTP<EventCancelledException> {
    public:
        explicit EventCancelledException(const string &msg, string _filename, int _lineNum) : MiraiCPExceptionCRTP(msg, std::move(_filename), _lineNum) {}
        static string exceptionType() { return "EventCancelledException"; }
    };
    /// 插件没有权限时抛出该异常
    /// 该异常仅可能在插件尝试调用libLoader 高级权限的Api接口时抛出
    /// 如插件尝试重载、加载、卸载插件等操作，但配置文件中并没有赋予该插件权限时
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT PluginNotAuthorizedException : public MiraiCPExceptionCRTP<PluginNotAuthorizedException> {
    public:
        explicit PluginNotAuthorizedException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("插件" + CPPPlugin::config.getId() + "没有管理权限", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "PluginNotAuthorizedException"; }
    };
    /// 插件未加载抛出该异常
    /// 在插件能正常运行时不会抛出，出现该异常事件时请不要再次尝试收发消息等Mirai操作，
    /// 否则可能导致异常处理时再次抛出异常
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT PluginNotEnabledException : public MiraiCPExceptionCRTP<PluginNotEnabledException> {
    public:
        explicit PluginNotEnabledException(string _filename, int _lineNum) : MiraiCPExceptionCRTP("插件" + CPPPlugin::config.getId() + "未加载", std::move(_filename), _lineNum) {}
        static string exceptionType() { return "PluginNotEnabledException"; }
    };
    /// 如果在 MiraiCPNewThread 中捕获到了非 MiraiCP 之外的异常抛出
    /// @see MiraiCPNewThread
    class MiraiCPThreadException : public MiraiCPExceptionCRTP<MiraiCPThreadException> {
    public:
        /// 抛出异常的线程 ID
        std::thread::id threadId;
    public:
        explicit MiraiCPThreadException(const std::string &exception_content, std::thread::id threadId, string _filename, int _lineNum)
            : MiraiCPExceptionCRTP(exception_content + " at threadId: " + getThreadIdStr(threadId), std::move(_filename), _lineNum),
              threadId(threadId) {}
    public:
        std::string getThreadIdStr() const { return getThreadIdStr(threadId); }
    public:
        static string exceptionType() { return "MiraiCPThreadException"; }
    private:
        MIRAICP_EXPORT static std::string getThreadIdStr(const std::thread::id &id);
    };
    void ErrorHandle0(const std::string &name, int line, const std::string &re, const std::string &ErrorMsg = "");
} // namespace MiraiCP
#endif //MIRAICP_PRO_EXCEPTION_H
#ifndef MIRAICP_PRO_FORWARDEDMESSAGE_H
#define MIRAICP_PRO_FORWARDEDMESSAGE_H
// #include "MessageChain.h"
#include <utility>
#include <variant>
namespace MiraiCP {
    class Contact;
    class ForwardedMessage;
    /// 转发信息显示策略, 目前好像只在转发信息内的转发信息生效
    class ForwardedMessageDisplayStrategy {
        using string = std::string;
    public:
        string title = "群聊的聊天记录";
        string brief = "[聊天记录]";
        string source = "聊天记录";
        string summary = "查看1条转发信息";
        std::vector<string> preview{"Name: message"};
        bool operator==(const ForwardedMessageDisplayStrategy& other) const;
    public:
        static ForwardedMessageDisplayStrategy defaultStrategy() { return {}; }
    public:
        ForwardedMessageDisplayStrategy() = default;
        ForwardedMessageDisplayStrategy(std::string title, std::string brief, std::string source, std::string summary, std::vector<std::string> preview) : title(std::move(title)), brief(std::move(brief)), source(std::move(source)), summary(std::move(summary)), preview(std::move(preview)) {}
    public:
        nlohmann::json toJson() const{
            nlohmann::json j;
            j["title"] = title;
            j["brief"] = brief;
            j["source"] = source;
            j["summary"] = summary;
            j["preview"] = preview;
            return j;
        }
        static ForwardedMessageDisplayStrategy fromJson(const nlohmann::json& j){
            return {j["title"], j["brief"], j["source"], j["summary"], j["preview"].get<std::vector<std::string>>()};
        }
    };
    ///聊天记录里每个消息
    /// todo 传入头像
    class ForwardedNode {
    public:
        ///发送者id
        QQID id = 0;
        ///发送者昵称
        std::string name;
        ///发送信息
        MessageChain message;
        ///发送时间(时间戳)
        int time = 0;
    private:
        bool isForwardedMessage;
    public:
        /// @brief 聊天记录里的每条信息
        /// @param id - 发送者id
        /// @param name - 发送者昵称
        /// @param message - 发送的信息
        /// @param time - 发送时间，以时间戳记
        ForwardedNode(QQID id, std::string name, MessageChain message,
                      int time)
            : id(id), name(std::move(name)), message(std::move(message)), time(time), isForwardedMessage(false) {}
        /// @brief 构造聊天记录里每条信息
        /// @param c - 发送者的contact指针
        /// @param message - 发送的信息
        /// @param t - 发送时间，时间戳格式
        ForwardedNode(QQID id, std::string name, ForwardedMessage message, int t);
    public:
        bool isForwarded() const { return isForwardedMessage; }
    };
    /*!转发消息, 由ForwardNode组成
     * @see class ForwardedNode
     * @doxygenEg{1005, forwardMessage.cpp, 构建聊天记录}
     */
    class ForwardedMessage: public SingleMessage {
    private:
        /// 每条信息
        std::vector<ForwardedNode> nodes;
        /// 显示策略
        ForwardedMessageDisplayStrategy display;
    public:
        ForwardedNode &operator[](int i) {
            return nodes[i];
        }
        const ForwardedNode &operator[](int i) const {
            return nodes[i];
        }
        void add(ForwardedNode &&a) { this->nodes.emplace_back(std::move(a)); }
        void add(const ForwardedNode &a) { this->nodes.push_back(a); }
        auto &operator+=(const ForwardedNode &a) {
            this->add(a);
            return *this;
        }
        auto &operator+=(ForwardedNode &&a) {
            this->add(std::move(a));
            return *this;
        }
        bool operator==(const ForwardedMessage &m) const;
    public:
        /*!
        *@brief 构建一条聊天记录
        *@details 第一个参数是聊天记录发生的地方, 然后是每条信息
        */
        ForwardedMessage(std::initializer_list<ForwardedNode> nodes, ForwardedMessageDisplayStrategy display = ForwardedMessageDisplayStrategy::defaultStrategy())
            : nodes(std::vector(nodes)), display(std::move(display)) {}
        explicit ForwardedMessage(std::vector<ForwardedNode> inNodes, ForwardedMessageDisplayStrategy display = ForwardedMessageDisplayStrategy::defaultStrategy())
            : nodes(std::move(inNodes)), display(std::move(display)) {}
        ForwardedMessage(const ForwardedMessage &) = default;
        ForwardedMessage(ForwardedMessage &&) = default;
        nlohmann::json toJson() const override;
    public:
        /// 发送给群或好友或群成员
        MessageSource sendTo(Contact *c) const;
        nlohmann::json nodesToJson() const;
    public:
        static ForwardedMessage deserializationFromMessageJson(const nlohmann::json &j);
    };
    /// 接收到的转发消息, 发送用 MiraiCP::ForwardedMessage
    /// @deprecated Use ForwardedMessage instead
    using OnlineForwardedMessage = ForwardedMessage;
} // namespace MiraiCP
#endif //MIRAICP_PRO_FORWARDEDMESSAGE_H
#ifndef MIRAICP_PRO_FRIEND_H
#define MIRAICP_PRO_FRIEND_H
// #include "Contact.h"
namespace MiraiCP {
    /// 好友类声明
    class Friend : public Contact, public INudgeSupport , public ContactDataHelper<Friend, IContactData>{
        friend class Contact;
    public:
        /*!
         * @brief 构建好友对象
         * @param friendid q号
         * @param botid 对应机器人id
         */
        Friend(QQID friendid, QQID botid);
        /// @brief 构建好友对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "botId":456}
        /// @throw IllegalArgumentException
        explicit Friend(nlohmann::json in_json);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Friend(bool) = delete;
    public:
        /// @brief 删除好友
        /// @note delete是C++关键字
        void deleteFriend();
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_FRIEND_H
#ifndef MIRAICP_PRO_GROUP_H
#define MIRAICP_PRO_GROUP_H
// #include "Contact.h"
#include <json_fwd.hpp>
#include <utility>
namespace MiraiCP {
    class Member; // forward declaration
    struct GroupData : public GroupRelatedData {
        struct GroupSetting {
            /// 群名称
            std::string name;
            /// 禁言全部
            bool isMuteAll{};
            /// 允许群成员邀请
            bool isAllowMemberInvite{};
            /// 自动同意进群
            bool isAutoApproveEnabled{};
            /// 允许匿名聊天
            bool isAnonymousChatEnabled{};
        };
        /**
         * @brief 群设置
         * @details 使用 Group::updateSetting 上传设置，后面两项由于 https://github.com/mamoe/mirai/issues/1307 还不能改
         */
        GroupSetting _setting;
        explicit GroupData(QQID in_groupid) : GroupRelatedData(in_groupid) {}
        void deserialize(nlohmann::json in_json) override;
        void refreshInfo() override;
    };
    /*!
     * @brief 群聊类
     */
    class Group : public Contact, public ContactDataHelper<Group, GroupData> {
    private:
        friend class Contact;
    public: // nested classes and structs
        /// 群公告参数
        struct AnnouncementParams {
            /// 发送给新成员
            bool send2new;
            /// 需要确认
            bool requireConfirm;
            /// 置顶
            bool pinned;
            /// 引导群成员修改群名片
            bool showEditCard;
            /// 显示弹窗
            bool showPopup;
            /// 序列化到文本
            nlohmann::json serializeToJson();
            //            explicit AnnouncementParams(bool send2New = false, bool requireConfirm = false, bool pinned = false,
            //                                        bool showEditCard = false, bool showPopup = false) : send2new(send2New),
            //                                                                                             requireConfirm(
            //                                                                                                     requireConfirm),
            //                                                                                             pinned(pinned),
            //                                                                                             showEditCard(showEditCard),
            //                                                                                             showPopup(showPopup) {}
        };
        /// 在线群公告
        struct OnlineAnnouncement {
            /// 内容
            std::string content;
            /// 所属bot
            QQID botId;
            /// 所在群id
            QQID groupId;
            /// 发送者id
            QQID senderId;
            /// 发送时间戳
            long long publicationTime;
            /// 唯一识别属性
            std::string fid;
            /// 图片id, 如果不存在即为空
            std::string imageId;
            /// 如果需要确认，即为确认的人数
            int confirmNum;
            /// 公告属性
            AnnouncementParams params;
            /// 删除当前群公告
            /// @throw BotException
            void deleteThis();
            /// 反序列化
            static OnlineAnnouncement deserializeFromJson(const nlohmann::json &);
            //            OnlineAnnouncement(std::string content, AnnouncementParams params,
            //                               QQID groupId, QQID senderId, QQID botId,
            //                               long long int publicationTime, std::string fid, int confirmNum,
            //                               std::string imageId) : content(std::move(content)), botId(botId), params(std::move(params)),
            //                                                             groupId(groupId), senderId(senderId),
            //                                                             publicationTime(publicationTime),
            //                                                             fid(std::move(fid)), confirmNum(confirmNum), imageId(std::move(imageId)) {}
        };
        /// 本地(未发送)群公告
        struct OfflineAnnouncement {
            /// 内容
            std::string content;
            /// 公告属性
            AnnouncementParams params;
            /// 发布群公告
            Group::OnlineAnnouncement publishTo(const Group &);
            //            OfflineAnnouncement(const std::string &content, AnnouncementParams params) : content(content),
            //                                                                                         params(params) {}
        };
        DECL_GETTER(setting)
        /// 群文件的简短描述
        struct file_short_info {
            // 路径带文件名
            std::string path;
            // 唯一id
            std::string id;
        };
    public: // constructors
        ///  @brief 构建以群号构建群对象
        /// @param groupId 群号
        /// @param botId 机器人id
        /// @doxygenEg{1007, group.cpp, 从群号构建群对象}
        Group(QQID groupId, QQID botId);
        /// @brief 构建群对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "botId":456}
        /// @throw IllegalArgumentException
        explicit Group(nlohmann::json in_json);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Group(bool) = delete;
    public: // methods
        /// @brief 获取groupId
        /// @note 同 id()
        INLINE_GETTER(groupId)
        /**
         * @brief 更新群设置, 即覆盖服务器上的群设置
         * @details 从服务器拉去群设置用refreshInfo
         * @param newSetting 新的设置
         * @see Group::refreshInfo()
         */
        void updateSetting(GroupData::GroupSetting newSetting);
        /// 取群成员列表
        /// @return vector<long>
        std::vector<unsigned long long> getMemberList();
        /*!
         * 以string格式取群成员列表
         * @note 格式:
         *  每个群成员id间用逗号分隔
        */
        std::string MemberListToString();
        /// 取群主
        Member getOwner();
        /// 取群成员
        Member getMember(QQID memberid);
        Member operator[](QQID id);
        /// 取群公告列表
        std::vector<OnlineAnnouncement> getAnnouncementsList();
        /// 刷新群聊信息
        //void refreshInfo();
        void quit();
        /*!
        @brief 上传并发送远程(群)文件
        @param path-群文件路径(带文件名),根目录为/
        @param filepath-本地文件路径
        @attention 路径分隔符是 `/`
        @doxygenEg{1008, group.cpp, 发送群文件}
        */
        RemoteFile sendFile(const std::string &path, const std::string &filepath);
        /// 发送语音
        MessageSource sendVoice( std::string path) {
            return sendVoiceImpl(std::move(path));
        }
        /*!
        取群文件信息,会自动搜索子目录
        @param path-群文件路径(不带文件名)
        @param id-文件id,可空，空则为用路径查找(此时路径要带文件名)
        @attention 因为群文件允许重名文件存在的特性，如果没有id该查找并不可靠，只能返回重名文件中的其中一个文件
        @see RemoteFile
        @doxygenEg{1009, group.cpp, 获取群文件}
        */
        RemoteFile getFile(const std::string &path, const std::string &id = "");
        /*!
         * @brief 取文件信息(根据id)
         * @param id 文件id
         * @return 文件
         * @detail 相当于从根目录开始遍历查找文件, 相当于getFile("/", id);
         */
        RemoteFile getFileById(const std::string &id);
        RemoteFile getFileByFile(const RemoteFile &file) {
            return getFileById(file.id);
        }
        /*!
         * 获取path路径下全部文件信息
         * @param path - 远程路径
         * @return 返回值为一个vector容器, 每一项为short_info
         * @doxygenEg{1010, group.cpp, 获取群文件列表}
        */
        std::vector<file_short_info> getFileList(const std::string &path);
        /// 取文件列表以字符串形式返回
        /// @param path 文件夹路径
        std::string getFileListString(const std::string &path);
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_GROUP_H
// Copyright (c) 2022 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_IMIRAIDATA_H
#define MIRAICP_PRO_IMIRAIDATA_H
#include "json_fwd.hpp"
#include <atomic>
#include <shared_mutex>
namespace MiraiCP {
    /// 声明 Contact 类数据安全锁接口以及部分实现的抽象类
    struct IMiraiData {
    private:
        /// 锁
        struct MiraiDataLocker final {
            /// 该数据是否上锁
            std::shared_mutex _mtx;
            /// 该数据是否已经初始化
            std::atomic<bool> _inited = false;
        };
    protected:
        /// 锁实例
        mutable MiraiDataLocker Locker;
    public:
        IMiraiData() = default;
        virtual ~IMiraiData() = default;
    public:
        /// 转为json, 由子类实现, 多线程安全(带锁)
        nlohmann::json toJson() const;
    protected:
        /// 读入json数据, 由子类实现, 无锁
        virtual void deserialize(nlohmann::json in_json) = 0;
        /// 转为json, 由子类实现, 无锁
        virtual nlohmann::json internalToJson() const = 0;
        /**
         * 转为json，internalToJson 的具体实现决定, 无锁
         * @see internalToJson
         */
        nlohmann::json internalToString() const;
    public:
        /// 请求一次刷新数据, 但不保证会进行
        void requestRefresh();
        /*!
         * @brief 确保下次调用 requestRefresh 时刷新数据
         * @note 调用该函数本身不会刷新数据
         * @see requestRefresh
         */
        void forceRefreshNextTime();
        /// 序列化为string, 带锁
        std::string toString() const;
        /// 获取锁
        std::shared_mutex &getMutex() {
            return Locker._mtx;
        }
    private:
        /// 刷新数据, 由子类实现
        virtual void refreshInfo() = 0;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_IMIRAIDATA_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_KTOPERATION_H
#define MIRAICP_PRO_KTOPERATION_H
#include <json_fwd.hpp>
/// @brief 配置类声明,  MiraiCP内部使用, 不需要更改或其他操作
/// @internal 一般为MiraiCP内部调用jni接口使用
/// @namespace KtOperation
namespace MiraiCP::KtOperation {
    /// 操作id
    enum operation_set {
        /// 撤回信息
        Recall,
        /// 发送信息
        Send,
        /// 查询信息接口
        RefreshInfo,
        /// 上传图片
        UploadImg,
        /// 取bot相关列表
        QueryBotList,
        /// 上传文件
        SendFile,
        /// 查询文件信息
        RemoteFileInfo,
        /// 查询图片下载地址
        QueryImgInfo,
        /// 禁言
        MuteM,
        /// 查询权限
        QueryM,
        /// 踢出
        KickM,
        /// 取群主
        QueryOwner,
        /// 语音
        Voice,
        /// 群设置
        GroupSetting,
        /// 构建转发信息
        Buildforward,
        /// 好友申请事件
        Nfroperation,
        /// 群聊邀请事件
        Gioperation,
        /// 回复(引用并发送)
        SendWithQuote,
        /// 群公告操作
        Announcement,
        /// 发送戳一戳
        SendNudge,
        /// 下一条信息
        NextMsg,
        /// 更改权限
        ModifyAdmin,
        /// 群成员申请入群
        MemberJoinRequest,
        /// 图片是否已经上传
        ImageUploaded,
        /// 注册指令
        CommandReg,
        /// 改名称
        ChangeNameCard,
        /// 改群头衔
        ChangeSpecialTitle,
    };
    enum QueryBotListCode {
        /// 查询好友列表
        FriendList = 0, // 0
        /// 查询群列表
        GroupList,      // 1
        /// 查询群成员列表
        MemberList,     // 2
    };
    enum AnnouncementOperationCode {
        /// 发布公告
        Delete = 1,      // 1
        /// 删除公告
        Publish,         // 2
    };
    /**
     * @brief 调用 Mirai 操作
     * @param type 操作id
     * @param data 传入数据
     * @return 返回数据
     */
    std::string ktOperation(
            operation_set type,
            const nlohmann::json &data,
            bool catchErr = true,
            const std::string &errorInfo = "");
    /**
     * @brief 调用 Mirai 操作
     * @param type 操作id
     * @param data 传入数据
     * @return 返回数据
     */
    std::string ktOperationStr(
            operation_set type,
            const std::string &data,
            bool catchErr = true,
            const std::string &errorInfo = "");
} // namespace MiraiCP::KtOperation
#endif //MIRAICP_PRO_KTOPERATION_H
#ifndef MIRAICP_PRO_LOGGER_H
#define MIRAICP_PRO_LOGGER_H
// #include "MiraiCode.h"
// #include "commonTypes.h"
#include <functional>
#include <sstream>
namespace MiraiCP {
    class MiraiCodeable; // forward declaration
    /*!
    * @class Logger
    * @brief 以MiraiCP的名义发送日志, 日志表现格式是: 2021-06-28 09:37:22 [log level]/MiraiCP: [log content], 为最底层的logger
	* 发送消息级日志
	* @code Logger::logger.info(string) @endcode
	* 发送警告级日志
	* @code Logger::logger.warning(string) @endcode
	* 发送错误级日志
	* @code Logger::logger.error(string) @endcode
    * @doxygenEg{1011, logger.cpp, 自定义日志handle}
    */
    class Logger_interface {
        using string = std::string;
    public:
        /// @brief 封装lambda类型
        /// @param string 日志内容
        /// @param 日志级别
        ///     - 0 info
        ///     - 1 warning
        ///     - 2 error
        typedef std::function<void(string, int)> Action;
        /// @brief loggerhandler会在每次log执行前执行一遍，可用于执行自定义的保存操作等
        struct Handler {
            /// @brief 是否启用
            bool enable = true;
            /// @brief 执行的操作，格式为lambda
            Action action;
        };
        std::shared_ptr<Handler> loggerhandler;
    private:
        static std::string constructString() {
            return "";
        }
        template<class T, class... T1>
        static std::string constructString(T &&val, T1 &&...val1) {
            // todo(Antares): 构造一个std::stringstream消耗很大，改为T类型实现序列化函数，
            //  调用 T::serialize
            std::stringstream sstream;
            sstream << val;
            return sstream.str() + constructString(std::forward<T1>(val1)...);
        }
        template<class... T>
        static std::string constructString(const std::string &a, T &&...val1) {
            return a + constructString(std::forward<T>(val1)...);
        }
        template<class... T>
        static std::string constructString(const MiraiCodeable &val, T &&...val1) {
            return val.toMiraiCode() + constructString(std::forward<T>(val1)...);
        }
        void create_loggerhandler() {
            loggerhandler.reset(new Handler);
        }
    protected:
        /// @brief 日志底层实现封装
        /// @param log 日志内容
        /// @param level 日志等级
        virtual void log_interface(const string &log, int level) = 0;
        void handler_trigger(string log, int level) {
            if (!loggerhandler) create_loggerhandler();
            if (loggerhandler->enable && loggerhandler->action) loggerhandler->action(std::move(log), level);
        }
    public:
        ///发送普通(info级日志)
        template<class... T>
        void info(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 0);
        }
        ///发送警告(warning级日志)
        template<class... T>
        void warning(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 1);
        }
        ///发送错误(error级日志)
        template<class... T>
        void error(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 2);
        }
        /// @brief 设置loggerhandler的action
        /// @param action 执行的操作
        /// @see Logger::handler
        void registerHandle(Action action) {
            if (!this->loggerhandler) create_loggerhandler();
            this->loggerhandler->action = std::move(action);
        }
        /// @brief 设置handler的启用状态
        /// @param state 状态，启用或者关闭
        /// @doxygenEg{1012, logger.cpp, 启用或关闭日志}
        void setHandleState(bool state) {
            if (!this->loggerhandler) create_loggerhandler();
            this->loggerhandler->enable = state;
        }
    };
    class MIRAICP_EXPORT Logger : public Logger_interface {
    private:
        Logger() = default;
    protected:
        /// @brief 日志底层实现封装
        /// @param content 日志内容
        /// @param level 日志等级
        void log_interface(const std::string &content, int level) override;
    public:
        static Logger logger;
    };
    /// 带id(一般为bot账号)的logger
    class IdLogger : public Logger_interface {
    public:
        QQID id;
    public:
        IdLogger(QQID id, Logger *l) : id(id) {
            this->loggerhandler = l->loggerhandler;
        }
    protected:
        void log_interface(const std::string &content, int level) override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOGGER_H
#ifndef MIRAICP_PRO_LOWLEVELAPI_H
#define MIRAICP_PRO_LOWLEVELAPI_H
#include <json_fwd.hpp>
namespace MiraiCP {
    /// 较底层api
    class LowLevelAPI {
    public:
        /// @brief 取该联系人的一些信息
        /// @param c 该联系人Contact->serializationToString()
        /// @return json格式字符串，待解析
        static std::string getInfoSource(nlohmann::json c);
        /*!
         * @brief 上传图片
         * @param path 本地地址
         * @param c 上传的对象, Contact->serializationToString()
         * @return string 待解析json
         */
        static std::string uploadImg0(std::string, nlohmann::json);
        /// 每个对象的必有信息
        struct info {
            std::string nickOrNameCard;
            std::string avatarUrl;
        };
        /// 获取每个对象必有信息
        /// @see LowLevelAPI::info
        static info info0(const std::string &source);
    };
    /// 判断目前是否可以安全地call LoaderApi
    bool checkSafeCall();
} // namespace MiraiCP
#endif //MIRAICP_PRO_LOWLEVELAPI_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MEMBER_H
#define MIRAICP_PRO_MEMBER_H
// #include "Contact.h"
namespace MiraiCP {
    /*!
     * @brief Member数据声明
     */
    struct MemberData : public GroupRelatedData {
        typedef IContactData Super;
        unsigned int _permission = 0;
        std::string _specialTitle;
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        bool _anonymous = false;
        explicit MemberData(QQID in_groupid) : GroupRelatedData(in_groupid) {}
        void deserialize(nlohmann::json in_json) override;
        void refreshInfo() override;
    };
    /*!
     * @brief 群成员类声明
     * @doxygenEg{1013, member.cpp, 群成员操作}
     */
    class Member : public Contact, public INudgeSupport, public ContactDataHelper<Member, MemberData> {
        friend class Contact;
    public:
        /// @brief 构建群成员对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "groupId":456, "botId":789}
        /// @throw IllegalArgumentException
        explicit Member(nlohmann::json in_json);
        /// @brief 构建群成员对象
        /// @param qqid 该成员q号
        /// @param groupid 所在群号
        /// @param botid 机器人id
        explicit Member(QQID qqid, QQID groupid, QQID botid);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Member(bool) = delete;
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        DECL_GETTER(anonymous)
        /// @brief 权限等级
        ///     - OWNER群主 为 2
        ///     - ADMINISTRATOR管理员 为 1
        ///     - MEMBER群成员 为 0
        DECL_GETTER(permission)
        /// 群头衔
        DECL_GETTER(specialTitle)
        INLINE_GETTER(groupId)
    public:
        /// @brief 更改群成员权限
        /// @param admin 如果为true为更改到管理员
        /// @param env
        void modifyAdmin(bool admin);
        /// @brief 更改群成员群头衔
        /// @throws BotException 如果没权限时
        void changeSpecialTitle(std::string_view);
        /// 发送语音
        MessageSource sendVoice(std::string path) {
            return sendVoiceImpl(std::move(path));
        }
        /*!
         * 禁言当前对象，单位是秒，最少0秒最大30天，如果为0或者为负则unmute
         * @throws BotException, MuteException
        */
        void mute(long long sec) const;
        /*!
         * 使用现代C++时间禁言对象，可以是任意时间，传参时会被自动转换为秒
         * @throws BotException, MuteException
        */
        void mute(std::chrono::seconds time) const {
            mute(time.count());
        }
        /// 取消禁言
        /// @throws BotException, MuteException
        void unMute() const {
            mute(0);
        }
        /*! 踢出这个群成员
        * @param reason - 原因
        */
        void kick(std::string reason);
        /// At一个群成员
        At at() { return At(this->id()); }
        /// 更改群名片
        /// @throw MiraiCP::BotException 如果没权限时
        void changeNameCard(std::string_view newName);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MEMBER_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MESSAGECHAIN_H
#define MIRAICP_PRO_MESSAGECHAIN_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "Exception.h"
// #include "SingleMessage.h"
// #include "commonTools.h"
namespace MiraiCP {
    class MessageSource; // forward declaration
    namespace internal {
        /// @brief 为 std::shared_ptr<SingleMessage> 增加功能的封装类
        /// @note dev: 不可加入其他成员变量
        class Message : public std::shared_ptr<SingleMessage> {
            typedef std::shared_ptr<SingleMessage> Super;
        public:
#if MIRAICP_MSVC
            Message() {} // for MSVC compatible, Message should be default constructable. See MessageChain
#endif
            template<typename T, typename = std::enable_if<std::is_base_of_v<SingleMessage, T>>>
            explicit Message(T msg) {
                reset(new T(std::move(msg)));
            }
            explicit Message(Super msgptr) noexcept : Super(std::move(msgptr)) {}
            // dev: DON'T write copy and move constructors here, otherwise add operator= overloads. See MessageChain
        public:
            /// 代表的子类
            /// @see MessageChain::messageType
            [[nodiscard]] int getType() const {
                return (*this)->internalType;
            };
            /// 取指定类型
            /// @throw IllegalArgumentException
            template<class T>
            T getVal() const {
                // for dev: 不用 get 为了不和shared_ptr重叠
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
                if (T::type() != getType())
                    throw IllegalArgumentException(
                            "cannot convert from " + SingleMessage::getTypeString(getType()) + " to " +
                                    SingleMessage::getTypeString(T::type()),
                            MIRAICP_EXCEPTION_WHERE);
                T *re = static_cast<T *>(std::shared_ptr<SingleMessage>::get());
                if (re == nullptr)
                    throw IllegalArgumentException(
                            "cannot convert from " + SingleMessage::getTypeString(getType()) + " to " +
                                    SingleMessage::getTypeString(T::type()),
                            MIRAICP_EXCEPTION_WHERE);
                return *re;
            }
            [[nodiscard]] std::string toMiraiCode() const {
                return (*this)->toMiraiCode();
            }
            [[nodiscard]] std::string toJson() const {
                return (*this)->toJson();
            }
            bool operator==(const Message &m) const {
                return (*this)->internalType == m->internalType && (*this)->toMiraiCode() == m->toMiraiCode();
            }
            bool operator!=(const Message &m) const {
                return (*this)->internalType != m->internalType || (*this)->toMiraiCode() != m->toMiraiCode();
            }
        };
    } // namespace internal
    /// 消息链, 一般由SingleMessage组成
    class MIRAICP_EXPORT MessageChain : public std::vector<internal::Message>, public MiraiCodeable {
    public: // typedefs
        using Message = internal::Message;
    public:
        /// 如果由MiraiCP构造(incoming)就会存在，否则则不存在
        std::optional<MessageSource> source = std::nullopt;
    public:
        MessageChain(const MessageChain &_o) = default;
        MessageChain(MessageChain &&_o) = default;
        MessageChain() = default;
        ~MessageChain() override = default;
        /*!
         * @brief 从多个参数构建MessageChain
         * @tparam T 多个传入参数的类型
         * 支持以下类型:
         * - std::string / const char* 相当于传入PlainText
         * - SingleMessage的派生类
         * @param args 参数本身
         */
        template<typename... T, typename = std::enable_if_t<!std::is_same_v<std::decay_t<T>..., MessageChain>>>
        explicit MessageChain(T &&...args) {
            constructMessages(std::forward<T>(args)...);
        };
        /// incoming构造器，对第一个参数为MessageSource的特化
        template<class... T>
        explicit MessageChain(MessageSource ms, T &&...args) : source(std::move(ms)) {
            this->constructMessages(std::forward<T>(args)...);
        };
    public:
        [[deprecated("MessageChain继承自std::vector<Message>，无需获取内部vector")]] const std::vector<Message> &vector() const {
            return static_cast<const std::vector<Message> &>(*this);
        }
        std::string toMiraiCode() const override;
        std::vector<std::string> toMiraiCodeVector() const {
            std::vector<std::string> tmp;
            for (auto &&a: *this)
                tmp.emplace_back(a->toMiraiCode());
            return tmp;
        }
        nlohmann::json toJson() const;
        /**
         * @ensure toJson().dump()
         * @return MessageChain serialize to String
         */
        std::string toString() const;
        /// @brief 使用emplace_back构造Message添加元素
        /// @tparam T 任意的SingleMessage的子类对象，但不允许传入SingleMessage本身
        /// @param a 添加的值
        /// @note 如果你已经有一个Message对象，请直接调用emplace_back。
        ///  若你尝试传入一个基类SingleMessage对象，说明你的程序出现了一些问题
        template<typename T, typename = std::enable_if_t<std::is_base_of_v<SingleMessage, std::decay_t<T>> && !std::is_same_v<SingleMessage, std::decay_t<T>>>>
        void add(T &&a) {
            emplace_back(std::forward<T>(a));
        }
        void add(MessageSource val) {
            source = std::move(val);
        }
        /// 筛选出某种类型的消息
        template<class T>
        std::vector<T> filter() {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto &&a: *this) {
                if (a.getType() == T::type())
                    re.emplace_back(a.getVal<T>());
            }
            return re;
        }
        /// 自定义筛选器
        template<class T>
        std::vector<T> filter(const std::function<bool(const Message &)> &func) {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto &&a: *this) {
                if (func(a))
                    re.push_back(a.getVal<T>());
            }
            return re;
        }
        /// 找出第一个指定的type的消息，消息可能不存在
        template<class T>
        std::optional<T> first() {
            for (auto &&a: *this)
                if (a.getType() == T::type())
                    return a.getVal<T>();
            return std::nullopt;
        }
        template<class T>
        [[nodiscard]] MessageChain plus(const T &a) const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            MessageChain tmp(*this);
            tmp.emplace_back(a);
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageChain &mc) const {
            MessageChain tmp(*this);
            tmp.insert(tmp.end(), mc.begin(), mc.end());
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageSource &ms) const {
            MessageChain tmp(*this);
            tmp.source = ms;
            return tmp;
        }
        template<class T>
        MessageChain operator+(const T &msg) const {
            return this->plus(msg);
        }
        bool operator==(const MessageChain &mc) const {
            if (size() != mc.size())
                return false;
            for (size_t i = 0; i < size(); i++) {
                if ((*this)[i] != mc[i])
                    return false;
            }
            return true;
        }
        bool operator!=(const MessageChain &mc) const {
            return !(*this == mc);
        }
        bool empty() const {
            return std::vector<Message>::empty() || toMiraiCode().empty();
        }
        /// @brief 回复并发送
        /// @param s 内容
        /// @param groupid 如果是来源于TempGroupMessage就要提供(因为要找到那个Member)
        /// @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
        /// @detail 支持以下类型传入
        /// - std::string / const char* 相当于传入PlainText(str)
        /// - SingleMessage的各种派生类
        /// - MessageChain
        /// @deprecated use Contact.quoteAndSend or `this->quoteAndSend1(s, groupId, env)`, since v2.8.1
        template<class T>
        ShouldNotUse("use Contact.quoteAndSend") MessageSource
                quoteAndSendMessage(T s, QQID groupid = -1, void *env = nullptr) = delete;
    public: // static functions
        /// @brief 找到miraiCode结尾的`]`
        /// @param s 文本
        /// @param start 开始位置
        /// @return 如果不存在返回-1, 存在则返回index
        static size_t findEnd(const std::string &s, size_t start) {
            size_t pos = start;
            while (pos < s.length()) {
                switch (s[pos]) {
                    case '\\':
                        pos += 2;
                        continue;
                    case ']':
                        return pos;
                }
                pos++;
            }
            return -1;
        }
        /// 从miraicode string构建MessageChain
        static MessageChain deserializationFromMiraiCode(const std::string &m);
        static MessageChain deserializationFromMessageSourceJson(const std::string &msg, bool origin = true) {
            return deserializationFromMessageSourceJson(nlohmann::json::parse(msg), origin);
        }
        /// 从MessageSource json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageSourceJson(nlohmann::json j, bool origin = true);
        /// 从 Message json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageJson(const nlohmann::json &j);
    private: // private methods
        void constructMessages() {}
        template<typename T1, typename... T2, typename = std::enable_if_t<std::is_base_of_v<SingleMessage, std::decay_t<T1>>>>
        void constructMessages(T1 &&h, T2 &&...args) {
            emplace_back(std::forward<T1>(h));
            constructMessages(std::forward<T2>(args)...);
        }
        template<typename... T2>
        void constructMessages(const std::string &h, T2 &&...args) {
            emplace_back(PlainText(h));
            constructMessages(std::forward<T2>(args)...);
        }
        template<typename... T>
        void constructMessages(const MessageChain &mc, T &&...args) {
            insert(end(), mc.begin(), mc.end());
            constructMessages(std::forward<T>(args)...);
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGECHAIN_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MESSAGESOURCE_H
#define MIRAICP_PRO_MESSAGESOURCE_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "commonTypes.h"
#include <string>
namespace MiraiCP {
    class MiraiCodeable; // forward declaration
    /*! 消息源声明
     * @doxygenEg{1014, message.cpp, 回复信息}
    */
     class MIRAICP_EXPORT MessageSource {
     public:
         /// 消息的ids
         std::string ids;
         /// 消息的internalids
         std::string internalids;
         /// 消息源序列化
         std::string source;
         MessageSource() = default;
        /// @deprecated 用Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMiraiCode(MiraiCodeable *msg, QQID groupid = 0,
                                      void *env = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMsg(const std::string &c, QQID groupid = 0,
                                void * = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMiraiCode(const std::string &c, QQID groupid = 0,
                                      void * = nullptr) const = delete;
        /*!
         * @brief 构建消息源
         * @param ids
         * @param internalids
         * @param source
         */
        MessageSource(std::string ids, std::string internalids, std::string source);
        /*!
         * @brief 从json字符串反序列化到MessageSource对象
         * @note json应该为以下格式
         * @code
         * {"ids":"", "internalIds":""}
         * @endcode
         */
        static MessageSource deserializeFromString(const std::string &source);
        std::string serializeToString() const;
        /// @brief 撤回该信息
        void recall() const;
        bool operator==(const MessageSource &ms) const {
            return this->ids == ms.ids && this->internalids == ms.internalids;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MESSAGESOURCE_H
// Copyright (c) 2022 - 2022. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_MIRAICPNEWTHREAD_H
#define MIRAICP_PRO_MIRAICPNEWTHREAD_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "CPPPlugin.h"
// #include "Event.h"
// #include "Exception.h"
// #include "Logger.h"
// #include "ThreadIdentify.h"
#include <ostream>
#include <thread>
namespace MiraiCP {
    /// MiraiCP 对 std::thread 的封装
    class MiraiCPNewThread : public std::thread {
    public:
        MiraiCPNewThread() noexcept = default;
        template<typename Callable, typename... Args>
        explicit MiraiCPNewThread(Callable &&func, Args &&...args)
            : std::thread(
                      [lambda_func = std::forward<Callable>(func)](auto &&...argss) {
                          try {
                              const char *thread_name = CPPPlugin::config.id;
//                              if (!checkPthreadLen(thread_name)) {
//                                  Logger::logger.warning("新线程创建中：插件id过长（Linux内核上限制为15个字节），当遇到致命问题时，MiraiCP可能无法正确排查");
//                              }
//                              platform_set_thread_name(platform_thread_self(), thread_name);
                              lambda_func(std::forward<decltype(argss)>(argss)...);
                          } catch (MiraiCPExceptionBase &e) {
                              e.raise();
                              Event::broadcast(MiraiCPExceptionEvent(&e));
                          } catch (const std::exception &e) {
                              MiraiCPThreadException exNew(std::string(e.what()), std::this_thread::get_id(), MIRAICP_EXCEPTION_WHERE);
                              exNew.raise();
                              Event::broadcast(MiraiCPExceptionEvent(&exNew));
                          } catch (...) {
                              MiraiCPThreadException exNew("unknown exception type", std::this_thread::get_id(), MIRAICP_EXCEPTION_WHERE);
                              exNew.raise();
                              Event::broadcast(MiraiCPExceptionEvent(&exNew));
                          }
                      },
                      std::forward<Args>(args)...) {}
        MiraiCPNewThread &operator=(const std::thread &) = delete;
        MiraiCPNewThread &operator=(const MiraiCPNewThread &) = delete;
        MiraiCPNewThread &operator=(std::thread &&other) {
            static_cast<std::thread &>(*this) = std::move(other);
            return *this;
        }
        MiraiCPNewThread &operator=(MiraiCPNewThread &&other) noexcept {
            static_cast<std::thread &>(*this) = std::move(static_cast<std::thread &>(other));
            return *this;
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MIRAICPNEWTHREAD_H
#ifndef MIRAICP_PRO_MIRAICODE_H
#define MIRAICP_PRO_MIRAICODE_H
#include <string>
namespace MiraiCP {
    /// MiraiCode父类, 指可以被转换成miraicode的类型
    class MiraiCodeable {
    public:
        /// 返回MiraiCode
        virtual std::string toMiraiCode() const = 0;
        virtual ~MiraiCodeable() = default;
    };
    /// @brief miraicode字符串
    /// @attention MiraiCode会把非miraicode组成部分(非[mirai:])转码, 输出转码前的文本用toString, 参考: https://github.com/mamoe/mirai/blob/dev/docs/Messages.md#%E8%BD%AC%E4%B9%89%E8%A7%84%E5%88%99
    /// @detail 为了便捷使用，构造函数不以explicit注释
    class MiraiCode : public MiraiCodeable {
    private:
        std::string content;
    public:
        ~MiraiCode() override = default;
        /// 输出当前内容, 会自动转码
        std::string toString();
        /// 和toString作用一样, 不过不会自动转码
        std::string toMiraiCode() const override {
            return content;
        }
        /// 从MiraiCodeable类型初始化一个miraicode字符串
        MiraiCode(MiraiCodeable *a) { // NOLINT(google-explicit-constructor)
            content = a->toMiraiCode();
        }
        /// 从文本初始化一个miraicode字符串, 根据第二个参数决定是否转码, 默认不转码
        /// @attention 如果是传入文本MiraiCode，请勿转码，转码只是为了[mirai:xxx:<应该转码的部分>], 如果<应该转码>的部分里面含有'[]:,'内容，请调用Tools::escapeToMiraiCode转码
        MiraiCode(const std::string &a, bool convert = false);
        MiraiCode operator+(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode operator+(const std::string &a) {
            return {content + a};
        }
        MiraiCode operator+(const MiraiCode &a) {
            return {content + a.content};
        }
        MiraiCode operator+(MiraiCode *a) {
            return {content + a->content};
        }
        MiraiCode &operator=(const std::string &a) {
            this->content = a;
            return *this;
        }
        MiraiCode plus(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode plus(const std::string &a) {
            return MiraiCode(a) + this;
        }
        /// 不执行转义，适用于已经被MiraiCode转义过的字符串
        static MiraiCode MiraiCodeWithoutEscape(const std::string &a) {
            return {a, false};
        }
        /// 不执行转义，因为MiraiCodeable的toMiraiCode已经转义过了
        static MiraiCode MiraiCodeWithoutEscape(MiraiCodeable *a) {
            return {a->toMiraiCode(), false};
        }
    };
} // namespace MiraiCP
#endif //MIRAICP_PRO_MIRAICODE_H
//
// Created by antares on 11/10/22.
//
#ifndef MIRAICP_PRO_SCHEDULE_H
#define MIRAICP_PRO_SCHEDULE_H
#include <chrono>
#include <string>
namespace MiraiCP {
    /*!
     * @brief 定时任务, 在一定时间后广播**一次**TimeOutEvent
     * @param sec 在多少秒后执行
     * @param msg 附加的string类型信息
     * @doxygenEg{1017, Schedule.h, 定时任务}
     */
    void schedule(size_t sec, const std::string &msg);
    /*!
     * @brief 定时任务, 在一定时间后广播**一次**TimeOutEvent，chrono重载
     * @param sec 在多少秒后执行
     * @param msg 附加的string类型信息
     * @doxygenEg{1017, Schedule.h, 定时任务}
     */
    void schedule(std::chrono::seconds sec, const std::string &msg);
} // namespace MiraiCP
#endif //MIRAICP_PRO_SCHEDULE_H
// Copyright (c) 2020 - 2023. Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_SINGLEMESSAGE_H
#define MIRAICP_PRO_SINGLEMESSAGE_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "MessageSource.h"
// #include "MiraiCode.h"
#include <array>
#include <json_fwd.hpp>
#include <optional>
#include <sstream>
#include <unordered_map>
#include <utility>
namespace MiraiCP {
    // todo(Antares): delete these after the whole refactor is finished
#define SINGLEMESSAGE_REFACTOR_ASSERTION(x, y) static_assert((x) == (y), "static assertion failed when refactoring code")
    namespace SingleMessageType {
        // id 小于 0 的是不能直接发送的消息(仅在接收的 MessageChain 里出现)
        MIRAICP_ITERABLE_ENUM(            // NOLINT(cert-dcl21-cpp)
                -6,                       // begin at
                MessageSource_t,          // -6
                MarketFace_t,             // -5
                OnlineForwardedMessage_t, // -4
                OnlineAudio_t,            // -3
                QuoteReply_t,             // -2
                UnsupportedMessage_t,     // -1
                PlainText_t,              // 0
                At_t,                     // 1
                AtAll_t,                  // 2
                Image_t,                  // 3
                LightApp_t,               // 4
                ServiceMessage_t,         // 5
                RemoteFile_t,             // 6
                Face_t,                   // 7
                FlashImage_t,             // 8
                MusicShare_t              // 9, End = 10
        )
        constexpr const char *miraiCodeNameInternal[] = {
                "NoExists",  // 0
                "NoExists",  // 1
                "NoExists",  // 2
                "NoExists",  // 3
                "NoExists",  // 4
                "NoExists",  // 5
                "NoExists",  // 6
                "at",        // 7
                "atall",     // 8
                "image",     // 9
                "app",       // 10
                "service",   // 11
                "file",      // 12
                "face",      // 13
                "flash",     // 14
                "musicshare" // 15
        };
        constexpr const char *messageTypeInternal[] = {
                "MessageSource",        // -6
                "MarketFace",           // -5
                "ForwardMessage",       // -4
                "OnlineAudio",          // -3
                "QuoteReply",           // -2
                "UnsupportedMessage",   // -1
                "PlainText",            // 0      <-- messageType is here
                "At",                   // 1
                "AtAll",                // 2
                "Image",                // 3
                "LightApp",             // 4
                "SimpleServiceMessage", // 5
                "FileMessage",          // 6
                "Face",                 // 7
                "FlashImage",           // 8
                "MusicShare",           // 9
        };
        static_assert(sizeof(messageTypeInternal) / sizeof(*messageTypeInternal) == SingleMessageType::End - SingleMessageType::Begin);
    } // namespace SingleMessageType
    /// 用serviceMessage的分享信息
    struct URLSharer {
        /// 简介 没点进来看见的样子
        std::string brief = "简介 没点进来看见的样子";
        /// 目标url
        std::string url = "目标url";
        /// 图标地址
        std::string cover = "图标地址";
        /// 标题
        std::string title = "标题";
        /// 描述文字
        std::string summary = "描述文字";
    };
    /// MessageChain的组成部分
    class MIRAICP_EXPORT SingleMessage : public MiraiCodeable {
    public:
    public:
        using Types = SingleMessageType::Type;
        std::string content;
        std::string prefix;
        /// MiraiCode类别
        /// @see SingleMessage::messageType
        int internalType = SingleMessageType::UnsupportedMessage_t;
    protected:
        /// @brief 仅限于让子类允许默认构造，以保证子类可以通过动态判断类型构造
        /// @note dev: 请勿删除
        SingleMessage() = default; // NOLINT(cppcoreguidelines-pro-type-member-init)
    public:
        static const char *const *const messageType;
        static const char *const *const miraiCodeName;
        static std::string getTypeString(int type) {
            return messageType[type];
        }
    public:
        /// @brief 构建单条
        /// @param type 消息类型 @see messageType
        /// @param content 内容
        /// @param prefix 前缀, 默认为`:`, 第二个冒号部分的内容, 目前在serviceMesage有使用
        SingleMessage(int inType, std::string content, std::string prefix = ":") noexcept
            : content(std::move(content)),
              prefix(std::move(prefix)),
              internalType(inType) {}
        virtual ~SingleMessage() noexcept = default;
    public:
        /// @brief 找对应类型的index key
        /// @param value 类型名
        /// @return 如果没找到返回-1
        static int getKey(const std::string &value);
        /**
         * 寻找对应的 MiraiCode 名称
         * @param value 名称
         * @return 如果没找到返回-1
         */
        static int getMiraiCodeKey(const std::string &value);
    public:
        [[nodiscard]] virtual nlohmann::json toJson() const;
        [[nodiscard]] std::string toMiraiCode() const override;
    public:
        bool operator==(const SingleMessage &m) const {
            return this->internalType == m.internalType && this->toMiraiCode() == m.toMiraiCode();
        }
        bool operator==(SingleMessage *m) const {
            return this->internalType == m->internalType && this->toMiraiCode() == m->toMiraiCode();
        }
    };
    /// 纯文本信息
    class MIRAICP_EXPORT PlainText : public SingleMessage {
    public:
        explicit PlainText(const SingleMessage &sg);
        PlainText(PlainText &&_o) noexcept = default;
        PlainText(const PlainText &_o) = default;
        explicit PlainText(std::string inStr) noexcept : SingleMessage(PlainText::type(), std::move(inStr)) {}
        template<typename Stringable, typename = decltype(std::to_string(std::declval<Stringable>()))>
        explicit PlainText(Stringable val) : SingleMessage(PlainText::type(), std::to_string(val)) {}
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(0, Types::PlainText_t);
            return Types::PlainText_t;
        }
    public:
        [[nodiscard]] std::string toMiraiCode() const override {
            return content;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        bool operator==(const PlainText &p) const {
            return this->content == p.content;
        }
    };
    // todo(Antares): 除特殊情况外（子类与基类没有差异）应禁止子类使用父类对象进行构造；或者构造函数直接调用downcast（不安全）
    //  例如 At(const SingleMessage &) 这样的构造函数不应该出现
    /// @
    class MIRAICP_EXPORT At : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(1, Types::At_t);
            return Types::At_t;
        }
        QQID target;
        [[nodiscard]] nlohmann::json toJson() const override;
        explicit At(const SingleMessage &sg);
        explicit At(QQID a) : SingleMessage(At::type(), std::to_string(a)), target(a){};
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:at:" + std::to_string(this->target) + "] "; // 后面有个空格
        }
        bool operator==(const At &a) const {
            return this->target == a.target;
        }
    };
    /// @brief \@全体
    class MIRAICP_EXPORT AtAll : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(2, Types::AtAll_t);
            return Types::AtAll_t;
        }
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:atall] ";
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        AtAll() : SingleMessage(AtAll::type(), "", "") {}
    };
    /// 图像类声明
    class MIRAICP_EXPORT Image : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(3, Types::Image_t);
            return Types::Image_t;
        }
        //图片id，样式:` {xxx}.xx `
        std::string id;
        /*!
         * @brief 图片类型
         *  - png
         *  - bmp
         *  - jpg
         *  - gif
         *  - apng
         *  - unknown
         *  默认 png
         */
        std::string imageType;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> md5;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> url;
        /// 可为0, 来源:用`refreshInfo`可能可以获取或者自己填充, 是isUploaded的必须条件, 默认0
        size_t size{};
        /// 宽度, 默认0, 单位px
        int width{};
        /// 长度, 默认0, 单位px
        int height{};
        /// 是否为 emoji
        bool isEmoji{};
        /*!
         * @brief 图片是否已经上传(如果已经上传即表明可以直接用ImageId发送, 如果没有需要手动上传)
         * @param md5 在kotlin端会用.toByteArray()转换
         * @param size 图片大小, 不能为0
         * @param botid 所属Botid
         * @return 是否已上传
         */
        bool isUploaded(QQID botid);
    protected:
        /// @brief 仅限于让子类允许默认构造，以保证子类可以通过动态判断类型构造
        /// @note dev: 请勿删除
        Image() = default; // NOLINT(cppcoreguidelines-pro-type-member-init)
    public:
        /*!
        * @brief 从图片builder构造，适用于服务器上已经有的图片，即接收到的
        * @param imageId 图片id, 必须
        * @param size isUploaded的必要条件, 单纯用ImageId可能取不到图片size, 需要自己上传
        * @param width 宽度
        * @param height 长度
        * @param type 图片类型
        * @detail 图片miraiCode格式例子, `[mirai:image:{图片id}.jpg]`
        * 可以用这个正则表达式找出id `\\[mirai:image:(.*?)\\]`
        */
        explicit Image(const std::string &imageId, size_t size = 0, int width = 0, int height = 0,
                       std::string type = "PNG",
                       bool isEmoji = false)
            : SingleMessage(Image::type(), imageId), id(imageId), imageType(std::move(type)), size(size),
              width(width), height(height), isEmoji(isEmoji) {
            // todo(Antares): 实际上重复的属性 id 和 content
        }
        /// 刷新信息(获取图片下载Url,md5, size)
        void refreshInfo();
        /// 取图片Mirai码
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:image:" + this->id + "]";
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        static Image deserialize(const std::string &);
        bool operator==(const Image &i) const {
            return this->id == i.id;
        }
    };
    /// 闪照, 和Image属性类似
    class MIRAICP_EXPORT FlashImage : public Image {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(8, Types::FlashImage_t);
            return Types::FlashImage_t;
        }
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:flash:" + this->id + "]";
        }
        explicit FlashImage(const std::string &imageId, size_t size = 0, int width = 0, int height = 0,
                            std::string type = "PNG") : Image(imageId, size, width, height, std::move(type)) {
            this->SingleMessage::internalType = Types::FlashImage_t;
        }
        explicit FlashImage(const Image &img);
        [[nodiscard]] nlohmann::json toJson() const override;
        static FlashImage deserialize(const std::string &);
        bool operator==(const FlashImage &i) const {
            return this->id == i.id;
        }
        /// 转换到普通图片
        Image toImage() { return Image(*this); }
    };
    /*!
    * @brief 小程序卡片
    * @attention 自带的模板不稳定，可能发出现没有效果
    * @doxygenEg{1015, lightApp.cpp, 从文本构建LightApp}
    */
    class MIRAICP_EXPORT LightApp : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(4, Types::LightApp_t);
            return Types::LightApp_t;
        }
        /// @brief 使用纯文本构造，推荐使用其他结构体方法构造
        /// @param content 构造文本
        explicit LightApp(std::string content) : SingleMessage(LightApp::type(), std::move(content)) {}
        explicit LightApp(const SingleMessage &sg);
        [[nodiscard]] nlohmann::json toJson() const override;
        /// 返回miraicode
        [[nodiscard]] std::string toMiraiCode() const override;
        bool operator==(const LightApp &la) const {
            return this->content == la.content;
        }
    };
    /// xml格式的超文本信息
    /// @attention 自带的模板不稳定，可能发出现没有效果
    class MIRAICP_EXPORT ServiceMessage : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(5, Types::ServiceMessage_t);
            return Types::ServiceMessage_t;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        [[nodiscard]] std::string toMiraiCode() const override;
        int id;
        /// @brief ServiceMessage
        /// @param id 在xml内容前面的id (不包括逗号)
        /// @param a xml内容 (不需要事先转码到miraiCode)
        explicit ServiceMessage(int id, std::string a) : SingleMessage(ServiceMessage::type(), std::move(a),
                                                                       ":" + std::to_string(id) + ','),
                                                         id(id) {}
        explicit ServiceMessage(const SingleMessage &sg);
        explicit ServiceMessage(const URLSharer &a) : SingleMessage(5,
                                                                    R"(<?xml version="1.0" encoding="utf-8"?><msg templateID="12345" action="web" brief=")" +
                                                                            a.brief + R"(" serviceID="1" url=")" + a.url +
                                                                            R"("><item layout="2"><picture cover=")" +
                                                                            a.cover + "\"/><title>" + a.title +
                                                                            "</title><summary>" + a.summary +
                                                                            "</summary></item><source/></msg>",
                                                                    ":1,"),
                                                      id(1) {}
        bool operator==(const ServiceMessage &s) const {
            return this->content == s.content;
        }
    };
    /// 引用信息
    class MIRAICP_EXPORT QuoteReply : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-2, Types::QuoteReply_t);
            return Types::QuoteReply_t;
        }
        // 不可直接发送, 发送引用信息用MessageChain.quoteAndSendMessage
        ShouldNotUse("don't have MiraiCode, use MessageChain.quote instead") std::string toMiraiCode() const override {
            return "";
        }
        /// 引用信息的MessageSource
        MessageSource source;
        explicit QuoteReply(const SingleMessage &m);
        explicit QuoteReply(MessageSource source) : SingleMessage(QuoteReply::type(), source.serializeToString()), source(std::move(source)){};
        bool operator==(const QuoteReply &qr) const {
            return this->source == qr.source;
        }
        nlohmann::json toJson() const override;
    };
    /// 接收到的音频文件, 发送用`Contact.sendAudio`
    class MIRAICP_EXPORT OnlineAudio : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-3, Types::OnlineAudio_t);
            return Types::OnlineAudio_t;
        }
        /// 文件名
        std::string filename;
        /// 下载地址
        std::string url;
        /// 文件大小
        int size;
        /// 编码方式
        int codec;
        /// 时长(单位s)
        int length;
        /// 16位md5
        std::array<uint8_t, 16> md5;
        /// 不支持直接发送, 用Contact.sendAudio
        ShouldNotUse("cannot use, use Contact.sendAudio") std::string toMiraiCode() const override {
            return "";
        }
        explicit OnlineAudio(std::string f, std::array<uint8_t, 16> md5, int size, int codec, int length,
                             std::string url) : SingleMessage(OnlineAudio::type(), ""),
                                                filename(std::move(f)), url(std::move(url)), size(size), codec(codec),
                                                length(length), md5(md5){};
        bool operator==(const OnlineAudio &oa) const {
            return this->md5 == oa.md5;
        }
    };
    /// @brief 远程(群)文件类型
    class MIRAICP_EXPORT RemoteFile : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(6, Types::RemoteFile_t);
            return Types::RemoteFile_t;
        }
        /// @brief 下载信息
        /// @see RemoteFile
        struct Dinfo {
            /// 下载地址, 可能会是 `null` 当文件不存在
            std::string url;
            /// md5 可用于校验
            std::string md5;
            /// sha1 可用于校验
            std::string sha1;
        };
        /// @brief 文件信息
        /// @see RemoteFile
        struct Finfo {
            /// 文件大小
            QQID size;
            /// 上传者id
            QQID uploaderid;
            /// 过期时间
            long expirytime;
            /// 上传时间, 时间戳格式
            QQID uploadtime;
            /// 上次更改时间, 时间戳格式
            QQID lastmodifytime;
        };
        /// 文件唯一id, 用于识别
        std::string id;
        /// 文件内部id, 用于构造miraiCode发送
        unsigned int internalid;
        /// 文件名
        std::string name;
        /// 文件大小
        long long size;
        /// 文件在群文件的路径
        /// @attention 可能为空(通常出现于MessageChain从MiraiCode反序列化), 需要从Group重新获取文件
        /// @see Group::getFileByFile
        std::optional<std::string> path;
        /// 文件下载信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Dinfo, Group::getFileByFile
        std::optional<Dinfo> dinfo;
        /// 文件信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Finfo, Group::getFileByFile
        std::optional<Finfo> finfo;
        std::string serializeToString();
        RemoteFile plus(unsigned int ii);
        static RemoteFile deserializeFromString(const std::string &source);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalIds
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p, struct Dinfo d, struct Finfo f);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalIds
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s);
        /// 上传后会自动发送
        ShouldNotUse("Cannot send manually, use Group.sendFile") std::string toMiraiCode() const override {
            return "";
        }
        bool operator==(const RemoteFile &rf) const {
            return this->id == rf.id;
        }
    };
    /// 自带表情
    /// @attention 有些表情会变成PlainText类型和\\xxx 的格式
    class MIRAICP_EXPORT Face : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(7, Types::Face_t);
            return Types::Face_t;
        }
        /**
         * @brief 表情 id
         */
        int id;
        [[nodiscard]] nlohmann::json toJson() const override;
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:face:" + std::to_string(id) + "]";
        }
        explicit Face(int id) : SingleMessage(Face::type(), std::to_string(id)), id(id) {}
        bool operator==(const Face &f) const {
            return this->id == f.id;
        }
    };
    /// 一些可以被mirai识别的音乐卡片, 如果不能被mirai识别, 那应该被表现成lightApp类型(可能收费/vip歌曲用lightApp, 免费用MusicShare)
    class MIRAICP_EXPORT MusicShare : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(9, Types::MusicShare_t);
            return Types::MusicShare_t;
        }
        /// 应用名称, 如NeteaseCloudMusic
        std::string appName;
        /// 歌名
        std::string title;
        /// 卡片第二行的文字内容
        std::string summary;
        /// 点击跳转到的链接
        std::string jumpUrl;
        /// 图片链接
        std::string picUrl;
        /// 音乐文件链接
        std::string musicUrl;
        /// 简介, 点进聊天节目前显示的小文字, 一般是`分享`
        std::string brief;
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:musicshare:" + appName + "," + title + "," + summary + "," + jumpUrl + "," + picUrl + "," + musicUrl + "," + brief + "]";
        }
        MusicShare(std::string appName,
                   std::string title,
                   std::string summary,
                   std::string jumpUrl,
                   std::string picUrl,
                   std::string musicUrl,
                   std::string brief)
            : SingleMessage(MusicShare::type(), ""),
              appName(std::move(appName)),
              title(std::move(title)),
              summary(std::move(summary)),
              jumpUrl(std::move(jumpUrl)),
              picUrl(std::move(picUrl)),
              musicUrl(std::move(musicUrl)),
              brief(std::move(brief)) {}
    };
    class MIRAICP_EXPORT MarketFace : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-5, Types::MarketFace_t);
            return Types::MarketFace_t;
        }
        /// 目前无法直接发送MarketFace, 可以转发
        ShouldNotUse("暂不支持直接发送") std::string toMiraiCode() const override {
            return "";
        }
        std::array<uint8_t, 16> faceId;
        explicit MarketFace(std::array<uint8_t, 16> id) : SingleMessage(MarketFace::type(), ""), faceId(id) {}
        bool operator==(const MarketFace &mf) const {
            return this->faceId == mf.faceId;
        }
    };
    /// @brief 目前不支持的消息类型, 不支持发送
    class MIRAICP_EXPORT UnSupportMessage : public SingleMessage {
    public:
        static int type() {
            SINGLEMESSAGE_REFACTOR_ASSERTION(-1, Types::UnsupportedMessage_t);
            return Types::UnsupportedMessage_t;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        /// 不支持发送
        ShouldNotUse("不支持直接发送UnSupportMessage") std::string toMiraiCode() const override {
            return "";
        }
        explicit UnSupportMessage(const SingleMessage &s) : SingleMessage(s){};
        explicit UnSupportMessage(const std::string &content) : SingleMessage(UnSupportMessage::type(), content) {}
        bool operator==(const UnSupportMessage &m) const {
            return this->content == m.content;
        }
    };
#undef SINGLEMESSAGE_REFACTOR_ASSERTION
} // namespace MiraiCP
#endif //MIRAICP_PRO_SINGLEMESSAGE_H
//
// Created by antares on 11/8/22.
//
#ifndef MIRAICP_PRO_THREADTASK_H
#define MIRAICP_PRO_THREADTASK_H
// #include "Logger.h"
// #include "loaderApiInternal.h"
#include <future>
namespace MiraiCP::ThreadTask {
    namespace internal {
        void task_interface(size_t id);
        size_t get_auto_incr_id();
        void remove_task(size_t id);
        void push_task(size_t id, std::shared_ptr<std::function<void()>> func);
    } // namespace internal
    /// @brief 提交一个任务到线程池，参数与构造 std::thread 以及 MiraiCPNewThread 用的参数相同。
    ///  任务在线程池可用时会被立刻执行
    /// @return 对应任务返回类型的 std::future 对象
    /// @see addTask, MiraiCPNewThread
    template<typename F, typename... Args, typename R = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>>
    std::future<R> promiseTask(F &&func, Args &&...args) {
        auto promise = std::make_shared<std::promise<R>>();
        auto future = promise->get_future();
        std::function<R()> taskfunction = std::bind(std::forward<F>(func), std::forward<Args>(args)...);
        size_t function_id = internal::get_auto_incr_id();
        auto to_push_func = std::make_shared<std::function<void()>>(
                [promise = std::move(promise), function_id, taskfunction = std::move(taskfunction)]() {
                    try {
                        if constexpr (std::is_void_v<R>) {
                            std::invoke(taskfunction);
                            promise->set_value();
                        } else {
                            promise->set_value(std::invoke(taskfunction));
                        }
                    } catch (...) {
                        try {
                            promise->set_exception(std::current_exception());
                            Logger::logger.error("Failed to run task: " + std::to_string(function_id));
                        } catch (...) {
                        }
                    }
                    try {
                        internal::remove_task(function_id);
                    } catch (...) {
                    }
                });
        internal::push_task(function_id, std::move(to_push_func));
        return future;
    }
    /// @brief 提交一个任务到线程池，参数与构造 std::thread 以及 MiraiCPNewThread 用的参数相同。
    ///  任务在线程池可用时会被立刻执行。与 promiseTask 不同，不会给出任务返回值
    /// @see promiseTask, MiraiCPNewThread
    template<typename F, typename... Args, typename R = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>>
    void addTask(F &&func, Args &&...args) {
        if constexpr (std::is_same_v<std::decay_t<F>, void (*)()>) {
            LibLoader::LoaderApi::pushTask(func);
        } else {
            auto function_id = internal::get_auto_incr_id();
            std::function<void()> taskfunction = std::bind(std::forward<F>(func), std::forward<Args>(args)...);
            auto to_push_func = std::make_shared<std::function<void()>>(
                    [function_id, taskfunction = std::move(taskfunction)]() {
                        try {
                            std::invoke(taskfunction);
                        } catch (...) {
                            try {
                                Logger::logger.error("Failed to run task: " + std::to_string(function_id));
                            } catch (...) {
                            }
                        }
                        try {
                            internal::remove_task(function_id);
                        } catch (...) {
                        }
                    });
            internal::push_task(function_id, std::move(to_push_func));
        }
    }
}; // namespace MiraiCP::ThreadTask
#endif //MIRAICP_PRO_THREADTASK_H
#ifndef MIRAICP_PRO_TOOLS_H
#define MIRAICP_PRO_TOOLS_H
// #include "MiraiCPMacros.h"
// -----------------------
// #include "commonTypes.h"
#include <sstream>
#include <string>
#include <vector>
namespace MiraiCP {
    /// @brief 工具类声明, 常用的一些转换工具
    namespace Tools {
        /*!
         * @brief 替换全部在一个字符串中.
         * @param str 原字符串.
         * @param from 需要被替换的字符.
         * @param to 替换到的字符.
         * @return 返回替换后的字符串.
         * @note 来源:https://stackoverflow.com/a/24315631/14646226
         */
        MIRAICP_EXPORT std::string replace(std::string str, std::string_view from, std::string_view to);
        /// @brief 任意类型的vector格式化输出
        /// @param a vector
        /// @return string
        /// @note dev: 尽量避免直接使用，而是使用其特化
        template<typename T>
        inline std::string VectorToString(const std::vector<T> &a, const std::string &separator = ",") {
            std::stringstream ss;
            for (auto it = a.begin(); it != a.end(); ++it) {
                if (it != a.begin()) ss << separator;
                ss << *it;
            }
            return ss.str();
        }
        /// @brief unsigned long long 类型的vector格式化输出，VectorToString<T>的特化
        /// @param a QQID vector
        /// @return string
        template<>
        inline std::string VectorToString(const std::vector<QQID> &a, const std::string &separator) {
            std::string ss;
            for (auto it = a.begin(); it != a.end(); ++it) {
                if (it != a.begin()) ss += separator;
                ss += std::to_string(*it);
            }
            return ss;
        }
        /// @brief string 类型的vector格式化输出，VectorToString<T>的特化
        /// @param a string vector
        /// @return string
        template<>
        inline std::string VectorToString(const std::vector<std::string> &a, const std::string &separator) {
            std::string ans;
            for (auto it = a.begin(); it != a.end(); ++it) {
                if (it != a.begin()) ans += separator;
                ans += *it;
            }
            return ans;
        }
        /// @brief 从string格式化到vector
        /// @param temp string
        /// @return vector
        MIRAICP_EXPORT std::vector<QQID> StringToVector(std::string temp);
        /// @brief 从miraicode转义到正常
        /// @param s 经过miraicode转义的字符串
        /// @return 原字符串
        MIRAICP_EXPORT std::string escapeFromMiraiCode(const std::string &s);
        /// @brief 转义miraicode格式
        MIRAICP_EXPORT std::string escapeToMiraiCode(const std::string &s);
        /// starts_with, from <https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a>
        MIRAICP_EXPORT bool starts_with(std::string_view f, std::string_view s);
        /// compare char with case-insensitive
        MIRAICP_EXPORT bool icompareChar(const char &c1, const char &c2);
        /// case insensitive string compare from https://thispointer.com/c-case-insensitive-string-comparison-using-stl-c11-boost-library/
        MIRAICP_EXPORT bool iequal(std::string_view str1, std::string_view str2);
        /// from https://www.zhihu.com/question/36642771, delim is regex(ignore last `+`)
        MIRAICP_EXPORT std::vector<std::string> split(const std::string &text, const std::string &delim);
        /// @brief 从json中移动数据，被移动的数据使用后就不再存在，主要用于std::string和json
        template<typename T>
        inline T json_mover(nlohmann::json &j, const std::string &key) {
            return std::move(j[key].get_ref<T &>());
        }
        /// @brief 从json中移动数据，被移动的数据使用后就不再存在，json特化
        template<>
        inline nlohmann::json json_mover(nlohmann::json &j, const std::string &key) {
            return std::move(j[key]);
        }
        inline std::string json_stringmover(nlohmann::json &j, const std::string &key) {
            return json_mover<std::string>(j, key);
        }
        inline nlohmann::json json_jsonmover(nlohmann::json &j, const std::string &key) {
            return json_mover<nlohmann::json>(j, key);
        }
        /// @brief id pair工具结构体声明，仅内部使用
        /// @note dev: 为保证可读性请仅在局部作用域使用，且使用聚合初始化
        struct idpair {
            QQID id1;
            QQID id2;
            bool operator==(const idpair &other) const {
                return id1 == other.id1 && id2 == other.id2;
            }
        };
    }; // namespace Tools
} // namespace MiraiCP
/// @brief id pair工具结构体散列特化，用于unordered_map
template<>
struct std::hash<MiraiCP::Tools::idpair> {
    using idpair = MiraiCP::Tools::idpair;
    size_t operator()(const idpair in_pair) const {
        auto First = reinterpret_cast<const char *>(&in_pair);
        size_t Val = 14695981039346656037ULL; // see: type_traits.h (MSVC)
        for (size_t Idx = 0; Idx < sizeof(idpair); ++Idx) {
            Val ^= static_cast<size_t>(First[Idx]);
            Val *= 1099511628211ULL; // see: type_traits.h (MSVC)
        }
        return Val;
    }
};
#endif //MIRAICP_PRO_TOOLS_H
// Copyright (c) 2022 - 2022. Antares, Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
#ifndef MIRAICP_PRO_LOADERAPI_H
#define MIRAICP_PRO_LOADERAPI_H
#include <string>
#include <vector>
// for plugin usage
namespace MiraiCP::LoaderApi {
    /// @brief 返回所有plugin的id
    std::vector<std::string> showAllPluginId();
    /// @brief 启用一个已经加载的插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    void enablePluginById(const std::string &id);
    /// @brief 禁用一个已经启用的插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    void disablePluginById(const std::string &);
    /// @brief 启用全部已加载的插件，仅限有管理权限的插件使用，否则没有任何效果
    void enableAllPlugins();
    /// @brief 禁用全部已启用的插件，仅限有管理权限的插件使用，否则没有任何效果
    void disableAllPlugins();
    /// @brief 加载新的插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param path 插件路径
    /// @param enableNow 是否立即启用
    void loadNewPlugin(const std::string &path, bool enableNow);
    /// @brief 卸载一个插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    void unloadPluginById(const std::string &id);
    /// @brief 重载一个插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    void reloadPluginById(const std::string &id);
} // namespace MiraiCP::LoaderApi
#endif //MIRAICP_PRO_LOADERAPI_H
#ifndef MIRAICP_PRO_UTILS_H
#define MIRAICP_PRO_UTILS_H
// #include "CPPPlugin.h"
// #include "KtOperation.h"
// #include "PluginConfig.h"
// #include "commonTypes.h"
namespace MiraiCP {
    /// 注册插件函数, 需要被插件实现, 类似onStart();
    void enrollPlugin();
    /// 用指针绑定插件
    [[deprecated("use enrollPlugin<T> instead")]] inline void enrollPlugin(CPPPlugin *p) {
        CPPPlugin::plugin.reset(p);
    }
    /// @note dev: 为防止用户插件crash造成内存泄漏等问题，改为用安全一些的make_unique
    template<typename T>
    inline void enrollPlugin() {
        static_assert(std::is_base_of_v<CPPPlugin, T>, "Enrolling plugin type T should be inherited from CPPPlugin");
        CPPPlugin::plugin = std::make_unique<T>();
    }
} // namespace MiraiCP
extern "C" {
MIRAICP_EXPORT int FUNC_ENTRANCE(const LibLoader::LoaderApi::interface_funcs &);
MIRAICP_EXPORT int FUNC_EVENT(const MiraiCP::MiraiCPString &ccontent);
MIRAICP_EXPORT int FUNC_EXIT();
MIRAICP_EXPORT const MiraiCP::PluginConfig *PLUGIN_INFO();
}
#endif //MIRAICP_PRO_UTILS_H
