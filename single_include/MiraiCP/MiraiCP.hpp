// This file is generated automatically by amalgamate;
// GitHub repo https://github.com/0ph1uch1/amalgamate
// When contributing to this repository, please DO NOT edit this file.

// Copyright (C) 2020-2023 Eritque arcus and contributors.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or any later version(in your opinion).
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/// commonTools.h START
#ifndef MIRAICP_PRO_COMMONTOOLS_H
#define MIRAICP_PRO_COMMONTOOLS_H
/// MiraiCPMacros.h START
#pragma clang diagnostic push
#pragma ide diagnostic ignored "bugprone-macro-parentheses"
#ifndef MIRAICP_PRO_MIRAICPMACROS_H
#define MIRAICP_PRO_MIRAICPMACROS_H
static_assert(sizeof(void *) == 8, "Only 64-bit platforms are supported");
static_assert(sizeof(char) == 1, "Please make sure the size of char is 1");
#define MIRAICP_WINDOWS 0
#define MIRAICP_LINUX 0
#define MIRAICP_UNIX 0
#define MIRAICP_IOS 0
#define MIRAICP_MACOS 0
#define MIRAICP_ANDROID 0
#define MIRAICP_TERMUX 0
#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
#undef MIRAICP_WINDOWS
#define MIRAICP_WINDOWS 1
#elif __APPLE__
#include <TargetConditionals.h>
#if TARGET_IPHONE_SIMULATOR || TARGET_OS_MACCATALYST || TARGET_OS_IPHONE
#undef MIRAICP_IOS
#define MIRAICP_IOS 1
#elif TARGET_OS_MAC
#undef MIRAICP_MACOS
#define MIRAICP_MACOS 1
#else
static_assert(false, "Unknown apple platform");
#endif
#elif __ANDROID__
#ifdef __TERMUX__
#undef MIRAICP_TERMUX
#define MIRAICP_TERMUX 1
#else
#undef MIRAICP_ANDROID
#define MIRAICP_ANDROID 1
#endif
#elif __linux__
#undef MIRAICP_LINUX
#define MIRAICP_LINUX 1
#elif __unix__
#undef MIRAICP_UNIX
#define MIRAICP_UNIX 1
#else
static_assert(false, "Unsupported platform");
#endif
#define MIRAICP_MSVC 0
#define MIRAICP_CLANG 0
#define MIRAICP_GCC 0
#define MIRAICP_COMPILER_OTHER 0
#if defined(_MSC_VER)
#undef MIRAICP_MSVC
#define MIRAICP_MSVC 1
#elif defined(__clang__)
#undef MIRAICP_CLANG
#define MIRAICP_CLANG 1
#elif defined(__GNUC__)
#undef MIRAICP_GCC
#define MIRAICP_GCC 1
#else
#undef MIRAICP_COMPILER_OTHER
#define MIRAICP_COMPILER_OTHER 1
#endif
#if MIRAICP_MSVC
#pragma warning(error : 4996)
#define ShouldNotUse(msg) [[deprecated(msg)]]
#elif MIRAICP_GCC
#define ShouldNotUse(msg) [[deprecated(msg)]] __attribute__((error(msg)))
#else
#define ShouldNotUse(msg)
#endif
#include <cassert>
#ifndef assert
#define assert(ignore) ((void) 0)
#endif
#define MIRAICP_EXCEPTION_WHERE __FILE__, __LINE__
#define MIRAICP_THROW(T, ...) throw T(__VA_ARGS__, MIRAICP_EXCEPTION_WHERE)
#define PLUGIN_NORMAL 0
#define PLUGIN_ERROR 1
#define MIRAICP_CRITICAL_NOEXCEPT_BLOCK(statements) \
    try {                                           \
        statements                                  \
    } catch (...) { return PLUGIN_ERROR; }
#define TOKEN_PASTE_INNER(X, Y) X##Y
#define TOKEN_PASTE(X, Y) TOKEN_PASTE_INNER(X, Y)
#define STRINGIFY(A) __STRINGIFY(A)
#ifndef __STRINGIFY
#define __STRINGIFY(A) #A
#endif
#define MIRAICP_DEFER(code)                                                   \
    auto TOKEN_PASTE(_defered_statement_wrapper_, __LINE__) = [&]() { code }; \
    CommonTools::MiraiCPDefer TOKEN_PASTE(_defered_object_, __LINE__)(std::move(TOKEN_PASTE(_defered_statement_wrapper_, __LINE__)))
#define MIRAICP_DEFER_LAMBDA(lambda)                                  \
    auto TOKEN_PASTE(_defered_statement_wrapper_, __LINE__) = lambda; \
    CommonTools::MiraiCPDefer TOKEN_PASTE(_defered_object_, __LINE__)(std::move(TOKEN_PASTE(_defered_statement_wrapper_, __LINE__)))
#define FUNC_ENTRANCE FUNC_ENTRANCE
#define FUNC_EVENT FUNC_EVENT
#define FUNC_EXIT FUNC_EXIT
#define PLUGIN_INFO PLUGIN_INFO
#ifdef MIRAICP_LIB_SDK
#define MIRAICP_ERROR_HANDLE(x, y) ErrorHandle0(__FILE__, __LINE__, (x), (y))
#endif
#define MIRAICP_EXPORT
#if MIRAICP_WINDOWS
#ifdef GOOGLE_TEST
#undef MIRAICP_EXPORT
#define MIRAICP_EXPORT __declspec(dllimport)
#else
#undef MIRAICP_EXPORT
#define MIRAICP_EXPORT __declspec(dllexport)
#endif
#else
#ifndef GOOGLE_TEST
#undef MIRAICP_EXPORT
#define MIRAICP_EXPORT __attribute__((visibility("default")))
#endif
#endif
#define MIRAICP_EXPORT_UNITTEST
#ifdef GOOGLE_TEST
#undef MIRAICP_EXPORT_UNITTEST
#define MIRAICP_EXPORT_UNITTEST __declspec(dllimport)
#else
#ifdef ENABLE_UNITTEST
#undef MIRAICP_EXPORT_UNITTEST
#define MIRAICP_EXPORT_UNITTEST __declspec(dllexport)
#endif
#endif
#define MIRAICP_DATALOCK std::shared_lock<std::shared_mutex> TOKEN_PASTE(local_lck_, __LINE__)(InternalData->getMutex())
#define GET_DATA_INTERNAL() GetDataInternal<LOC_CLASS_NAMESPACE::DataType>(InternalData)
#define DECL_GETTER(type, attr) type attr();
#define IMPL_GETTER(attr)                                                          \
    decltype(LOC_CLASS_NAMESPACE::DataType::_##attr) LOC_CLASS_NAMESPACE::attr() { \
        InternalData->requestRefresh();                                            \
        MIRAICP_DATALOCK;                                                          \
        return GET_DATA_INTERNAL()->_##attr;                                         \
    }
#define NOLOCK_IMPL_GETTER(attr)                                                   \
    decltype(LOC_CLASS_NAMESPACE::DataType::_##attr) LOC_CLASS_NAMESPACE::attr() { \
        return GET_DATA_INTERNAL()->_##attr;                                         \
    }
#define DECL_API(x) decltype(&x) _##x
#define MIRAICP_ITERABLE_ENUM_OPERATOR_PLUSPLUS \
    inline Type &operator++(Type &value) {      \
        value = (Type) ((int) value + 1);       \
        return value;                           \
    }                                           \
    inline Type operator++(Type &value, int) {  \
        Type result = value;                    \
        value = (Type) ((int) value + 1);       \
        return result;                          \
    }
#define MIRAICP_ITERABLE_ENUM(BeginAt, First, ...) \
    enum Type : int {                              \
        First = BeginAt,                           \
##__VA_ARGS__,                             \
        Count,                                     \
        Begin = BeginAt,                           \
        End = Count,                               \
    };                                             \
    MIRAICP_ITERABLE_ENUM_OPERATOR_PLUSPLUS
#endif
#pragma clang diagnostic pop
/// MiraiCPMacros.h END

#include <functional>
namespace CommonTools {
    /// defer class
    /// @see MIRAICP_DEFER
    class MiraiCPDefer {
    public:
        std::function<void()> defer_func;
        MiraiCPDefer(std::function<void()> func) : defer_func(std::move(func)) {
        }
        ~MiraiCPDefer() {
            defer_func();
        }
    };
}
#endif
/// commonTools.h END
/// JsonTools.h START
#ifndef MIRAICP_PRO_JSONTOOLS_H
#define MIRAICP_PRO_JSONTOOLS_H
#include <nlohmann/json.hpp>
namespace MiraiCP{
    /// @brief 从json中移动数据，被移动的数据使用后就不再存在，主要用于std::string和json
    template<typename T>
    inline T json_mover(nlohmann::json &j, const std::string &key) {
        return std::move(j[key].get_ref<T &>());
    }
    /// @brief 从json中移动数据，被移动的数据使用后就不再存在，json特化
    template<>
    inline nlohmann::json json_mover(nlohmann::json &j, const std::string &key) {
        return std::move(j[key]);
    }
    inline std::string json_stringmover(nlohmann::json &j, const std::string &key) {
        return json_mover<std::string>(j, key);
    }
    inline nlohmann::json json_jsonmover(nlohmann::json &j, const std::string &key) {
        return json_mover<nlohmann::json>(j, key);
    }
}
#endif
/// JsonTools.h END
/// Event.h START
#ifndef MIRAICP_PRO_EVENT_H
#define MIRAICP_PRO_EVENT_H
/// EventBase.h START
#ifndef MIRAICP_PRO_EVENTBASE_H
#define MIRAICP_PRO_EVENTBASE_H
/// SdkType.h START
#ifndef MIRAICP_PRO_SDKTYPE_H
#define MIRAICP_PRO_SDKTYPE_H
namespace MiraiCP {
    using QQID = unsigned long long;
}
#endif
/// SdkType.h END

#include <nlohmann/json.hpp>
#include <memory>
#include <optional>
namespace MiraiCP {
    class Contact;
    class MessageChain;
    /// Event 工厂
    namespace eventTypes {
        enum Types {
            BaseEvent [[maybe_unused]] = -1,
            BotOnlineEvent,
            BotJoinGroupEvent,
            GroupInviteEvent,
            BotLeaveEvent,
            FriendMessageEvent,
            GroupMessageEvent,
            GroupTempMessageEvent,
            FriendRecallEvent,
            MemberRecallEvent,
            MessagePreSendEvent,
            NudgeEvent,
            NewFriendRequestEvent,
            MemberLeaveEvent,
            MemberJoinEvent,
            MemberJoinRequestEvent,
            TimeOutEvent,
            MiraiCPExceptionEvent = 16,
            Command = 17,
            count,
            error
        };
    }
    class BaseEventData {
    public:
        class BuiltInContact {
        public:
            enum ContactType {
                TypeFriend = 1,
                TypeGroup,
                TypeMember,
                TypeBot,
                TypeStranger,
                TypeAnonymousMember
            };
            QQID id{};
            QQID botId{};
            QQID groupId{};
            ContactType type{};
            [[nodiscard]] std::string toString() const;
            explicit BuiltInContact(nlohmann::json in_json);
            std::shared_ptr<Contact> toContactPointer();
        };
        std::optional<BuiltInContact> subject = std::nullopt;
        std::optional<BuiltInContact> object = std::nullopt;
        QQID botId;
        nlohmann::json eventData;
        [[nodiscard]] std::string toString() const;
        explicit BaseEventData(nlohmann::json j);
    };
    /// Event抽象父类
    class MiraiCPEvent {
    public:
        MiraiCPEvent() = default;
        virtual ~MiraiCPEvent() = default;
    public:
        static eventTypes::Types get_event_type() { return eventTypes::Types::error; }
        virtual eventTypes::Types getEventType() const = 0;
    };
    /// MessageEvent类型的抽象接口，用于Message类型多态实现
    class IMessageEvent {
    public:
        /// 获取当前聊天，可能是群，私聊，或群临时会话
        virtual Contact *chat() = 0;
        /// 获取当前聊天的发送人，可能是群成员，私聊的好友，或群临时会话对应的群成员
        virtual Contact *from() = 0;
        virtual MessageChain *getMessageChain() = 0;
        virtual const Contact *chat() const = 0;
        virtual const Contact *from() const = 0;
        virtual const MessageChain *getMessageChain() const = 0;
    };
}
#endif
/// EventBase.h END

#include <functional>
#include <map>
#include <memory>
#include <mutex>
#include <shared_mutex>
#include <vector>
namespace MiraiCP {
    class MiraiCPEvent;
    class FriendRecallEvent;
    class MemberRecallEvent;
    /// 撤回信息
    namespace RecallEvent {
        using FriendRecallEvent = MiraiCP::FriendRecallEvent;
        using MemberRecallEvent = MiraiCP::MemberRecallEvent;
    };
    /// 事件监听操控, 可用于stop停止监听和resume继续监听
    class MIRAICP_EXPORT NodeHandle {
        struct NodeHandleInternal;
    private:
        NodeHandleInternal *handle;
    public:
        explicit NodeHandle(bool a);
        NodeHandle(NodeHandle &&) = delete;
        NodeHandle(const NodeHandle &) = delete;
        ~NodeHandle();
        [[nodiscard]] bool isEnable() const;
        void stop();
        void resume();
    };
    class MIRAICP_EXPORT Event {
    private:
        struct eventNode {
        public:
            std::function<bool(MiraiCPEvent *)> func;
        private:
            /// 回调的handle，用于管理
            NodeHandle _handle;
        public:
            eventNode() : func(nullptr), _handle(true) {}
            explicit eventNode(std::function<bool(MiraiCPEvent *)> f) : func(std::move(f)), _handle(true) {}
        public:
            /// 返回true代表block之后的回调
            bool run(MiraiCPEvent *a) const {
                return _handle.isEnable() && func(a);
            }
            NodeHandle *getHandle() {
                return &_handle;
            }
        };
        using priority_level = unsigned char;
        using event_vector = std::vector<std::unique_ptr<eventNode>>;
        using eventNodeTable = std::vector<std::map<priority_level, event_vector>>;
    private:
        eventNodeTable _all_events_;
        mutable std::shared_mutex eventsMtx;
    private:
        Event();
    public:
        static Event processor;
    private:
        template<typename EventClass>
        constexpr static size_t id() {
            static_assert(std::is_base_of_v<MiraiCPEvent, EventClass>, "只支持广播继承MiraiCPEvent的事件");
            return static_cast<size_t>(EventClass::get_event_type());
        }
        bool internalNoRegistered(int index) const;
        void internalClear() noexcept;
        void internalBroadcast(MiraiCPEvent *event, size_t eventId) const;
        NodeHandle *internalRegister(std::function<bool(MiraiCPEvent *)> callback, size_t where, priority_level level);
    public:
        static bool noRegistered(int index) {
            return processor.internalNoRegistered(index);
        }
        /// 清空全部配置
        static void clear() noexcept {
            processor.internalClear();
        }
        static void incomingEvent(BaseEventData j, int type);
        /// 广播一个事件, 必须为MiraiCPEvent的派生类
        template<typename EventClass>
        static void broadcast(EventClass &&val) {
            using UnderlyingClass = std::decay_t<EventClass>;
            static_assert(std::is_base_of_v<MiraiCPEvent, UnderlyingClass>, "只支持广播MiraiCPEvent的派生类");
            MiraiCPEvent *p = &val;
            processor.internalBroadcast(p, id<UnderlyingClass>());
        }
        /**
         * @brief 注册一个事件的回调
         * @param T 事件类型
         * @param callback 要注册的回调函数，忽略返回值
         * @param priority_level 优先级，范围：0-255，越低的优先级越先执行，默认100
         * @doxygenEg{1018, callbackHandle.cpp, NodeHandle使用}
         */
        template<typename EventClass, typename = std::enable_if_t<std::is_base_of_v<MiraiCPEvent, EventClass>>>
        static NodeHandle *registerEvent(std::function<void(EventClass)> callback, priority_level level = 100) {
            std::function<bool(MiraiCPEvent *)> tmp = [=](MiraiCPEvent *p) {
                callback(*static_cast<EventClass *>(p));
                return false;
            };
            return processor.internalRegister(std::move(tmp), id<EventClass>(), level);
        }
        /**
         * @brief 注册一个可以阻塞后续回调函数的回调。
         * 回调返回true时，将会忽略所有优先级低于当前回调，以及注册顺序晚于当前回调且优先级等于当前回调的所有其他回调函数
         * @param T 事件类型
         * @param callback 要注册的回调函数，必须返回bool值
         * @param priority_level 优先级，范围：0-255，越低的优先级越先执行，默认100
         * @doxygenEg{1019, callbackHandle.cpp, NodeHandle使用}
         */
        template<typename EventClass, typename = std::enable_if_t<std::is_base_of_v<MiraiCPEvent, EventClass>>>
        static NodeHandle *registerBlockingEvent(std::function<bool(EventClass)> callback, priority_level level = 100) {
            std::function<bool(MiraiCPEvent *)> tmp = [=](MiraiCPEvent *p) {
                return callback(*static_cast<EventClass *>(p));
            };
            return processor.internalRegister(std::move(tmp), id<EventClass>(), level);
        }
    };
}
#endif
/// Event.h END
/// MiraiCPSchedule.h START
#ifndef MIRAICP_PRO_SCHEDULE_H
#define MIRAICP_PRO_SCHEDULE_H
#include <chrono>
#include <string>
namespace MiraiCP {
    /*!
     * @brief 定时任务, 在一定时间后广播**一次**TimeOutEvent
     * @param sec 在多少秒后执行
     * @param msg 附加的string类型信息
     * @doxygenEg{1017, Schedule.h, 定时任务}
     */
    MIRAICP_EXPORT void schedule(size_t sec, const std::string &msg);
    /*!
     * @brief 定时任务, 在一定时间后广播**一次**TimeOutEvent，chrono重载
     * @param sec 在多少秒后执行
     * @param msg 附加的string类型信息
     * @doxygenEg{1017, Schedule.h, 定时任务}
     */
    MIRAICP_EXPORT void schedule(std::chrono::seconds sec, const std::string &msg);
}
#endif
/// MiraiCPSchedule.h END
/// ForwardedMessage.h START
#ifndef MIRAICP_PRO_FORWARDEDMESSAGE_H
#define MIRAICP_PRO_FORWARDEDMESSAGE_H
/// MessageChain.h START
#ifndef MIRAICP_PRO_MESSAGECHAIN_H
#define MIRAICP_PRO_MESSAGECHAIN_H
/// SingleMessage.h START
#ifndef MIRAICP_PRO_SINGLEMESSAGE_H
#define MIRAICP_PRO_SINGLEMESSAGE_H
/// MessageSource.h START
#ifndef MIRAICP_PRO_MESSAGESOURCE_H
#define MIRAICP_PRO_MESSAGESOURCE_H
#include <string>
namespace MiraiCP {
    class MiraiCodeable;
    /*! 消息源声明
     * @doxygenEg{1014, message.cpp, 回复信息}
    */
     class MIRAICP_EXPORT MessageSource {
     public:
         /// 消息的ids
         std::string ids;
         /// 消息的internalids
         std::string internalids;
         /// 消息源序列化
         std::string source;
         MessageSource() = default;
        /// @deprecated 用Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMiraiCode(MiraiCodeable *msg, QQID groupid = 0,
                                      void *env = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMsg(const std::string &c, QQID groupid = 0,
                                void * = nullptr) const = delete;
        /// @deprecated use Contact.quoteAndSendMessage, since v2.8.1
        ShouldNotUse("Use Contact.quoteAndSendMessage") MessageSource
                quoteAndSendMiraiCode(const std::string &c, QQID groupid = 0,
                                      void * = nullptr) const = delete;
        /*!
         * @brief 构建消息源
         * @param ids
         * @param internalids
         * @param source
         */
        MessageSource(std::string ids, std::string internalids, std::string source);
        /*!
         * @brief 从json字符串反序列化到MessageSource对象
         * @note json应该为以下格式
         * @code
         * {"ids":"", "internalIds":""}
         * @endcode
         */
        static MessageSource deserializeFromString(const std::string &source);
        [[nodiscard]] std::string serializeToString() const;
        /// @brief 撤回该信息
        void recall() const;
        bool operator==(const MessageSource &ms) const;
    };
}
#endif
/// MessageSource.h END

/// MiraiCode.h START
#ifndef MIRAICP_PRO_MIRAICODE_H
#define MIRAICP_PRO_MIRAICODE_H
#include <string>
namespace MiraiCP {
    /// MiraiCode父类, 指可以被转换成miraicode的类型
    class MIRAICP_EXPORT MiraiCodeable {
    public:
        /// 返回MiraiCode
        virtual std::string toMiraiCode() const = 0;
        virtual ~MiraiCodeable() = default;
    };
    /// @brief miraicode字符串
    /// @attention MiraiCode会把非miraicode组成部分(非[mirai:])转码, 输出转码前的文本用toString, 参考: https://github.com/mamoe/mirai/blob/dev/docs/Messages.md#%E8%BD%AC%E4%B9%89%E8%A7%84%E5%88%99
    /// @detail 为了便捷使用，构造函数不以explicit注释
    class MIRAICP_EXPORT MiraiCode : public MiraiCodeable {
    private:
        std::string content;
    public:
        ~MiraiCode() override = default;
        /// 输出当前内容, 会自动转码
        std::string toString();
        /// 和toString作用一样, 不过不会自动转码
        std::string toMiraiCode() const override {
            return content;
        }
        /// 从MiraiCodeable类型初始化一个miraicode字符串
        MiraiCode(MiraiCodeable *a) {
            content = a->toMiraiCode();
        }
        /// 从文本初始化一个miraicode字符串, 根据第二个参数决定是否转码, 默认不转码
        /// @attention 如果是传入文本MiraiCode，请勿转码，转码只是为了[mirai:xxx:<应该转码的部分>], 如果<应该转码>的部分里面含有'[]:,'内容，请调用Tools::escapeToMiraiCode转码
        MiraiCode(const std::string &a, bool convert = false);
        MiraiCode operator+(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode operator+(const std::string &a) {
            return {content + a};
        }
        MiraiCode operator+(const MiraiCode &a) {
            return {content + a.content};
        }
        MiraiCode operator+(MiraiCode *a) {
            return {content + a->content};
        }
        MiraiCode &operator=(const std::string &a) {
            this->content = a;
            return *this;
        }
        MiraiCode plus(MiraiCodeable *a) {
            return {content + a->toMiraiCode()};
        }
        MiraiCode plus(const std::string &a) {
            return MiraiCode(a) + this;
        }
        /// 不执行转义，适用于已经被MiraiCode转义过的字符串
        static MiraiCode MiraiCodeWithoutEscape(const std::string &a) {
            return {a, false};
        }
        /// 不执行转义，因为MiraiCodeable的toMiraiCode已经转义过了
        static MiraiCode MiraiCodeWithoutEscape(MiraiCodeable *a) {
            return {a->toMiraiCode(), false};
        }
    };
}
#endif
/// MiraiCode.h END

#include <array>
#include <nlohmann/json_fwd.hpp>
#include <optional>
#include <sstream>
#include <unordered_map>
#include <utility>
namespace MiraiCP {
    namespace SingleMessageType {
        MIRAICP_ITERABLE_ENUM(
                -6,
                MessageSource_t,
                MarketFace_t,
                OnlineForwardedMessage_t,
                OnlineAudio_t,
                QuoteReply_t,
                UnsupportedMessage_t,
                PlainText_t,
                At_t,
                AtAll_t,
                Image_t,
                LightApp_t,
                ServiceMessage_t,
                RemoteFile_t,
                Face_t,
                FlashImage_t,
                MusicShare_t
        )
        constexpr const char *miraiCodeNameInternal[] = {
                "NoExists",  
                "NoExists",  
                "NoExists",  
                "NoExists",  
                "NoExists",  
                "NoExists",  
                "NoExists",  
                "at",
                "atall",     
                "image",     
                "app",
                "service",   
                "file",      
                "face",      
                "flash",     
                "musicshare" 
        };
        constexpr const char *messageTypeInternal[] = {
                "MessageSource",
                "MarketFace",
                "ForwardMessage",
                "OnlineAudio",
                "QuoteReply",
                "UnsupportedMessage",   
                "PlainText",
                "At",
                "AtAll",
                "Image",
                "LightApp",
                "SimpleServiceMessage", 
                "FileMessage",
                "Face",
                "FlashImage",
                "MusicShare",
        };
        static_assert(sizeof(messageTypeInternal) / sizeof(*messageTypeInternal) == SingleMessageType::End - SingleMessageType::Begin);
    }
    /// 用serviceMessage的分享信息
    struct MIRAICP_EXPORT URLSharer {
        /// 简介 没点进来看见的样子
        std::string brief = "简介 没点进来看见的样子";
        /// 目标url
        std::string url = "目标url";
        /// 图标地址
        std::string cover = "图标地址";
        /// 标题
        std::string title = "标题";
        /// 描述文字
        std::string summary = "描述文字";
    };
    /// MessageChain的组成部分
    class MIRAICP_EXPORT SingleMessage : public MiraiCodeable {
    public:
    public:
        using Types = SingleMessageType::Type;
        std::string content;
        std::string prefix;
        /// MiraiCode类别
        /// @see SingleMessage::messageType
        int internalType = SingleMessageType::UnsupportedMessage_t;
    protected:
        /// @brief 仅限于让子类允许默认构造，以保证子类可以通过动态判断类型构造
        /// @note dev: 请勿删除
        SingleMessage() = default;
    public:
        static const char *const *const messageType;
        static const char *const *const miraiCodeName;
        static std::string getTypeString(int type) {
            return messageType[type];
        }
    public:
        /// @brief 构建单条
        /// @param type 消息类型 @see messageType
        /// @param content 内容
        /// @param prefix 前缀, 默认为`:`, 第二个冒号部分的内容, 目前在serviceMesage有使用
        SingleMessage(int inType, std::string content, std::string prefix = ":") noexcept;
        ~SingleMessage() noexcept override = default;
    public:
        /// @brief 找对应类型的index key
        /// @param value 类型名
        /// @return 如果没找到返回-1
        static int getKey(const std::string &value);
        /**
         * 寻找对应的 MiraiCode 名称
         * @param value 名称
         * @return 如果没找到返回-1
         */
        static int getMiraiCodeKey(const std::string &value);
    public:
        [[nodiscard]] virtual nlohmann::json toJson() const;
        [[nodiscard]] std::string toMiraiCode() const override;
    public:
        bool operator==(const SingleMessage &m) const;
    };
    /// 纯文本信息
    class MIRAICP_EXPORT PlainText : public SingleMessage {
    public:
        explicit PlainText(const SingleMessage &sg);
        PlainText(PlainText &&_o) noexcept = default;
        PlainText(const PlainText &_o) = default;
        explicit PlainText(std::string inStr) noexcept;
        template<typename Stringable, typename = decltype(std::to_string(std::declval<Stringable>()))>
        explicit PlainText(Stringable val) : SingleMessage(PlainText::type(), std::to_string(val)) {}
    public:
        static int type() {
            return Types::PlainText_t;
        }
    public:
        [[nodiscard]] std::string toMiraiCode() const override {
            return content;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        bool operator==(const PlainText &p) const;
    };
    /// @
    class MIRAICP_EXPORT At : public SingleMessage {
    public:
        static int type() {
            return Types::At_t;
        }
        QQID target;
        [[nodiscard]] nlohmann::json toJson() const override;
        explicit At(const SingleMessage &sg);
        explicit At(QQID a);
        [[nodiscard]] std::string toMiraiCode() const override;
        bool operator==(const At &a) const;
    };
    /// @brief \@全体
    class MIRAICP_EXPORT AtAll : public SingleMessage {
    public:
        static int type() {
            return Types::AtAll_t;
        }
        [[nodiscard]] std::string toMiraiCode() const override;
        [[nodiscard]] nlohmann::json toJson() const override;
        AtAll();
    };
    /// 图像类声明
    class MIRAICP_EXPORT Image : public SingleMessage {
    public:
        static int type() {
            return Types::Image_t;
        }
        std::string id;
        /*!
         * @brief 图片类型
         *  - png
         *  - bmp
         *  - jpg
         *  - gif
         *  - apng
         *  - unknown
         *  默认 png
         */
        std::string imageType;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> md5;
        /// 可为空, 用`refreshInfo`获取
        std::optional<std::string> url;
        /// 可为0, 来源:用`refreshInfo`可能可以获取或者自己填充, 是isUploaded的必须条件, 默认0
        size_t size{};
        /// 宽度, 默认0, 单位px
        int width{};
        /// 长度, 默认0, 单位px
        int height{};
        /// 是否为 emoji
        bool isEmoji{};
        /*!
         * @brief 图片是否已经上传(如果已经上传即表明可以直接用ImageId发送, 如果没有需要手动上传)
         * @param md5 在kotlin端会用.toByteArray()转换
         * @param size 图片大小, 不能为0
         * @param botid 所属Botid
         * @return 是否已上传
         */
        bool isUploaded(QQID botid);
    protected:
        /// @brief 仅限于让子类允许默认构造，以保证子类可以通过动态判断类型构造
        /// @note dev: 请勿删除
        Image() = default;
    public:
        /*!
        * @brief 从图片builder构造，适用于服务器上已经有的图片，即接收到的
        * @param imageId 图片id, 必须
        * @param size isUploaded的必要条件, 单纯用ImageId可能取不到图片size, 需要自己上传
        * @param width 宽度
        * @param height 长度
        * @param type 图片类型
        * @detail 图片miraiCode格式例子, `[mirai:image:{图片id}.jpg]`
        * 可以用这个正则表达式找出id `\\[mirai:image:(.*?)\\]`
        */
        explicit Image(const std::string &imageId, size_t size = 0, int width = 0, int height = 0,
                       std::string type = "PNG",
                       bool isEmoji = false);
        /// 刷新信息(获取图片下载Url,md5, size)
        void refreshInfo();
        /// 取图片Mirai码
        [[nodiscard]] std::string toMiraiCode() const override;
        [[nodiscard]] nlohmann::json toJson() const override;
        static Image deserialize(const std::string &);
        bool operator==(const Image &i) const;
    };
    /// 闪照, 和Image属性类似
    class MIRAICP_EXPORT FlashImage : public Image {
    public:
        static int type() {
            return Types::FlashImage_t;
        }
        [[nodiscard]] std::string toMiraiCode() const override {
            return "[mirai:flash:" + this->id + "]";
        }
        explicit FlashImage(const std::string &imageId, size_t size = 0, int width = 0, int height = 0,
                            std::string type = "PNG");
        explicit FlashImage(const Image &img);
        [[nodiscard]] nlohmann::json toJson() const override;
        static FlashImage deserialize(const std::string &);
        bool operator==(const FlashImage &i) const;
        /// 转换到普通图片
        Image toImage();
    };
    /*!
    * @brief 小程序卡片
    * @attention 自带的模板不稳定，可能发出现没有效果
    * @doxygenEg{1015, lightApp.cpp, 从文本构建LightApp}
    */
    class MIRAICP_EXPORT LightApp : public SingleMessage {
    public:
        static int type() {
            return Types::LightApp_t;
        }
        /// @brief 使用纯文本构造，推荐使用其他结构体方法构造
        /// @param content 构造文本
        explicit LightApp(std::string content);
        explicit LightApp(const SingleMessage &sg);
        [[nodiscard]] nlohmann::json toJson() const override;
        /// 返回miraicode
        [[nodiscard]] std::string toMiraiCode() const override;
        bool operator==(const LightApp &other) const;
    };
    /// xml格式的超文本信息
    /// @attention 自带的模板不稳定，可能发出现没有效果
    class MIRAICP_EXPORT ServiceMessage : public SingleMessage {
    public:
        int id;
        static int type() {
            return Types::ServiceMessage_t;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        [[nodiscard]] std::string toMiraiCode() const override;
        /// @brief ServiceMessage
        /// @param id 在xml内容前面的id (不包括逗号)
        /// @param a xml内容 (不需要事先转码到miraiCode)
        explicit ServiceMessage(int id, std::string a);
        explicit ServiceMessage(const SingleMessage &sg);
        explicit ServiceMessage(const URLSharer &a);
        bool operator==(const ServiceMessage &s) const;
    };
    /// 引用信息
    class MIRAICP_EXPORT QuoteReply : public SingleMessage {
    public:
        static int type() {
            return Types::QuoteReply_t;
        }
        ShouldNotUse("don't have MiraiCode, use MessageChain.quote instead") std::string toMiraiCode() const override {
            return "";
        }
        /// 引用信息的MessageSource
        MessageSource source;
        explicit QuoteReply(const SingleMessage &m);
        explicit QuoteReply(MessageSource source);
        bool operator==(const QuoteReply &qr) const;
        [[nodiscard]] nlohmann::json toJson() const override;
    };
    /// 接收到的音频文件, 发送用`Contact.sendAudio`
    class MIRAICP_EXPORT OnlineAudio : public SingleMessage {
    public:
        static int type() {
            return Types::OnlineAudio_t;
        }
        /// 文件名
        std::string filename;
        /// 下载地址
        std::string url;
        /// 文件大小
        int size;
        /// 编码方式
        int codec;
        /// 时长(单位s)
        int length;
        /// 16位md5
        std::array<uint8_t, 16> md5;
        /// 不支持直接发送, 用Contact.sendAudio
        ShouldNotUse("cannot use, use Contact.sendAudio") std::string toMiraiCode() const override {
            return "";
        }
        explicit OnlineAudio(std::string f, std::array<uint8_t, 16> md5, int size, int codec, int length,
                             std::string url);
        bool operator==(const OnlineAudio &oa) const;
    };
    /// @brief 远程(群)文件类型
    class MIRAICP_EXPORT RemoteFile : public SingleMessage {
    public:
        static int type() {
            return Types::RemoteFile_t;
        }
        /// @brief 下载信息
        /// @see RemoteFile
        struct Dinfo {
            /// 下载地址, 可能会是 `null` 当文件不存在
            std::string url;
            /// md5 可用于校验
            std::string md5;
            /// sha1 可用于校验
            std::string sha1;
        };
        /// @brief 文件信息
        /// @see RemoteFile
        struct Finfo {
            /// 文件大小
            QQID size;
            /// 上传者id
            QQID uploaderid;
            /// 过期时间
            long expirytime;
            /// 上传时间, 时间戳格式
            QQID uploadtime;
            /// 上次更改时间, 时间戳格式
            QQID lastmodifytime;
        };
        /// 文件唯一id, 用于识别
        std::string id;
        /// 文件内部id, 用于构造miraiCode发送
        unsigned int internalid;
        /// 文件名
        std::string name;
        /// 文件大小
        long long size;
        /// 文件在群文件的路径
        /// @attention 可能为空(通常出现于MessageChain从MiraiCode反序列化), 需要从Group重新获取文件
        /// @see Group::getFileByFile
        std::optional<std::string> path;
        /// 文件下载信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Dinfo, Group::getFileByFile
        std::optional<Dinfo> dinfo;
        /// 文件信息
        /// @attention 可能为空(常出现于MessageChain从MiraiCode反序列化), 如果为空需要从Group重新获取
        /// @see MiraiCP::Finfo, Group::getFileByFile
        std::optional<Finfo> finfo;
        std::string serializeToString();
        RemoteFile plus(unsigned int ii);
        static RemoteFile deserializeFromString(const std::string &source);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalIds
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s, std::string p, struct Dinfo d, struct Finfo f);
        /*!
         * @brief 构造远程(群)文件
         * @param i ids
         * @param ii internalIds
         * @param n name
         * @param s size
         * @param p path
         * @param d dinfo
         * @param f finfo
         */
        explicit RemoteFile(const std::string &i, unsigned int ii, std::string n, long long s);
        /// 上传后会自动发送
        ShouldNotUse("Cannot send manually, use Group.sendFile") std::string toMiraiCode() const override {
            return "";
        }
        bool operator==(const RemoteFile &rf) const;
    };
    /// 自带表情
    /// @attention 有些表情会变成PlainText类型和\\xxx 的格式
    class MIRAICP_EXPORT Face : public SingleMessage {
    public:
        static int type() {
            return Types::Face_t;
        }
        /**
         * @brief 表情 id
         */
        int id;
        [[nodiscard]] nlohmann::json toJson() const override;
        [[nodiscard]] std::string toMiraiCode() const override;
        explicit Face(int id) : SingleMessage(Face::type(), std::to_string(id)), id(id) {}
        bool operator==(const Face &f) const;
    };
    /// 一些可以被mirai识别的音乐卡片, 如果不能被mirai识别, 那应该被表现成lightApp类型(可能收费/vip歌曲用lightApp, 免费用MusicShare)
    class MIRAICP_EXPORT MusicShare : public SingleMessage {
    public:
        static int type() {
            return Types::MusicShare_t;
        }
        /// 应用名称, 如 NeteaseCloudMusic
        std::string appName;
        /// 歌名
        std::string title;
        /// 卡片第二行的文字内容
        std::string summary;
        /// 点击跳转到的链接
        std::string jumpUrl;
        /// 图片链接
        std::string picUrl;
        /// 音乐文件链接
        std::string musicUrl;
        /// 简介, 点进聊天节目前显示的小文字, 一般是`分享`
        std::string brief;
    public:
        MusicShare(std::string appName,
                   std::string title,
                   std::string summary,
                   std::string jumpUrl,
                   std::string picUrl,
                   std::string musicUrl,
                   std::string brief);
        [[nodiscard]] std::string toMiraiCode() const override;
        nlohmann::json toJson() const override;
        std::string toString() const;
    };
    class MIRAICP_EXPORT MarketFace : public SingleMessage {
    public:
        std::array<uint8_t, 16> faceId;
        static int type() {
            return Types::MarketFace_t;
        }
        /// 目前无法直接发送MarketFace, 可以转发
        ShouldNotUse("暂不支持直接发送") std::string toMiraiCode() const override {
            return "";
        }
        explicit MarketFace(std::array<uint8_t, 16> id);
        bool operator==(const MarketFace &mf) const;
    };
    /// @brief 目前不支持的消息类型, 不支持发送
    class MIRAICP_EXPORT UnSupportMessage : public SingleMessage {
    public:
        static int type() {
            return Types::UnsupportedMessage_t;
        }
        [[nodiscard]] nlohmann::json toJson() const override;
        /// 不支持发送
        ShouldNotUse("不支持直接发送UnSupportMessage") std::string toMiraiCode() const override {
            return "";
        }
        explicit UnSupportMessage(const SingleMessage &s);
        explicit UnSupportMessage(const std::string &content) : SingleMessage(UnSupportMessage::type(), content) {}
        bool operator==(const UnSupportMessage &m) const;
    };
}
#endif
/// SingleMessage.h END

#include <functional>
namespace MiraiCP {
    class MessageSource;
    namespace internal {
        /// @brief 为 std::shared_ptr<SingleMessage> 增加功能的封装类
        /// @note dev: 不可加入其他成员变量
        class MIRAICP_EXPORT Message : public std::shared_ptr<SingleMessage> {
            typedef std::shared_ptr<SingleMessage> Super;
        public:
#if MIRAICP_MSVC
            Message() {} /// for MSVC compatible, Message should be default constructable. See MessageChain
#endif
            template<typename T, typename = std::enable_if<std::is_base_of_v<SingleMessage, T>>>
            explicit Message(T msg) {
                reset(new T(std::move(msg)));
            }
            explicit Message(Super msgptr) noexcept;
        public:
            /// 代表的子类
            /// @see MessageChain::messageType
            [[nodiscard]] int getType() const;
            /// 取指定类型
            /// @throw IllegalArgumentException
            /// @note 将复制一次对象
            template<typename T>
            T getVal() const {
                return getRef<T>();
            }
            /// 取指定类型的const引用
            /// @throw IllegalArgumentException
            template<typename T>
            const T &getRef() const {
                assert(get());
                static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的派生类");
                if (T::type() != getType()) {
                    messageThrow(SingleMessage::getTypeString(getType()), SingleMessage::getTypeString(T::type()), MIRAICP_EXCEPTION_WHERE);
                }
                return *static_cast<T *>(Super::get());
            }
            [[nodiscard]] std::string toMiraiCode() const;
            [[nodiscard]] std::string toJson() const;
            bool operator==(const Message &m) const;
            bool operator!=(const Message &m) const;
        private:
            static void messageThrow(const std::string &from, const std::string &to, const char *file, int line);
        };
    }
    /// 消息链, 一般由SingleMessage组成
    class MIRAICP_EXPORT MessageChain : public std::vector<internal::Message>, public MiraiCodeable {
    public:
        using Message = internal::Message;
    public:
        /// 如果由MiraiCP构造(incoming)就会存在，否则则不存在
        std::optional<MessageSource> source = std::nullopt;
    public:
        MessageChain(const MessageChain &_o) = default;
        MessageChain(MessageChain &&_o) = default;
        MessageChain() = default;
        ~MessageChain() override = default;
        /*!
         * @brief 从多个参数构建MessageChain
         * @tparam T 多个传入参数的类型
         * 支持以下类型:
         * - std::string / const char* 相当于传入PlainText
         * - SingleMessage的派生类
         * @param args 参数本身
         */
        template<typename... T, typename = typename std::enable_if_t<(true && ... && !std::is_same_v<std::decay_t<T>, MessageChain>)>>
        explicit MessageChain(T &&...args) {
            constructMessages(std::forward<T>(args)...);
        };
        /// incoming构造器，对第一个参数为MessageSource的特化
        template<class... T>
        explicit MessageChain(MessageSource ms, T &&...args) : source(std::move(ms)) {
            this->constructMessages(std::forward<T>(args)...);
        };
    public:
        [[nodiscard]] std::string toMiraiCode() const override;
        [[nodiscard]] std::vector<std::string> toMiraiCodeVector() const;
        [[nodiscard]] nlohmann::json toJson() const;
        /**
         * @ensure toJson().dump()
         * @return MessageChain serialize to String
         */
        [[nodiscard]] std::string toString() const;
        /// @brief 使用emplace_back构造Message添加元素
        /// @tparam T 任意的SingleMessage的子类对象，但不允许传入SingleMessage本身
        /// @param a 添加的值
        /// @note 如果你已经有一个Message对象，请直接调用emplace_back。
        ///  若你尝试传入一个基类SingleMessage对象，说明你的程序出现了一些问题
        template<typename T, typename = std::enable_if_t<std::is_base_of_v<SingleMessage, std::decay_t<T>> && !std::is_same_v<SingleMessage, std::decay_t<T>>>>
        void add(T &&a) {
            emplace_back(std::forward<T>(a));
        }
        void add(MessageSource val) {
            source = std::move(val);
        }
        /// 筛选出某种类型的消息
        /// @note 最多可能将整个vector复制一次
        template<typename T>
        std::vector<T> filter() const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto &&a: *this) {
                if (a.getType() == T::type())
                    re.emplace_back(a.getVal<T>());
            }
            return re;
        }
        /// 自定义筛选器
        /// @note 最多可能将整个vector复制一次
        template<typename T>
        std::vector<T> filter(const std::function<bool(const Message &)> &func) const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            std::vector<T> re;
            for (auto &&a: *this) {
                if (func(a))
                    re.push_back(a.getVal<T>());
            }
            return re;
        }
        /// 找出第一个指定的type的消息，消息可能不存在
        template<typename T>
        std::optional<T> first() const {
            for (auto &&a: *this)
                if (a.getType() == T::type())
                    return a.getVal<T>();
            return std::nullopt;
        }
        template<typename T>
        [[nodiscard]] MessageChain plus(const T &a) const {
            static_assert(std::is_base_of_v<SingleMessage, T>, "只支持SingleMessage的子类");
            MessageChain tmp(*this);
            tmp.emplace_back(a);
            return tmp;
        }
        [[nodiscard]] MessageChain plus(const MessageChain &mc) const;
        [[nodiscard]] MessageChain plus(const MessageSource &ms) const;
        template<class T>
        MessageChain operator+(const T &msg) const {
            return this->plus(msg);
        }
        bool operator==(const MessageChain &mc) const;
        bool operator!=(const MessageChain &mc) const;
        [[nodiscard]] bool empty() const;
    public:
        /// @brief 找到miraiCode结尾的`]`
        /// @param s 文本
        /// @param start 开始位置
        /// @return 如果不存在返回-1, 存在则返回index
        static size_t findEnd(const std::string &s, size_t start);
        /// 从miraicode string构建MessageChain
        static MessageChain deserializationFromMiraiCode(const std::string &m);
        static MessageChain deserializationFromMessageSourceJson(const std::string &msg, bool origin = true);
        /// 从MessageSource json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageSourceJson(nlohmann::json j, bool origin = true);
        /// 从 Message json中构建MessageChain, 常用于Incoming message
        /// @attention 本方法并不会自动附加MessageSource到MessageChain, 需要用.plus方法自行附加
        static MessageChain deserializationFromMessageJson(const nlohmann::json &j);
    private:
        void constructMessages() {}
        template<typename T1, typename... T2, typename = std::enable_if_t<std::is_base_of_v<SingleMessage, std::decay_t<T1>>>>
        void constructMessages(T1 &&h, T2 &&...args) {
            emplace_back(std::forward<T1>(h));
            constructMessages(std::forward<T2>(args)...);
        }
        template<typename... T2>
        void constructMessages(std::string h, T2 &&...args) {
            emplace_back(PlainText(std::move(h)));
            constructMessages(std::forward<T2>(args)...);
        }
        template<typename... T>
        void constructMessages(const MessageChain &mc, T &&...args) {
            insert(end(), mc.begin(), mc.end());
            constructMessages(std::forward<T>(args)...);
        }
        template<typename... T>
        void constructMessages(const MiraiCode &m, T &&...args) {
            auto mc = MessageChain::deserializationFromMiraiCode(m.toMiraiCode());
            insert(end(), mc.begin(), mc.end());
            constructMessages(std::forward<T>(args)...);
        }
    };
}
#endif
/// MessageChain.h END

#include <string>
#include <utility>
#include <variant>
#include <vector>
namespace MiraiCP {
    class Contact;
    class ForwardedMessage;
    /// 转发信息显示策略, 目前好像只在转发信息内的转发信息生效
    class MIRAICP_EXPORT ForwardedMessageDisplayStrategy {
        using string = std::string;
    public:
        string title = "群聊的聊天记录";
        string brief = "[聊天记录]";
        string source = "聊天记录";
        string summary = "查看1条转发信息";
        std::vector<string> preview{"Name: message"};
        bool operator==(const ForwardedMessageDisplayStrategy &other) const;
    public:
        static ForwardedMessageDisplayStrategy defaultStrategy() { return {}; }
    public:
        ForwardedMessageDisplayStrategy() = default;
        ForwardedMessageDisplayStrategy(std::string title, std::string brief, std::string source, std::string summary, std::vector<std::string> preview);
    public:
        [[nodiscard]] nlohmann::json toJson() const;
        static ForwardedMessageDisplayStrategy fromJson(const nlohmann::json &j);
    };
    ///聊天记录里每个消息
    /// todo 传入头像
    class MIRAICP_EXPORT ForwardedNode {
    public:
        ///发送者id
        QQID id = 0;
        ///发送者昵称
        std::string name;
        ///发送信息
        MessageChain message;
        ///发送时间(时间戳)
        int time = 0;
    private:
        bool isForwardedMessage;
    public:
        /// @brief 聊天记录里的每条信息
        /// @param id - 发送者id
        /// @param name - 发送者昵称
        /// @param message - 发送的信息
        /// @param time - 发送时间，以时间戳记
        ForwardedNode(QQID id, std::string name, MessageChain message, int time);
        /// @brief 构造聊天记录里每条信息
        /// @param c - 发送者的contact指针
        /// @param message - 发送的信息
        /// @param t - 发送时间，时间戳格式
        ForwardedNode(QQID id, std::string name, ForwardedMessage message, int t);
    public:
        /*!
         * 是否也是转发信息
         */
        [[nodiscard]] bool isForwarded() const { return isForwardedMessage; }
    };
    /*!转发消息, 由ForwardNode组成
     * @see class ForwardedNode
     * @doxygenEg{1005, forwardMessage.cpp, 构建聊天记录}
     */
    class MIRAICP_EXPORT ForwardedMessage : public SingleMessage {
    private:
        /// 每条信息
        std::vector<ForwardedNode> nodes;
        /// 显示策略
        ForwardedMessageDisplayStrategy display;
    public:
        static int type() {
            return Types::OnlineForwardedMessage_t;
        }
        ForwardedNode &operator[](size_t i) {
            return nodes[i];
        }
        const ForwardedNode &operator[](size_t i) const {
            return nodes[i];
        }
        void add(ForwardedNode a);
        auto &operator+=(ForwardedNode a);
        bool operator==(const ForwardedMessage &m) const;
        ForwardedMessage& setDisplayStrategy(ForwardedMessageDisplayStrategy strategy) {
            display = std::move(strategy);
            return *this;
        }
    public:
        /*!
        *@brief 构建一条聊天记录
        *@details 第一个参数是聊天记录发生的地方, 然后是每条信息
        */
        ForwardedMessage(std::initializer_list<ForwardedNode> nodes, ForwardedMessageDisplayStrategy display = ForwardedMessageDisplayStrategy::defaultStrategy());
        explicit ForwardedMessage(std::vector<ForwardedNode> inNodes, ForwardedMessageDisplayStrategy display = ForwardedMessageDisplayStrategy::defaultStrategy());
        ForwardedMessage(const ForwardedMessage &) = default;
        ForwardedMessage(ForwardedMessage &&) = default;
        [[nodiscard]] nlohmann::json toJson() const override;
    public:
        /// 发送给群或好友或群成员
        MessageSource sendTo(Contact *c) const;
        [[nodiscard]] nlohmann::json nodesToJson() const;
    public:
        static ForwardedMessage deserializationFromMessageJson(const nlohmann::json &j);
    };
    /// 接收到的转发消息, 发送用 MiraiCP::ForwardedMessage
    /// @deprecated Use ForwardedMessage instead
    using OnlineForwardedMessage = ForwardedMessage;
}
#endif
/// ForwardedMessage.h END
/// ThreadTask.h START
#ifndef MIRAICP_PRO_THREADTASK_H
#define MIRAICP_PRO_THREADTASK_H
#include <functional>
#include <future>
#include <memory>
#include <string>
namespace MiraiCP::ThreadTask {
    namespace internal {
        MIRAICP_EXPORT void task_interface(size_t id);
        MIRAICP_EXPORT size_t get_auto_incr_id();
        MIRAICP_EXPORT void remove_task(size_t id);
        MIRAICP_EXPORT void push_task(size_t id, std::shared_ptr<std::function<void()>> func);
        MIRAICP_EXPORT void raw_push_task(void (*)());
        MIRAICP_EXPORT void logerror(const std::string &content);
    }
    /// @brief 提交一个任务到线程池，参数与构造 std::thread 以及 MiraiCPNewThread 用的参数相同。
    ///  任务在线程池可用时会被立刻执行
    /// @return 对应任务返回类型的 std::future 对象
    /// @see addTask, MiraiCPNewThread
    template<typename F, typename... Args, typename R = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>>
    std::future<R> promiseTask(F &&func, Args &&...args) {
        auto promise = std::make_shared<std::promise<R>>();
        auto future = promise->get_future();
        std::function<R()> taskfunction = std::bind(std::forward<F>(func), std::forward<Args>(args)...);
        size_t function_id = internal::get_auto_incr_id();
        auto to_push_func = std::make_shared<std::function<void()>>(
                [promise = std::move(promise), function_id, taskfunction = std::move(taskfunction)]() {
                    try {
                        if constexpr (std::is_void_v<R>) {
                            std::invoke(taskfunction);
                            promise->set_value();
                        } else {
                            promise->set_value(std::invoke(taskfunction));
                        }
                    } catch (...) {
                        try {
                            promise->set_exception(std::current_exception());
                            internal::logerror("Failed to run task: " + std::to_string(function_id));
                        } catch (...) {
                        }
                    }
                    try {
                        internal::remove_task(function_id);
                    } catch (...) {
                    }
                });
        internal::push_task(function_id, std::move(to_push_func));
        return future;
    }
    /// @brief 提交一个任务到线程池，参数与构造 std::thread 以及 MiraiCPNewThread 用的参数相同。
    ///  任务在线程池可用时会被立刻执行。与 promiseTask 不同，不会给出任务返回值
    /// @see promiseTask, MiraiCPNewThread
    template<typename F, typename... Args, typename R = std::invoke_result_t<std::decay_t<F>, std::decay_t<Args>...>>
    void addTask(F &&func, Args &&...args) {
        if constexpr (std::is_same_v<std::decay_t<F>, void (*)()>) {
            internal::raw_push_task(func);
        } else {
            auto function_id = internal::get_auto_incr_id();
            std::function<void()> taskfunction = std::bind(std::forward<F>(func), std::forward<Args>(args)...);
            auto to_push_func = std::make_shared<std::function<void()>>(
                    [function_id, taskfunction = std::move(taskfunction)]() {
                        try {
                            std::invoke(taskfunction);
                        } catch (...) {
                            try {
                                internal::logerror("Failed to run task: " + std::to_string(function_id));
                            } catch (...) {
                            }
                        }
                        try {
                            internal::remove_task(function_id);
                        } catch (...) {
                        }
                    });
            internal::push_task(function_id, std::move(to_push_func));
        }
    }
};
#endif
/// ThreadTask.h END
/// utils.h START
#ifndef MIRAICP_PRO_UTILS_H
#define MIRAICP_PRO_UTILS_H
/// CPPPlugin.h START
#ifndef MIRAICP_PRO_CPPPLUGIN_H
#define MIRAICP_PRO_CPPPLUGIN_H
/// PluginConfig.h START
#ifndef MIRAICP_PRO_PLUGINCONFIG_H
#define MIRAICP_PRO_PLUGINCONFIG_H
#include <string>
namespace MiraiCP {
    constexpr const char *m_MiraiCPVersion = "v2.16.0";
    inline const std::string MiraiCPVersion = m_MiraiCPVersion;
    struct PluginConfig {
        /// @brief 插件id, 要与别人不一样否则报错无法加载(建议用类包格式，如: io.github.nambers)
        const char *id = nullptr;
        /// @brief 插件名称
        const char *name = nullptr;
        /// @brief 插件版本
        const char *version = nullptr;
        /// @brief 插件作者(及联系方式)
        const char *author = nullptr;
        /// @brief [optional]插件描述
        const char *description = "";
        /// @brief [optional]构建时间, 默认为__DATE__宏
        const char *time = __DATE__;
        const char *mversion = m_MiraiCPVersion;
        [[nodiscard]] std::string getId() const {
            return {id};
        }
        [[nodiscard]] std::string getName() const {
            return {name};
        }
        [[nodiscard]] std::string getVersion() const {
            return {version};
        }
        [[nodiscard]] std::string getAuthor() const {
            return {author};
        }
        [[nodiscard]] std::string getDescription() const {
            return {description};
        }
        [[nodiscard]] std::string getTime() const {
            return {time};
        }
        [[nodiscard]] std::string getMVersion() const {
            return {mversion};
        }
        [[nodiscard]] bool isValid() const {
            return id && name && version && author;
        }
    };
}
#endif
/// PluginConfig.h END

#include <memory>
#include <utility>
namespace MiraiCP {
    /// 插件父类
    class MIRAICP_EXPORT CPPPlugin {
    public:
        ShouldNotUse("请改为初始化静态常量 CPPPlugin::config") explicit CPPPlugin(const PluginConfig &) {
        }
        explicit CPPPlugin() = default;
        virtual ~CPPPlugin() = default;
    public:
        /// @brief 插件信息，一个插件中该内容不应变化
        const static PluginConfig config;
        inline static std::unique_ptr<CPPPlugin> plugin = nullptr;
    public:
        /// 插件启用时调用一次
        virtual void onEnable() {}
        virtual void onDisable() {}
    };
}
#endif
/// CPPPlugin.h END

namespace MiraiCP {
    /// 注册插件函数, 需要被插件实现, 类似onStart();
    MIRAICP_EXPORT void enrollPlugin();
    /// 用指针绑定插件
    [[deprecated("use enrollPlugin<T> instead")]] inline void enrollPlugin(CPPPlugin *p) {
        CPPPlugin::plugin.reset(p);
    }
    /// @note dev: 为防止用户插件crash造成内存泄漏等问题，改为用安全一些的make_unique
    template<typename T>
    inline void enrollPlugin() {
        static_assert(std::is_base_of_v<CPPPlugin, T>, "Enrolling plugin type T should be inherited from CPPPlugin");
        CPPPlugin::plugin = std::make_unique<T>();
    }
}
#endif
/// utils.h END
/// Tools.h START
#ifndef MIRAICP_PRO_TOOLS_H
#define MIRAICP_PRO_TOOLS_H
#include <nlohmann/json_fwd.hpp>
#include <sstream>
#include <string>
#include <vector>
namespace MiraiCP {
    /// @brief 工具类声明, 常用的一些转换工具
    namespace Tools {
        /*!
         * @brief 替换全部在一个字符串中.
         * @param str 原字符串.
         * @param from 需要被替换的字符.
         * @param to 替换到的字符.
         * @return 返回替换后的字符串.
         * @note 来源:https://stackoverflow.com/a/24315631/14646226
         */
        MIRAICP_EXPORT std::string replace(std::string str, std::string_view from, std::string_view to);
        /// @brief 任意类型的vector格式化输出
        /// @param a vector
        /// @return string
        /// @note dev: 尽量避免直接使用，而是使用其特化
        template<typename T>
        inline std::string VectorToString(const std::vector<T> &a, const std::string &separator = ",") {
            std::stringstream ss;
            for (auto it = a.begin(); it != a.end(); ++it) {
                if (it != a.begin()) ss << separator;
                ss << *it;
            }
            return ss.str();
        }
        /// @brief unsigned long long 类型的vector格式化输出，VectorToString<T>的特化
        /// @param a QQID vector
        /// @return string
        template<>
        inline std::string VectorToString(const std::vector<QQID> &a, const std::string &separator) {
            std::string ss;
            for (auto it = a.begin(); it != a.end(); ++it) {
                if (it != a.begin()) ss += separator;
                ss += std::to_string(*it);
            }
            return ss;
        }
        /// @brief string 类型的vector格式化输出，VectorToString<T>的特化
        /// @param a string vector
        /// @return string
        template<>
        inline std::string VectorToString(const std::vector<std::string> &a, const std::string &separator) {
            std::string ans;
            for (auto it = a.begin(); it != a.end(); ++it) {
                if (it != a.begin()) ans += separator;
                ans += *it;
            }
            return ans;
        }
        /// @brief 从string格式化到vector
        /// @param temp string
        /// @return vector
        MIRAICP_EXPORT std::vector<QQID> StringToVector(std::string temp);
        /// @brief 从miraicode转义到正常
        /// @param s 经过miraicode转义的字符串
        /// @return 原字符串
        MIRAICP_EXPORT std::string escapeFromMiraiCode(const std::string &s);
        /// @brief 转义miraicode格式
        MIRAICP_EXPORT std::string escapeToMiraiCode(const std::string &s);
        /// starts_with, from <https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a>
        MIRAICP_EXPORT bool starts_with(std::string_view f, std::string_view s);
        /// compare char with case-insensitive
        MIRAICP_EXPORT bool icompareChar(const char &c1, const char &c2);
        /// case insensitive string compare from https://thispointer.com/c-case-insensitive-string-comparison-using-stl-c11-boost-library/
        MIRAICP_EXPORT bool iequal(std::string_view str1, std::string_view str2);
        /// from https://www.zhihu.com/question/36642771, delim is regex(ignore last `+`)
        MIRAICP_EXPORT std::vector<std::string> split(const std::string &text, const std::string &delim);
        /// @brief id pair工具结构体声明，仅内部使用
        /// @note dev: 为保证可读性请仅在局部作用域使用，且使用聚合初始化
        struct idpair {
            QQID id1;
            QQID id2;
            bool operator==(const idpair &other) const {
                return id1 == other.id1 && id2 == other.id2;
            }
        };
    };
}
/// @brief id pair工具结构体散列特化，用于unordered_map
template<>
struct std::hash<MiraiCP::Tools::idpair> {
    using idpair = MiraiCP::Tools::idpair;
    size_t operator()(const idpair in_pair) const {
        auto First = reinterpret_cast<const char *>(&in_pair);
        size_t Val = 14695981039346656037ULL;
        for (size_t Idx = 0; Idx < sizeof(idpair); ++Idx) {
            Val ^= static_cast<size_t>(First[Idx]);
            Val *= 1099511628211ULL;
        }
        return Val;
    }
};
#endif
/// Tools.h END
/// MiraiCPNewThread.h START
#ifndef MIRAICP_PRO_MIRAICPNEWTHREAD_H
#define MIRAICP_PRO_MIRAICPNEWTHREAD_H
/// Exception.h START
#ifndef MIRAICP_PRO_EXCEPTION_H
#define MIRAICP_PRO_EXCEPTION_H
#include "nlohmann/json.hpp"
#include <exception>
#include <sstream>
#include <string>
#include <thread>
#define EXCEPTION_DEFINE(name, cause)                                                                                 \
    class MIRAICP_EXPORT name : public MiraiCPExceptionCRTP<name> {                                                   \
    public:                                                                                                           \
        explicit name(string _filename, int _lineNum) : MiraiCPExceptionCRTP(cause, std::move(_filename), _lineNum) { \
        }                                                                                                             \
        static string exceptionType() { return #name; }                                                               \
    }
#define EXCEPTION_DEFINE_W_NUM(name, cause)                                                                                     \
    class MIRAICP_EXPORT name : public MiraiCPExceptionCRTP<name> {                                                             \
    public:                                                                                                                     \
        explicit name(int info, string _filename, int _lineNum) : MiraiCPExceptionCRTP(cause, std::move(_filename), _lineNum) { \
        }                                                                                                                       \
        static string exceptionType() { return #name; }                                                                         \
    }
#define EXCEPTION_DEFINE_W_STR(name, cause)                                                                                        \
    class MIRAICP_EXPORT name : public MiraiCPExceptionCRTP<name> {                                                                \
    public:                                                                                                                        \
        explicit name(string info, string _filename, int _lineNum) : MiraiCPExceptionCRTP(cause, std::move(_filename), _lineNum) { \
        }                                                                                                                          \
        static string exceptionType() { return #name; }                                                                            \
    }
namespace MiraiCP {
    /// @brief 总异常抽象类，用于一般捕获，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException
    /// @interface MiraiCPExceptionBase
    class MIRAICP_EXPORT MiraiCPExceptionBase : public ::std::exception {
    protected:
        using string = std::string;
    protected:
        /// @brief 异常内容
        string cause;
    public:
        /// @brief 发生异常的文件名
        string filename;
        /// @brief 发生异常的行号
        int lineNum = 0;
    protected:
        /// 受保护构造函数，供子类调用
        MiraiCPExceptionBase(const nlohmann::json &info, string _filename, int _lineNum) : cause(info.dump()), filename(std::move(_filename)), lineNum(_lineNum) {}
    public:
        ~MiraiCPExceptionBase() override = default;
    public:
        /// 异常信息
        const char *what() const noexcept override { return cause.c_str(); }
        /// 返回std::string的异常信息
        string getError() const { return cause; }
        /// 返回解析后的异常信息
        nlohmann::json getCause() const { return nlohmann::json::parse(cause); }
        /// 实际抛出方法
        void raise() const;
    public:
        /// basicRaise 基本抛出方法，子类重写该方法
        virtual void basicRaise() const;
        /// 获取异常类型，通用接口
        virtual string getExceptionType() const = 0;
        /// 返回异常的类型，该静态方法无法正确实现多态，请使用 getExceptionType
        /// @see getExceptionType
        static string exceptionType() { return "MiraiCPException"; }
    };
    /// @brief 总异常CRTP抽象类，不要直接抛出该类，不知道抛出什么的时候请抛出 MiraiCPException。
    /// 该类是用于继承的基类，需要新的异常类型时，继承该类并以子类作为模板参数。
    /// 子类需要实现的方法：
    /// 1. 构造函数，要求必须委托MiraiCPExceptionCRTP构造。
    /// 2. `static std::string exceptionType()` 返回一个字符串表示异常类型。
    /// 继承该类后异常类能正确实现多态。
    /// @interface MiraiCPExceptionCRTP
    /// @note 请勿给该类增加新的属性。如果要增加属性应在 MiraiCPExceptionBase 中增加
    template<typename T>
    class MIRAICP_EXPORT MiraiCPExceptionCRTP : public MiraiCPExceptionBase {
    public:
        /// 委托构造函数
        explicit MiraiCPExceptionCRTP(nlohmann::json info, string _filename, int _lineNum) : MiraiCPExceptionBase(std::move(info), std::move(_filename), _lineNum) {
        }
    public:
        string getExceptionType() const override { return T::exceptionType(); }
    };
    /// @brief 通用MiraiCP异常
    /// @param const string &description, string _filename, int _lineNum
    /// @see MiraiCPExceptionBase
    class MIRAICP_EXPORT MiraiCPException : public MiraiCPExceptionCRTP<MiraiCPExceptionBase> {};
    EXCEPTION_DEFINE(BotPermException, (nlohmann::json{{"cause", "没有权限执行该操作"}}));
    EXCEPTION_DEFINE_W_STR(BotNotFoundException, (nlohmann::json{{"cause", "找不到bot"}, {"botId", info}}));
    EXCEPTION_DEFINE_W_NUM(BotIsBeingMutedException, (nlohmann::json{{"cause", "发送信息失败, bot已被禁言"}, {"timeRemain", info}}));
    /// 事件被取消, 一般出现在发送消息时在preSendMessageEvent取消的时候抛出
    EXCEPTION_DEFINE(EventCancelledException, (nlohmann::json{{"cause", "发送信息被取消"}}));
    EXCEPTION_DEFINE(FriendException, (nlohmann::json{{"cause", "找不到好友"}}));
    /// 获取群错误
    EXCEPTION_DEFINE(GroupException, (nlohmann::json{{"cause", "找不到群"}}));
    EXCEPTION_DEFINE(MemberGroupNotFoundException, (nlohmann::json{{"cause", "获取群成员错误:找不到群"}}));
    EXCEPTION_DEFINE(MemberNotFoundException, (nlohmann::json{{"cause", "获取群成员错误:找不到群成员"}}));
    /// 内部异常, 通常为json读写问题
    EXCEPTION_DEFINE_W_STR(APIException, (nlohmann::json{{"cause", "MiraiCP内部无法预料的错误"}, {"info", info}}));
    EXCEPTION_DEFINE_W_STR(IllegalArgumentException, (nlohmann::json{{"cause", "参数错误"}, {"info", info}}));
    /// 通常为Mirai返回
    EXCEPTION_DEFINE_W_STR(IllegalStateException, (nlohmann::json{{"cause", "状态错误"}, {"info", info}}));
    /// 远程资源出现问题
    EXCEPTION_DEFINE_W_STR(RemoteAssetException, (nlohmann::json{{"cause", "远程资源出现问题"}, {"info", info}}));
    EXCEPTION_DEFINE_W_STR(TimeOutException, (nlohmann::json{{"cause", "执行超时"}, {"info", info}}));
    /// 文件读取异常
    EXCEPTION_DEFINE_W_STR(UploadException, (nlohmann::json{{"cause", "上传(图片/文件)异常"}, {"info", info}}));
    /// 插件没有权限时抛出该异常
    /// 该异常仅可能在插件尝试调用libLoader 高级权限的Api接口时抛出
    /// 如插件尝试重载、加载、卸载插件等操作，但配置文件中并没有赋予该插件权限时
    EXCEPTION_DEFINE(PluginNotAuthorizedException, (nlohmann::json{{"cause", "插件" + CPPPlugin::config.getId() + "没有管理权限"}}));
    /// 插件未加载抛出该异常
    /// 在插件能正常运行时不会抛出，出现该异常事件时请不要再次尝试收发消息等Mirai操作，
    /// 否则可能导致异常处理时再次抛出异常
    EXCEPTION_DEFINE(PluginNotEnabledException, (nlohmann::json{{"cause", "插件" + CPPPlugin::config.getId() + "未加载"}}));
    /// LoaderAPI返回空Msg unique指针
    EXCEPTION_DEFINE(LibLoaderNoResponseException, (nlohmann::json{{"cause", "LibLoader返回了空的响应"}}));
    /// 禁言异常
    EXCEPTION_DEFINE(MuteException, (nlohmann::json{{"cause", "禁言时长不在0s~30d中间"}}));
    /// 撤回异常
    EXCEPTION_DEFINE(RecallException, (nlohmann::json{{"cause", "该消息已经被撤回"}}));
    /// 如果在 MiraiCPNewThread 中捕获到了非 MiraiCP 之外的异常抛出
    /// @see MiraiCPNewThread
    class MiraiCPThreadException : public MiraiCPExceptionCRTP<MiraiCPThreadException> {
    public:
        /// 抛出异常的线程 ID
        std::thread::id threadId;
    public:
        explicit MiraiCPThreadException(const std::string &exception_content, std::thread::id threadId, string _filename, int _lineNum)
            : MiraiCPExceptionCRTP(exception_content + " at threadId: " + getThreadIdStr(threadId), std::move(_filename), _lineNum),
              threadId(threadId) {}
    public:
        std::string getThreadIdStr() const { return getThreadIdStr(threadId); }
    public:
        static string exceptionType() { return "MiraiCPThreadException"; }
    private:
        MIRAICP_EXPORT static std::string getThreadIdStr(const std::thread::id &id) {
            static std::stringstream ss;
            ss << id;
            auto result = ss.str();
            ss.str("");
            return result;
        }
    };
}
#endif
/// Exception.h END

#include <thread>
namespace MiraiCP {
    /// MiraiCP 对 std::thread 的封装
    class MIRAICP_EXPORT MiraiCPNewThread : public std::thread {
    public:
        MiraiCPNewThread() noexcept = default;
        template<typename Callable, typename... Args>
        explicit MiraiCPNewThread(Callable &&func, Args &&...args)
            : std::thread(
                      [lambda_func = std::forward<Callable>(func)](auto &&...argss) {
                          try {
                              lambda_func(std::forward<decltype(argss)>(argss)...);
                          } catch (MiraiCPExceptionBase &e) {
                              threadExceptionBroadcast(e);
                          } catch (const std::exception &e) {
                              threadThrows(e.what());
                          } catch (...) {
                              threadThrows("unknown exception type");
                          }
                      },
                      std::forward<Args>(args)...) {}
        MiraiCPNewThread &operator=(const std::thread &) = delete;
        MiraiCPNewThread &operator=(const MiraiCPNewThread &) = delete;
        MiraiCPNewThread &operator=(std::thread &&other) {
            static_cast<std::thread &>(*this) = std::move(other);
            return *this;
        }
        MiraiCPNewThread &operator=(MiraiCPNewThread &&other) noexcept {
            static_cast<std::thread &>(*this) = std::move(static_cast<std::thread &>(other));
            return *this;
        }
    private:
        static void threadThrows(const std::string &content);
        static void threadExceptionBroadcast(MiraiCPExceptionBase &e);
    };
}
#endif
/// MiraiCPNewThread.h END
/// loaderApi.h START
#ifndef MIRAICP_PRO_LOADERAPI_H
#define MIRAICP_PRO_LOADERAPI_H
#include <string>
#include <vector>
namespace MiraiCP::LoaderApi {
    /// @brief 返回所有plugin的id
    MIRAICP_EXPORT std::vector<std::string> showAllPluginId();
    /// @brief 启用一个已经加载的插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    MIRAICP_EXPORT void enablePluginById(const std::string &id);
    /// @brief 禁用一个已经启用的插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    MIRAICP_EXPORT void disablePluginById(const std::string &);
    /// @brief 启用全部已加载的插件，仅限有管理权限的插件使用，否则没有任何效果
    MIRAICP_EXPORT void enableAllPlugins();
    /// @brief 禁用全部已启用的插件，仅限有管理权限的插件使用，否则没有任何效果
    MIRAICP_EXPORT void disableAllPlugins();
    /// @brief 加载新的插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param path 插件路径
    /// @param enableNow 是否立即启用
    MIRAICP_EXPORT void loadNewPlugin(const std::string &path, bool enableNow);
    /// @brief 卸载一个插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    MIRAICP_EXPORT void unloadPluginById(const std::string &id);
    /// @brief 重载一个插件，仅限有管理权限的插件使用，否则没有任何效果
    /// @param id 插件id
    MIRAICP_EXPORT void reloadPluginById(const std::string &id);
}
#endif
/// loaderApi.h END
/// Command.h START
#ifndef MIRAICP_PRO_COMMAND_H
#define MIRAICP_PRO_COMMAND_H
#include <memory>
#include <optional>
#include <string>
#include <vector>
namespace MiraiCP {
    class MessageChain; /// forward declaration
    class Bot;          /// forward declaration
    class Contact;      /// forward declaration
    /*!
     * @brief 指令 Interface
     * @doxygenEg{1001, command.h, 新建自定义命令}
     * @attention loader端的命令只支持从console传入, plugin端是对接 mirai 的RawCommand
     * @note 析构函数必须重写基类，否则会造成内存泄漏
     */
    class MIRAICP_EXPORT IRawCommand {
    public:
        /// @brief Command 类的配置信息
        struct Config {
            using string = std::string;
            /// 指令名不能为空
            string primaryName;
            /// 可以为空
            std::vector<string> secondNames;
            /// 用法
            string usage = "null";
            /// 描述
            string description = "null";
            /// 覆盖已有命令
            bool overrideOrigin = false;
            /// 前缀`/`可省略
            bool preFixOption = false;
        };
    public:
        /// @brief 子类需要实现的函数
        /// @return 返回一个 IRawCommand::Config 对象
        virtual IRawCommand::Config config() = 0;
        /// @brief 子类需要实现的函数
        /// @return 在command被触发时的回调
        /// @param contact command被触发的聊天环境
        /// @param msg command被触发的 message chain
        virtual void onCommand(std::shared_ptr<Contact> contact, const Bot &bot, const MessageChain &msg) = 0;
        /// 析构函数必须override该函数
        virtual ~IRawCommand() = default;
    };
    namespace internal {
        bool commandRegister(std::unique_ptr<IRawCommand> inPtr);
    }
    namespace CommandManager {
        /*!
         * @brief 注册一条指令
         * @tparam T 指令的类，必须继承 IRawCommand 且默认构造函数可访问
         * @return 是否注册成功
         * @note 默认构造函数构造出的对象的config()函数内容会被注册
         */
        template<typename T>
        bool registerCommand() {
            static_assert(std::is_base_of_v<IRawCommand, T>, "只支持IRawCommand的派生类");
            return internal::commandRegister(std::make_unique<T>());
        }
    }
}
#endif
/// Command.h END
/// FriendRecallEvent.h START
#ifndef MIRAICP_PRO_FRIENDRECALLEVENT_H
#define MIRAICP_PRO_FRIENDRECALLEVENT_H
/// Friend.h START
#ifndef MIRAICP_PRO_FRIEND_H
#define MIRAICP_PRO_FRIEND_H
/// Contact.h START
#ifndef MIRAICP_PRO_CONTACT_H
#define MIRAICP_PRO_CONTACT_H
#include <nlohmann/json.hpp>
#include <string>
namespace MiraiCP {
    /// Contact 类型
    enum ContactType {
        MIRAI_CONTACT = 0,
        /// 好友
        MIRAI_FRIEND = 1,
        /// 群聊
        MIRAI_GROUP = 2,
        /// 群成员
        MIRAI_MEMBER = 3,
        /// bot
        MIRAI_BOT = 4,
        MIRAI_OTHERTYPE = 5,
    };
    struct IMiraiData;
    struct IContactData;
    namespace internal {
        std::string getNickFromIContactPtr(IContactData *);
        std::string getAvatarUrlFromIContactPtr(IContactData *);
    }
    /*!
    * @brief group, friend, member的父类
    * @doxygenEg{1002, message.cpp, 发送以及回复群消息}
    */
    class MIRAICP_EXPORT Contact {
        template<typename ClassType, typename InternalDataType>
        friend struct ContactDataHelper;
    protected:
        /// 内部数据
        std::shared_ptr<IContactData> InternalData;
    public:
        /*!
         * @brief 无参初始化Contact类型
         * @internal 禁止使用
         */
        Contact() = delete;
    protected:
        explicit Contact(std::shared_ptr<IContactData> Data);
    public:
        /// 虚类 destructor
        virtual ~Contact() = default;
        bool operator==(const Contact &c) const;
        /**
         * @brief 设置内部数据指针
         * @note dev: 避免直接使用 InternalData, 请使用该接口操作 InternalData 指针
         */
        void SetInternalData(std::shared_ptr<IContactData> Data);
        /**
         * @brief 尝试一次数据刷新
         * @note 不保证进行刷新, 一般为内部调用. 强制刷新请使用 forceRefreshInfo()
         * @see forceRefreshInfo
         */
        void refreshInfo();
        /**
         * @brief 强制下次 refreshInfo() 调用时刷新数据
         * @note 尽可能调用该函数, 避免不必要的刷新
         * @see refreshInfo
         */
        void forceRefreshNextTime();
        /**
         * @brief 强制数据刷新
         * @note 频繁刷新可能会有性能损耗
         * @see refreshInfo, forceRefreshNextTime
         */
        void forceRefreshNow();
        /**
         * @brief 当前对象类型
         * @see ContactType
         * @note dev: 不会修改, 不需要锁
         *     - ContactType::MIRAI_FRIEND 好友
         *     - ContactType::MIRAI_GROUP 群聊
         *     - ContactType::MIRAI_MEMBER 群成员
         */
        [[nodiscard]] ContactType type() const;
        /**
         * @brief id 在全部情况存在
         * @note dev: 不会修改，不需要锁
         *      - 当前type为Friend时，为好友id
         *      - 当前type为Group时，为群id
         *      - 当前type为Member时，为群成员id
         * @see MIRAI_CONTACT
         */
        [[nodiscard]] QQID id() const;
        /**
         * 所属bot
         * @note dev: 不会修改，不需要锁
         */
        [[nodiscard]] QQID botid() const;
        /**
         * @brief 回复并发送
         * @param s 内容
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         * @param ms 回复的信息的MessageSource
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         */
        template<typename T>
        MessageSource quoteAndSendMessage(const T &s, MessageSource ms) const {
            return unpackQuote(s, ms);
        }
        /**
         * @brief 回复并发送
         * @param val 内容
         * @note 可以改MessageSource里的内容, 客户端在发送的时候并不会校验MessageSource的内容正确性(比如改originalMessage来改引用的文本的内容, 或者改id来定位到其他信息)
         * @detail 支持以下类型传入
         * - std::string / const char* 相当于传入PlainText(str)
         * - SingleMessage的各种派生类
         * - MessageChain
         */
        template<typename... T>
        MessageSource quoteAndSendMessage(const MessageSource &ms, T &&...val) const {
            return unpackQuote(MessageChain(std::forward<T>(val)...), ms);
        }
        /**
         * @brief 发送信息
         * @tparam T 类型
         * 支持:
         * - SingleMessage的派生类
         * - MessageChain
         * - std::string / const char* 相当于发送PlainText()
         * @param msg 内容
         * @return MessageSource
         */
        template<typename... T>
        MessageSource sendMessage(T &&...msg) const {
            return unpackMsg(MessageChain(std::forward<T>(msg)...));
        }
        /**
         * @brief 发送一条Message
         * @detail 支持
         *  - std::string: 相当于发送PlainText(str)
         *  - MiraiCode 相当于发送反序列化MiraiCode后的
         *  - 各种SingleMessage的派生类
         *  - MessageChain
         *  @param msg Message
         *  @return MessageSource
         */
        template<typename T>
        MessageSource sendMessage(T &&msg) const {
            return unpackMsg(MessageChain(std::forward<T>(msg)));
        }
    public:
        /// 序列化到json对象
        [[nodiscard]] nlohmann::json toJson() const;
        /// 将数据序列化进已有的json对象, 覆盖原有数据
        void updateJson(nlohmann::json &j) const;
        /**
         * 序列化成文本, 可以通过deserializationFromString反序列化, 利于保存
         * @see Contact::fromString()
         */
        [[nodiscard]] std::string toString() const;
        /// 反序列化成Contact智能指针
        /// @param source 序列化后的文本
        static std::shared_ptr<Contact> deserializeToPointer(nlohmann::json source);
        /**
        * @brief 上传本地图片，务必要用绝对路径
        * 由于mirai要区分图片发送对象，所以使用本函数上传的图片只能发到群
        * @attention 最大支持图片大小为30MB
        * @throws
        * -可能抛出UploadException异常代表路径无效或大小大于30MB
        * -可能抛出MemberException找不到群或群成员
        */
        [[nodiscard]] Image uploadImg(const std::string &path) const;
        [[nodiscard]] FlashImage uploadFlashImg(const std::string &path) const;
    protected:
        [[nodiscard]] MessageSource quoteAndSendImpl(std::string msg, const MessageSource &ms) const;
        [[nodiscard]] MessageSource unpackQuote(const SingleMessage &s, const MessageSource &ms) const;
        [[nodiscard]] MessageSource unpackQuote(const std::string &s, const MessageSource &ms) const;
        [[nodiscard]] MessageSource unpackQuote(const MessageChain &mc, const MessageSource &ms) const;
        /// 发送语音
        [[nodiscard]] MessageSource sendVoiceImpl(std::string path) const;
        /// 发送纯文本信息
        /// @throw IllegalArgumentException, TimeOutException, BotIsBeingMutedException
        [[nodiscard]] MessageSource sendMsgImpl(std::string msg) const;
        [[nodiscard]] MessageSource unpackMsg(const MessageChain &msg) const;
        [[nodiscard]] MessageSource unpackMsg(const MiraiCodeable &msg) const;
        [[nodiscard]] MessageSource unpackMsg(std::string msg) const;
    };
    /// @brief Contact类型的数据接口模板类
    /// @note dev: 任何操作内部数据的行为在此处定义。Contact只处理 InternalData 这个 shared_ptr 本身
    template<typename ClassType, typename InternalDataType>
    struct ContactDataHelper {
        typedef InternalDataType DataType;
        using json = nlohmann::json;
    public:
        /// 群名称，群成员群名片，或好友昵称
        [[nodiscard]] std::string nickOrNameCard() const {
            auto clz_ptr = static_cast<const ClassType *>(this);
            return internal::getNickFromIContactPtr(clz_ptr->InternalData.get());
        };
        /// 头像url地址
        [[nodiscard]] std::string avatarUrl() const {
            auto clz_ptr = static_cast<const ClassType *>(this);
            return internal::getNickFromIContactPtr(clz_ptr->InternalData.get());
        };
    };
    class MIRAICP_EXPORT INudgeSupport {
    public:
        virtual ~INudgeSupport() = default;
        /*!
         * @brief 发送戳一戳
         * @warning 仅限Friend, Member类调用
         * @see MiraiCP::Friend::sendNudge, MiraiCP::Member::sendNudge
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        virtual void sendNudge() = 0;
    };
}
#endif
/// Contact.h END

namespace MiraiCP {
    /// 好友类声明
    class MIRAICP_EXPORT Friend : public Contact, public INudgeSupport, public ContactDataHelper<Friend, IContactData> {
        friend class Contact;
    public:
        /*!
         * @brief 构建好友对象
         * @param friendid q号
         * @param botid 对应机器人id
         */
        Friend(QQID friendid, QQID botid);
        /// @brief 构建好友对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "botId":456}
        /// @throw IllegalArgumentException
        explicit Friend(nlohmann::json in_json);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Friend(bool) = delete;
        ~Friend() override = default;
    public:
        /// @brief 删除好友
        /// @note delete是C++关键字
        void deleteFriend();
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
}
#endif
/// Friend.h END

/// BotEvent.h START
#ifndef MIRAICP_PRO_BOTEVENT_H
#define MIRAICP_PRO_BOTEVENT_H
/// Bot.h START
#ifndef MIRAICP_PRO_BOT_H
#define MIRAICP_PRO_BOT_H
#include <string>
#include <vector>
namespace MiraiCP {
    class Friend; /// forward declaration
    class Group;  /// forward declaration
    /// 当前bot账号信息
    class MIRAICP_EXPORT Bot : public Contact {
    public:
        /**
         * 用 id 构造 Bot 对象
         * @param in_id Bot 的 qq id
         */
        explicit Bot(QQID in_id);
    public:
        /**
         * 取 Bot 下对应 id 的好友
         * @param i 好友的 qq id
         * @return 好友对象
         */
        [[nodiscard]] Friend getFriend(QQID i) const;
        /**
         * 取群聊
         * @param groupid 群聊的 id
         * @return 群聊对象
         */
        [[nodiscard]] Group getGroup(QQID groupid) const;
        /// @brief 昵称
        std::string nick();
        /// @brief 头像下载链接
        std::string avatarUrl();
        /// @brief 取好友列表
        [[nodiscard]] std::vector<QQID> getFriendList() const;
        /// @brief 好友列表string形式返回, 利于保存
        [[nodiscard]] std::string FriendListToString() const;
        /// @brief 取群列表
        [[nodiscard]] std::vector<QQID> getGroupList() const;
        /// @brief 群列表string形式返回, 利于保存
        [[nodiscard]] std::string GroupListToString() const;
        /// @brief 取在线 Bot 列表
        [[nodiscard]] std::vector<QQID> getOnlineBotsList() const;
        /// @brief 在线 Bot 列表string形式返回, 利于保存
        [[nodiscard]] std::string OnlineBotsListToString() const;
        bool operator==(const Bot &b) const;
    };
}
#endif
/// Bot.h END

/// Logger.h START
#ifndef MIRAICP_PRO_LOGGER_H
#define MIRAICP_PRO_LOGGER_H
#include <functional>
#include <memory>
#include <sstream>
namespace MiraiCP {
    class MiraiCodeable;
    /*!
    * @class Logger
    * @brief 以MiraiCP的名义发送日志, 日志表现格式是: 2021-06-28 09:37:22 [log level]/MiraiCP: [log content], 为最底层的logger
	* 发送消息级日志
	* @code Logger::logger.info(string) @endcode
	* 发送警告级日志
	* @code Logger::logger.warning(string) @endcode
	* 发送错误级日志
	* @code Logger::logger.error(string) @endcode
    * @doxygenEg{1011, logger.cpp, 自定义日志handle}
    */
    class MIRAICP_EXPORT Logger_interface {
        using string = std::string;
    public:
        /// @brief 封装lambda类型
        /// @param string 日志内容
        /// @param 日志级别
        ///     - 0 info
        ///     - 1 warning
        ///     - 2 error
        typedef std::function<void(string, int)> Action;
        /// @brief loggerhandler会在每次log执行前执行一遍，可用于执行自定义的保存操作等
        struct Handler {
            /// @brief 是否启用
            bool enable = true;
            /// @brief 执行的操作，格式为lambda
            Action action;
        };
        std::shared_ptr<Handler> loggerhandler;
    private:
        static std::string constructString() {
            return "";
        }
        template<class T, class... T1>
        static std::string constructString(T &&val, T1 &&...val1) {
            std::stringstream sstream;
            sstream << val;
            return sstream.str() + constructString(std::forward<T1>(val1)...);
        }
        template<typename... T>
        static std::string constructString(const std::string &a, T &&...val1) {
            return a + constructString(std::forward<T>(val1)...);
        }
        template<typename... T>
        static std::string constructString(const MiraiCodeable &val, T &&...val1) {
            return val.toMiraiCode() + constructString(std::forward<T>(val1)...);
        }
        void create_loggerhandler() {
            loggerhandler = std::make_shared<Handler>();
        }
    protected:
        /// @brief 日志底层实现封装
        /// @param log 日志内容
        /// @param level 日志等级
        virtual void log_interface(const string &log, int level) = 0;
        void handler_trigger(string log, int level);
    public:
        ///发送普通(info级日志)
        template<class... T>
        void info(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 0);
        }
        ///发送警告(warning级日志)
        template<class... T>
        void warning(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 1);
        }
        ///发送错误(error级日志)
        template<class... T>
        void error(T &&...val) {
            this->log_interface(constructString(std::forward<T>(val)...), 2);
        }
        /// @brief 设置loggerhandler的action
        /// @param action 执行的操作
        /// @see Logger::handler
        void registerHandle(Action action);
        /// @brief 设置handler的启用状态
        /// @param state 状态，启用或者关闭
        /// @doxygenEg{1012, logger.cpp, 启用或关闭日志}
        void setHandleState(bool state);
    };
    class MIRAICP_EXPORT Logger : public Logger_interface {
    private:
        Logger() = default;
    protected:
        /// @brief 日志底层实现封装
        /// @param content 日志内容
        /// @param level 日志等级
        void log_interface(const std::string &content, int level) override;
    public:
        static Logger logger;
    };
    /// 带id(一般为bot账号)的logger
    class MIRAICP_EXPORT IdLogger : public Logger_interface {
    public:
        QQID id;
    public:
        IdLogger(QQID inId, Logger *l);
    protected:
        void log_interface(const std::string &content, int level) override;
    };
}
#endif
/// Logger.h END

namespace MiraiCP {
    /// 所有事件处理timeoutevent都是机器人事件，指都有机器人实例
    template<class T>
    class BotEvent : public MiraiCPEvent {
    public:
        [[nodiscard]] eventTypes::Types getEventType() const override { return T::get_event_type(); }
        /// 该事件接受的机器人
        Bot bot;
        /// 以该机器人的名义发送日志
        /// @see BotLogger
        IdLogger botlogger;
        explicit BotEvent(QQID botid) : bot(botid), botlogger(botid, &Logger::logger) {}
        ~BotEvent() override = default;
    };
}
#endif
/// BotEvent.h END

namespace MiraiCP {
    class FriendRecallEvent : public BotEvent<FriendRecallEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::FriendRecallEvent;
        }
    public:
        /// 时间戳
        int time = 0;
        /// 信息发生着
        Friend author;
        /// 信息撤回者
        Friend operater;
        /// 信息id
        std::string ids;
        /// 信息内部ids
        std::string internalIds;
    public:
        explicit FriendRecallEvent(BaseEventData j);
    };
}
#endif
/// FriendRecallEvent.h END
/// NewFriendRequestEvent.h START
#ifndef MIRAICP_PRO_NEWFRIENDREQUESTEVENT_H
#define MIRAICP_PRO_NEWFRIENDREQUESTEVENT_H
/// Group.h START
#ifndef MIRAICP_PRO_GROUP_H
#define MIRAICP_PRO_GROUP_H
#include <nlohmann/json_fwd.hpp>
#include <utility>
namespace MiraiCP {
    class Group;
    namespace internal {
        struct GroupSetting {
            /// 群名称
            std::string name;
            /// 禁言全部
            bool isMuteAll{};
            /// 允许群成员邀请
            bool isAllowMemberInvite{};
            /// 自动同意进群
            bool isAutoApproveEnabled{};
            /// 允许匿名聊天
            bool isAnonymousChatEnabled{};
        };
        struct AnnouncementParams {
            /// 发送给新成员
            bool send2new;
            /// 需要确认
            bool requireConfirm;
            /// 置顶
            bool pinned;
            /// 引导群成员修改群名片
            bool showEditCard;
            /// 显示弹窗
            bool showPopup;
            /// 序列化到文本
            nlohmann::json serializeToJson();
        };
        struct OnlineAnnouncement {
            /// 内容
            std::string content;
            /// 所属bot
            QQID botId;
            /// 所在群id
            QQID groupId;
            /// 发送者id
            QQID senderId;
            /// 发送时间戳
            long long publicationTime;
            /// 唯一识别属性
            std::string fid;
            /// 图片id, 如果不存在即为空
            std::string imageId;
            /// 如果需要确认，即为确认的人数
            int confirmNum;
            /// 公告属性
            AnnouncementParams params;
            /// 删除当前群公告
            /// @throw BotException
            void deleteThis();
            /// 反序列化
            static OnlineAnnouncement deserializeFromJson(const nlohmann::json &);
        };
        struct OfflineAnnouncement {
            /// 内容
            std::string content;
            /// 公告属性
            AnnouncementParams params;
            /// 发布群公告
            OnlineAnnouncement publishTo(const Group &);
        };
    }
    class Member;     /// forward declaration
    struct GroupData; /// forward declaration
    /*!
     * @brief 群聊类
     */
    class MIRAICP_EXPORT Group : public Contact, public ContactDataHelper<Group, GroupData> {
    private:
        friend class Contact;
        /**
         * @brief 群设置
         * @details 使用 Group::updateSetting 上传设置，后面两项由于 https://github.com/mamoe/mirai/issues/1307 还不能改
         */
    public:
        /// 群设置
        using GroupSetting = ::MiraiCP::internal::GroupSetting;
        /// 群公告参数
        using AnnouncementParams = ::MiraiCP::internal::AnnouncementParams;
        /// 在线群公告
        using OnlineAnnouncement = ::MiraiCP::internal::OnlineAnnouncement;
        /// 本地(未发送)群公告
        using OfflineAnnouncement = ::MiraiCP::internal::OfflineAnnouncement;
        DECL_GETTER(GroupSetting, setting)
        /// 群文件的简短描述
        struct file_short_info {
            /// 路径带文件名
            std::string path;
            /// 唯一id
            std::string id;
        };
        /// 群荣耀类型
        /// @note 与这里的值对应: <https://github.com/mamoe/mirai/blob/v2.13.4/mirai-core-api/src/commonMain/kotlin/data/GroupHonorType.kt#L52>
        enum HonorMemberType {
            /// 龙王
            TALKATIVE = 1,
        };
    public:
        ///  @brief 构建以群号构建群对象
        /// @param groupId 群号
        /// @param botId 机器人id
        /// @doxygenEg{1007, group.cpp, 从群号构建群对象}
        Group(QQID groupId, QQID botId);
        /// @brief 构建群对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "botId":456}
        /// @throw IllegalArgumentException
        explicit Group(nlohmann::json in_json);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Group(bool) = delete;
        ~Group() override = default;
    public:
        /// @brief 获取groupId
        /// @note 同 id()
        QQID groupId();
        /**
         * @brief 更新群设置, 即覆盖服务器上的群设置
         * @details 从服务器拉去群设置用refreshInfo
         * @param newSetting 新的设置
         * @see Group::refreshInfo()
         */
        void updateSetting(GroupSetting newSetting);
        /// 取群成员列表
        /// @return vector<long>
        std::vector<unsigned long long> getMemberList();
        /*!
         * 以string格式取群成员列表
         * @note 格式:
         *  每个群成员id间用逗号分隔
        */
        std::string MemberListToString();
        /// 取群主
        Member getOwner();
        /// 取群成员
        Member getMember(QQID memberid);
        Member operator[](QQID id);
        /// 取群公告列表
        std::vector<OnlineAnnouncement> getAnnouncementsList();
        /// 退群
        void quit();
        /*!
        @brief 上传并发送远程(群)文件
        @param path-群文件路径(带文件名),根目录为/
        @param filepath-本地文件路径
        @attention 路径分隔符是 `/`
        @doxygenEg{1008, group.cpp, 发送群文件}
        */
        RemoteFile sendFile(const std::string &path, const std::string &filepath);
        /// 发送语音
        MessageSource sendVoice(std::string path);
        /*!
        取群文件信息,会自动搜索子目录
        @param path-群文件路径(不带文件名)
        @param id-文件id,可空，空则为用路径查找(此时路径要带文件名)
        @attention 因为群文件允许重名文件存在的特性，如果没有id该查找并不可靠，只能返回重名文件中的其中一个文件
        @see RemoteFile
        @doxygenEg{1009, group.cpp, 获取群文件}
        */
        RemoteFile getFile(const std::string &path, const std::string &id = std::string());
        /*!
         * @brief 取文件信息(根据id)
         * @param id 文件id
         * @return 文件
         * @detail 相当于从根目录开始遍历查找文件, 相当于getFile("/", id);
         */
        RemoteFile getFileById(const std::string &id);
        RemoteFile getFileByFile(const RemoteFile &file) {
            return getFileById(file.id);
        }
        /*!
         * 获取path路径下全部文件信息
         * @param path - 远程路径
         * @return 返回值为一个vector容器, 每一项为short_info
         * @doxygenEg{1010, group.cpp, 获取群文件列表}
        */
        std::vector<file_short_info> getFileList(const std::string &path);
        /// 取文件列表以字符串形式返回
        /// @param path 文件夹路径
        std::string getFileListString(const std::string &path);
        /// 查询目前拥有对应群荣耀的成员
        std::optional<Member> queryCurrentHonorMember(HonorMemberType);
    };
}
#endif
/// Group.h END

namespace MiraiCP {
    /// 好友申请事件声明
    class NewFriendRequestEvent : public BotEvent<NewFriendRequestEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::NewFriendRequestEvent;
        }
    public:
        /// @brief 序列化的事件信息
        std::string source;
        /// @brief 对方id
        Friend from;
        /// 如果是从群聊申请的则为来源群, 否则为空
        std::optional<Group> fromGroup;
        /// @brief 对方昵称
        std::string nick;
        /// @brief 申请理由
        std::string message;
        /// @brief 事件识别 id
        size_t requestEventId;
        /// @brief 拒绝好友申请
        /// @param ban - 是否加入黑名单
        void reject(bool ban = false);
        /// @brief 接受好友申请
        void accept();
        explicit NewFriendRequestEvent(BaseEventData j);
    };
}
#endif
/// NewFriendRequestEvent.h END
/// GroupInviteEvent.h START
#ifndef MIRAICP_PRO_GROUPINVITEEVENT_H
#define MIRAICP_PRO_GROUPINVITEEVENT_H
namespace MiraiCP {
    /// 群聊邀请事件类声明
    class GroupInviteEvent : public BotEvent<GroupInviteEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::GroupInviteEvent;
        }
    public:
        /// 事件序列化文本
        std::string source;
        /// 发起人昵称
        std::string inviterNick;
        /// 被邀请进的组
        std::string groupName;
        /// 群号
        Group group;
        /// 邀请的好友, 如果在邀请后删除好友则为空
        Friend inviter;
        /// 本次申请 id
        size_t requestEventId = 0;
        void reject();
        void accept();
        explicit GroupInviteEvent(BaseEventData j);
    };
}
#endif
/// GroupInviteEvent.h END
/// GroupTempMessageEvent.h START
#ifndef MIRAICP_PRO_GROUPTEMPMESSAGEEVENT_H
#define MIRAICP_PRO_GROUPTEMPMESSAGEEVENT_H
/// Member.h START
#ifndef MIRAICP_PRO_MEMBER_H
#define MIRAICP_PRO_MEMBER_H
namespace MiraiCP {
    /*!
     * @brief Member数据声明
     */
    struct MemberData;
    /*!
     * @brief 群成员类声明
     * @doxygenEg{1013, member.cpp, 群成员操作}
     */
    class MIRAICP_EXPORT Member : public Contact, public INudgeSupport, public ContactDataHelper<Member, MemberData> {
        friend class Contact;
    public:
        /// @brief 构建群成员对象，一般为内部调用
        /// @param in_json 内容至少如下：{"id":123, "groupId":456, "botId":789}
        /// @throw IllegalArgumentException
        explicit Member(nlohmann::json in_json);
        /// @brief 构建群成员对象
        /// @param qqid 该成员q号
        /// @param groupid 所在群号
        /// @param botid 机器人id
        explicit Member(QQID qqid, QQID groupid, QQID botid);
        /// @note dev: avoid unintentional implicit conversion to nlohmann::json
        Member(bool) = delete;
        ~Member() override = default;
        /// 是否是匿名群成员, 如果是匿名群成员一些功能会受限
        DECL_GETTER(bool, anonymous)
        /// @brief 权限等级
        ///     - OWNER群主 为 2
        ///     - ADMINISTRATOR管理员 为 1
        ///     - MEMBER群成员 为 0
        DECL_GETTER(unsigned int, permission)
        /// 群头衔
        DECL_GETTER(std::string, specialTitle)
        DECL_GETTER(QQID, groupId)
    public:
        /// @brief 更改群成员权限
        /// @param admin 如果为true为更改到管理员
        /// @param env
        void modifyAdmin(bool admin);
        /// @brief 更改群成员群头衔
        /// @throws BotException 如果没权限时
        void changeSpecialTitle(std::string_view);
        /// 发送语音
        MessageSource sendVoice(std::string path) {
            return sendVoiceImpl(std::move(path));
        }
        /*!
         * 禁言当前对象，单位是秒，最少0秒最大30天，如果为0或者为负则unmute
         * @throws BotException, MuteException
        */
        void mute(long long sec) const;
        /*!
         * 使用现代C++时间禁言对象，可以是任意时间，传参时会被自动转换为秒
         * @throws BotException, MuteException
        */
        void mute(std::chrono::seconds time) const {
            mute(time.count());
        }
        /// 取消禁言
        /// @throws BotException, MuteException
        void unMute() const {
            mute(0);
        }
        /*! 踢出这个群成员
        * @param reason - 原因
        */
        void kick(std::string reason);
        /// At一个群成员
        At at() { return At(this->id()); }
        /// 更改群名片
        /// @throw MiraiCP::BotException 如果没权限时
        void changeNameCard(std::string_view newName);
        /*!
         * @brief 发送戳一戳
         * @warning 发送戳一戳的前提是登录该bot的协议是android_phone/ipad, 否则抛出IllegalStateException
         * @throw MiraiCP::BotException, MiraiCP::IllegalStateException
         */
        void sendNudge() override;
    };
}
#endif
/// Member.h END

namespace MiraiCP {
    /// 群临时会话
    class GroupTempMessageEvent : public BotEvent<GroupTempMessageEvent>, public IMessageEvent {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::GroupTempMessageEvent;
        }
    public:
        /// 来源群
        Group group;
        /// 发送人
        Member sender;
        /// 信息
        MessageChain message;
    public:
        explicit GroupTempMessageEvent(BaseEventData j);
    public:
        Contact *chat() override {
            return &sender;
        }
        const Contact *chat() const override {
            return &sender;
        }
        Contact *from() override {
            return &sender;
        }
        const Contact *from() const override {
            return &sender;
        }
        MessageChain *getMessageChain() override {
            return &message;
        }
        const MessageChain *getMessageChain() const override {
            return &message;
        }
    };
}
#endif
/// GroupTempMessageEvent.h END
/// TimeOutEvent.h START
#ifndef MIRAICP_PRO_TIMEOUTEVENT_H
#define MIRAICP_PRO_TIMEOUTEVENT_H
#include <string>
namespace MiraiCP {
    /// 定时任务结束
    class TimeOutEvent : public MiraiCPEvent {
    public:
        /// 事件所附信息
        std::string msg;
    public:
        explicit TimeOutEvent(std::string msg) : msg(std::move(msg)) {}
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::TimeOutEvent;
        }
        eventTypes::Types getEventType() const override { return get_event_type(); }
    };
}
#endif
/// TimeOutEvent.h END
/// MiraiCPExceptionEvent.h START
#ifndef MIRAICP_PRO_MIRAICPEXCEPTIONEVENT_H
#define MIRAICP_PRO_MIRAICPEXCEPTIONEVENT_H
namespace MiraiCP {
    class MiraiCPExceptionBase;
    /// @brief 异常抛出事件
    class MiraiCPExceptionEvent : public MiraiCPEvent {
    private:
        MiraiCPExceptionBase *exceptionPtr;
    public:
        explicit MiraiCPExceptionEvent(MiraiCPExceptionBase *err) {
            exceptionPtr = err;
        }
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MiraiCPExceptionEvent;
        }
        eventTypes::Types getEventType() const override { return get_event_type(); }
        const MiraiCPExceptionBase *getException() const {
            return exceptionPtr;
        }
    };
}
#endif
/// MiraiCPExceptionEvent.h END
/// MemberRecallEvent.h START
#ifndef MIRAICP_PRO_MEMBERRECALLEVENT_H
#define MIRAICP_PRO_MEMBERRECALLEVENT_H
namespace MiraiCP {
    class MemberRecallEvent : public BotEvent<MemberRecallEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberRecallEvent;
        }
    public:
        /// 时间戳
        int time = 0;
        /// 信息发生着
        Member author;
        /// 信息撤回者
        Member operater;
        /// 信息id
        std::string ids;
        /// 信息内部ids
        std::string internalIds;
    public:
        explicit MemberRecallEvent(BaseEventData j);
    };
}
#endif
/// MemberRecallEvent.h END
/// PrivateMessageEvent.h START
#ifndef MIRAICP_PRO_PRIVATEMESSAGEEVENT_H
#define MIRAICP_PRO_PRIVATEMESSAGEEVENT_H
namespace MiraiCP {
    /*!
     * @detail 私聊消息事件类声明
     * @doxygenEg{1004, group.cpp, 取好友下一条信息}
     */
    class PrivateMessageEvent : public BotEvent<PrivateMessageEvent>, public IMessageEvent {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::FriendMessageEvent;
        }
    public:
        /// 发起人
        Friend sender;
        /// 信息
        MessageChain message{};
        /*!
         * @brief 构建私聊信息
         * @param botid 对应botid
         * @param sender 发送者
         * @param message 消息
         * @param messageSource 消息源
         */
        explicit PrivateMessageEvent(BaseEventData j);
        /*!
         * @brief 取下一个消息(发送人和接收人和本事件一样)
         * @warning 如果两次发送信息间隔过短可能会漏过信息
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不被注册的监听器收到处理)
         * @return 消息链
         */
        MessageChain nextMessage(long time = -1, bool halt = true) const;
    public:
        Contact *chat() override {
            return &sender;
        }
        const Contact *chat() const override {
            return &sender;
        }
        Contact *from() override {
            return &sender;
        }
        const Contact *from() const override {
            return &sender;
        }
        MessageChain *getMessageChain() override {
            return &message;
        }
        const MessageChain *getMessageChain() const override {
            return &message;
        }
    };
}
#endif
/// PrivateMessageEvent.h END
/// MessagePreSendEvent.h START
#ifndef MIRAICP_PRO_MESSAGEPRESENDEVENT_H
#define MIRAICP_PRO_MESSAGEPRESENDEVENT_H
namespace MiraiCP {
    class Contact;
    /*! 每条消息发送前的事件, 总是在消息实际上被发送和广播MessagePostSendEvent前广播
     * @see MessagePostSendEvent
     * @warning 在这个事件里小心使用sendMessage, 可能会触发无限递归 preSend -> sendMessage -> preSend -> ...
     * */
    class MessagePreSendEvent : public BotEvent<MessagePreSendEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MessagePreSendEvent;
        }
    public:
        /// 发送目标
        std::shared_ptr<Contact> target;
        /// 消息
        MessageChain message;
        explicit MessagePreSendEvent(BaseEventData j);
    };
}
#endif
/// MessagePreSendEvent.h END
/// BotJoinGroupEvent.h START
#ifndef MIRAICP_PRO_BOTJOINGROUPEVENT_H
#define MIRAICP_PRO_BOTJOINGROUPEVENT_H
namespace MiraiCP {
    /// 机器人进入某群
    class BotJoinGroupEvent : public BotEvent<BotJoinGroupEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::BotJoinGroupEvent;
        }
    public:
        /// 进入的群
        Group group;
        /// 当type=2时存在，为邀请人，否则为空，调用可能会报错
        std::optional<Member> inviter;
        /// 1-主动加入,2-被邀请加入,3-提供恢复群主身份加入
        int type;
    public:
        explicit BotJoinGroupEvent(BaseEventData j);
    };
}
#endif
/// BotJoinGroupEvent.h END
/// MemberJoinRequestEvent.h START
#ifndef MIRAICP_PRO_MEMBERJOINREQUESTEVENT_H
#define MIRAICP_PRO_MEMBERJOINREQUESTEVENT_H
namespace MiraiCP {
    /// 申请加群事件, bot需为管理员或者群主
    class MemberJoinRequestEvent : public BotEvent<MemberJoinRequestEvent> {
    private:
        std::string source;
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberJoinRequestEvent;
        }
    public:
        /// 申请的群, 如果不存在就表明广播这个事件的时候机器人已经退出该群
        Group group;
        /// 邀请人, 如果不存在表明这个邀请人退出了群或没有邀请人为主动进群
        std::optional<Member> inviter;
        /// 申请人
        Member from;
        /// 申请人昵称
        std::string fromNick;
        /// 申请信息
        std::string message;
    public:
        explicit MemberJoinRequestEvent(BaseEventData j);
        /// 通过
        void accept();
        /// 拒绝
        void reject(std::string msg);
    };
}
#endif
/// MemberJoinRequestEvent.h END
/// NudgeEvent.h START
#ifndef MIRAICP_PRO_NUDGEEVENT_H
#define MIRAICP_PRO_NUDGEEVENT_H
namespace MiraiCP {
    class Contact;
    /*! 戳一戳事件
     * @warning nudgeEvent事件也会被bot自己发的Nudge触发, 可能会造成无限循环
     */
    class NudgeEvent : public BotEvent<NudgeEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::NudgeEvent;
        }
    public:
        ///发送人
        std::shared_ptr<Contact> from;
        /// 目标
        std::shared_ptr<Contact> target;
        /// 发送的环境, 可能为Group / Friend
        std::shared_ptr<Contact> subject;
    public:
        explicit NudgeEvent(BaseEventData j);
    };
}
#endif
/// NudgeEvent.h END
/// BotOnlineEvent.h START
#ifndef MIRAICP_PRO_BOTONLINEEVENT_H
#define MIRAICP_PRO_BOTONLINEEVENT_H
namespace MiraiCP {
    /// 机器人上线事件
    class BotOnlineEvent : public BotEvent<BotOnlineEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::BotOnlineEvent;
        }
    public:
        explicit BotOnlineEvent(QQID botid) : BotEvent(botid) {}
    };
}
#endif
/// BotOnlineEvent.h END
/// MemberLeaveEvent.h START
#ifndef MIRAICP_PRO_MEMBERLEAVEEVENT_H
#define MIRAICP_PRO_MEMBERLEAVEEVENT_H
namespace MiraiCP {
    /// 群成员离开
    class MemberLeaveEvent : public BotEvent<MemberLeaveEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberLeaveEvent;
        }
    public:
        /// 退出的成员q号
        Member member;
        /// 目标群
        Group group;
        /// 操作人, 主动退出时与member相同，该成员可能是当前bot，名称为operater以与系统operator区分
        std::optional<Member> operater;
        /*!
        * @brief 事件类型
        *           1 - 被踢出
        *           2 - 主动退出
        */
        int type = 0;
    public:
        explicit MemberLeaveEvent(BaseEventData j);
    };
}
#endif
/// MemberLeaveEvent.h END
/// MemberJoinEvent.h START
#ifndef MIRAICP_PRO_MEMBERJOINEVENT_H
#define MIRAICP_PRO_MEMBERJOINEVENT_H
namespace MiraiCP {
    /// 新群成员加入
    class MemberJoinEvent : public BotEvent<MemberJoinEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::MemberJoinEvent;
        }
    public:
        enum joinType {
            error = 0,
            invited = 1,
            applied = 2,
            rehab = 3
        };
        /*!
        * @brief 事件类型
        *   1 - 被邀请进来
        *   2 - 主动加入
        *   3 - 原群主通过 https://huifu.qq.com/ 恢复原来群主身份并入群
        */
        joinType type = joinType::error;
        ///新进入的成员
        Member member;
        ///目标群
        Group group;
        ///邀请人, 当type = 1时存在，否则则和member变量相同
        std::optional<Member> inviter;
        explicit MemberJoinEvent(BaseEventData j);
    };
}
#endif
/// MemberJoinEvent.h END
/// GroupMessageEvent.h START
#ifndef MIRAICP_PRO_GROUPMESSAGEEVENT_H
#define MIRAICP_PRO_GROUPMESSAGEEVENT_H
namespace MiraiCP {
    /*!
     * @brief 群消息事件声明
     * @doxygenEg{1003, group.cpp, 取群聊下一条消息}
     */
    class GroupMessageEvent : public BotEvent<GroupMessageEvent>, public IMessageEvent {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::GroupMessageEvent;
        }
    public:
        ///来源群
        Group group;
        ///发送人
        Member sender;
        /// 信息
        MessageChain message;
        explicit GroupMessageEvent(BaseEventData j);
        /*!
         * @brief 取群聊下一个消息(群聊与本事件一样)
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不让这个消息被注册的其他监听器收到处理)
         * @return 消息链
         */
        MessageChain nextMessage(long time = -1, bool halt = true) const;
        /*!
         * @brief 取群聊中同群成员的下一个消息(发送人和群与本事件一样)
         * @param time 超时时间限制, 单位为ms, 超时后抛出TimeOutException
         * @param halt 是否拦截该事件(不让消息被注册的其他监听器收到处理)
         * @return 消息链
         */
        MessageChain senderNextMessage(long time = -1, bool halt = true) const;
    public:
        Contact *chat() override {
            return &group;
        }
        const Contact *chat() const override {
            return &group;
        }
        Contact *from() override {
            return &sender;
        }
        const Contact *from() const override {
            return &sender;
        }
        MessageChain *getMessageChain() override {
            return &message;
        }
        const MessageChain *getMessageChain() const override {
            return &message;
        }
    };
}
#endif
/// GroupMessageEvent.h END
/// BotLeaveEvent.h START
#ifndef MIRAICP_PRO_BOTLEAVEEVENT_H
#define MIRAICP_PRO_BOTLEAVEEVENT_H
namespace MiraiCP {
    /// 机器人退群事件
    /// 可能有3种类型, 主动退/被踢/解散
    /// 目前mirai的botLeave事件还不稳定暂时不支持类型
    class BotLeaveEvent : public BotEvent<BotLeaveEvent> {
    public:
        static eventTypes::Types get_event_type() {
            return eventTypes::Types::BotLeaveEvent;
        }
        /// 事件类型
        enum class EventType {
            /// 主动退出
            Active = 0,
            /// 被踢出
            Kick,
            /// 群被解散
            Disband
        };
    public:
        /// 退出的群
        /// @attension 收到这个事件时已经退出该群, 可能取不到相关信息
        Group group;
        EventType type;
        Member operater;
    public:
        explicit BotLeaveEvent(BaseEventData j);
    };
}
#endif
/// BotLeaveEvent.h END
